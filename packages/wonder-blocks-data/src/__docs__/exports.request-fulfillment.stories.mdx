import {Meta} from "@storybook/addon-docs";

<Meta
    title="Data / Exports / RequestFulfillment"
    parameters={{
        chromatic: {
            disableSnapshot: true,
        },
    }}
/>

# RequestFulfillment

The `RequestFulfillment` class encapsulates tracking of inflight asynchronous actions keyed by an identifier. Using this API, callers can request the result of the same asynchronous action multiple times without invoking the underlying action more than is necessary. Instead, any pending request will be shared by all requests for the same identifier.

## Usage

```ts
    fulfill: <TData: ValidCacheData>(
        id: string,
        options: {|
            handler: () => Promise<TData>,
            hydrate?: boolean,
        |},
    ) => Promise<Result<TData>>;
```

There is a single function on the `RequestFulfillment` class, called `fulfill`.

The `fulfill` method takes the request identifier (used to deduplicate requests) and an options object. The options object contains the following properties:

 * `handler`: A function that returns a promise resolving to the result of the request. This is the asynchronous work that will be tracked by the given identifier.
 * `hydrate`: A boolean indicating whether the data should be hydrated. This is used during server-side rendering to determine if the response data should be included in the hydration cache. This defaults to `true` and should only be set to `false` if you are performing server-side rendering of the request and you know that the data will not be needed for hydration to succeed.

## RequestFulfillment.Default
The `RequestFulfillment` class provides a static instance, `RequestFulfillment.Default`, which is used by the Wonder Blocks Data framework. However, a custom instance can be constructed should your specific use case need to be isolated from others.
