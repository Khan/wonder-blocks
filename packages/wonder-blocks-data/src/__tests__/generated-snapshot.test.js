// This file is auto-generated by gen-snapshot-tests.js
// Do not edit this file.  To make changes to these snapshot tests:
//   1. edit the markdown documentation files in the package,
//        packages/wonder-blocks-data
//   2. Run `yarn run gen-snapshot-tests`.
import React from "react";
import renderer from "react-test-renderer";

// Mock react-dom as jest doesn't like findDOMNode.
jest.mock("react-dom");
import {Body, BodyMonospace} from "@khanacademy/wonder-blocks-typography";
import {View, Server} from "@khanacademy/wonder-blocks-core";
import {
    Data,
    initializeHydrationCache,
    InterceptRequests,
    TrackData,
    fulfillAllDataRequests,
} from "@khanacademy/wonder-blocks-data";
import {Strut} from "@khanacademy/wonder-blocks-layout";
import Color from "@khanacademy/wonder-blocks-color";
import Spacing from "@khanacademy/wonder-blocks-spacing";
import Button from "@khanacademy/wonder-blocks-button";

describe("wonder-blocks-data", () => {
    it("example 1", () => {
        const myValidHandler = () =>
            new Promise((resolve, reject) =>
                setTimeout(() => resolve("I'm DATA from a request"), 3000),
            );

        const myInvalidHandler = () =>
            new Promise((resolve, reject) =>
                setTimeout(() => reject("I'm an ERROR from a request"), 3000),
            );

        const example = (
            <View>
                <View>
                    <Body>This request will succeed and give us data!</Body>
                    <Data handler={myValidHandler} requestId="VALID">
                        {(result) => {
                            if (result.status === "loading") {
                                return "Loading...";
                            }

                            return <BodyMonospace>{result.data}</BodyMonospace>;
                        }}
                    </Data>
                </View>
                <Strut size={Spacing.small_12} />
                <View>
                    <Body>This request will go boom and give us an error!</Body>
                    <Data handler={myInvalidHandler} requestId="INVALID">
                        {(result) => {
                            if (result.status === "loading") {
                                return "Loading...";
                            }

                            return (
                                <BodyMonospace
                                    style={{
                                        color: Color.red,
                                    }}
                                >
                                    ERROR: {result.error}
                                </BodyMonospace>
                            );
                        }}
                    </Data>
                </View>
            </View>
        );
        const tree = renderer.create(example).toJSON();
        expect(tree).toMatchSnapshot();
    });

    it("example 2", () => {
        const myHandler = () => {
            throw new Error(
                "If you're seeing this error, the examples are broken and data isn't in the cache that should be.",
            );
        };

        initializeHydrationCache({
            DATA: {
                data: "I'm DATA from the hydration cache",
            },
        });
        const example = (
            <View>
                <View>
                    <Body>This cache has data!</Body>
                    <Data handler={myHandler} requestId="DATA">
                        {(result) => {
                            if (result.status !== "success") {
                                return "If you see this, the example is broken!";
                            }

                            return <BodyMonospace>{result.data}</BodyMonospace>;
                        }}
                    </Data>
                </View>
            </View>
        );
        const tree = renderer.create(example).toJSON();
        expect(tree).toMatchSnapshot();
    });

    it("example 3", () => {
        const myHandler = () =>
            Promise.reject(new Error("You should not see this!"));

        const interceptor = (requestId) =>
            requestId === "INTERCEPT_EXAMPLE"
                ? Promise.resolve("INTERCEPTED DATA!")
                : null;

        const example = (
            <InterceptRequests interceptor={interceptor}>
                <View>
                    <Body>This received intercepted data!</Body>
                    <Data handler={myHandler} requestId="INTERCEPT_EXAMPLE">
                        {(result) => {
                            if (result.status !== "success") {
                                return "If you see this, the example is broken!";
                            }

                            return <BodyMonospace>{result.data}</BodyMonospace>;
                        }}
                    </Data>
                </View>
            </InterceptRequests>
        );
        const tree = renderer.create(example).toJSON();
        expect(tree).toMatchSnapshot();
    });

    it("example 4", () => {
        class ErrorBoundary extends React.Component {
            constructor(props) {
                super(props);
                this.state = {};
            }

            static getDerivedStateFromError(error) {
                return {
                    error: error.message,
                };
            }

            render() {
                if (typeof jest !== "undefined") {
                    /**
                     * The snapshot test just sees the error getting thrown, not the
                     * awesome error boundary, so we have to hack around it to keep
                     * this live example, but not get test failures.
                     */
                    return "Sorry, no snapshot for you";
                }

                if (this.state.error) {
                    return <View>{this.state.error}</View>;
                }

                return this.props.children;
            }
        }

        const example = (
            <ErrorBoundary>
                <View>
                    <TrackData>
                        <Body>
                            This only renders if we're in server-side mode and
                            the page hot reloaded
                        </Body>
                    </TrackData>
                </View>
            </ErrorBoundary>
        );
        const tree = renderer.create(example).toJSON();
        expect(tree).toMatchSnapshot();
    });

    it("example 5", () => {
        const myPretendHandler = () =>
            new Promise((resolve, reject) =>
                setTimeout(() => resolve("DATA!"), 3000),
            );

        class Example extends React.Component {
            constructor() {
                super();
                /**
                 * For this demonstration, we need to hack the return of isServerSide solely
                 * for the scope of this component.
                 */

                this.state = {};
            }

            static getDerivedStateFromError(error) {
                return {
                    error,
                };
            }

            componentDidMount() {
                this._mounted = true;
            }

            componentWillUnmount() {
                this._mounted = false;
            }

            setClientMode() {
                window.location.reload();
            }

            setServerMode() {
                Server.setServerSide();
                this.setState({
                    refresh: Date.now(),
                    error: null,
                });
            }

            _renderErrorOrContent() {
                if (typeof jest !== "undefined") {
                    /**
                     * The snapshot test just sees the error getting thrown, not the
                     * awesome error boundary, so we have to hack around it to keep
                     * this live example, but not get test failures.
                     */
                    return "Sorry, no snapshot for you";
                }

                if (this.state.error) {
                    return (
                        <React.Fragment>
                            <Strut size={Spacing.small_12} />
                            <Body>
                                We can't show you anything useful in client-side
                                mode
                            </Body>
                        </React.Fragment>
                    );
                }

                const data = this.state.data
                    ? JSON.stringify(this.state.data, undefined, "  ")
                    : "Data requested...";
                return (
                    <React.Fragment>
                        <Strut size={Spacing.small_12} />
                        <TrackData>
                            <Data
                                handler={myPretendHandler}
                                requestId="TRACK_DATA_EXAMPLE"
                            >
                                {(result) => (
                                    <View>
                                        <BodyMonospace>{`Loading: ${
                                            result.status === "loading"
                                        }`}</BodyMonospace>
                                        <BodyMonospace>{`Data: ${JSON.stringify(
                                            result.data,
                                        )}`}</BodyMonospace>
                                    </View>
                                )}
                            </Data>
                        </TrackData>
                        <Strut size={Spacing.small_12} />
                        <View>
                            <Body>
                                The above components requested data, but we're
                                server-side, so all that happened is we tracked
                                the request. In this example, we've also called
                                `fulfillAllDataRequests` to fetch that tracked
                                data.
                            </Body>
                            <Strut size={Spacing.small_12} />
                            <Body>
                                In about 3 seconds, it will appear below. Notice
                                that when it does, the above still doesn't
                                update. That's because during SSR, the data is
                                not updated in the rendered tree.
                            </Body>
                            <Strut size={Spacing.small_12} />
                            <BodyMonospace>{data}</BodyMonospace>
                        </View>
                    </React.Fragment>
                );
            }

            render() {
                try {
                    return (
                        <View key={this.state.refresh}>
                            {Server.isServerSide() ? (
                                <React.Fragment>
                                    <Button
                                        kind={"secondary"}
                                        onClick={() => this.setClientMode()}
                                    >
                                        Back to Client-side Mode (reloads page)
                                    </Button>
                                    <Strut size={Spacing.small_12} />
                                    <Button
                                        kind={"secondary"}
                                        onClick={() => this.setServerMode()}
                                    >
                                        Re-mount
                                    </Button>
                                </React.Fragment>
                            ) : (
                                <Button
                                    kind={"primary"}
                                    onClick={() => this.setServerMode()}
                                >
                                    Enable Server-side Mode
                                </Button>
                            )}
                            {this._renderErrorOrContent()}
                        </View>
                    );
                } finally {
                    if (!this.state.data && Server.isServerSide()) {
                        setTimeout(
                            () =>
                                fulfillAllDataRequests().then((data) => {
                                    if (this._mounted) {
                                        this.setState({
                                            data,
                                        });
                                    }
                                }),
                            0,
                        );
                    }
                }
            }
        }

        const example = <Example />;
        const tree = renderer.create(example).toJSON();
        expect(tree).toMatchSnapshot();
    });
});
