{"version":3,"file":"2957.6c16a7ef.iframe.bundle.js","mappings":";;AAKA;;AAEA;AACA;ACFA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;;;AAIA;;AAEA;;;ACxCA","sources":["webpack://wonder-blocks/./node_modules/@storybook/addon-backgrounds/dist/chunk-GRJZJKJ4.mjs","webpack://wonder-blocks/./node_modules/@storybook/addon-outline/dist/preview.mjs","webpack://wonder-blocks/./node_modules/@storybook/testing-library/dist/index.mjs"],"sourcesContent":["import { global } from '@storybook/global';\nimport { dedent } from 'ts-dedent';\nimport { logger } from '@storybook/client-logger';\n\nvar ADDON_ID=\"storybook/background\",PARAM_KEY=\"backgrounds\";var {document,window}=global,isReduceMotionEnabled=()=>window.matchMedia(\"(prefers-reduced-motion: reduce)\").matches,getBackgroundColorByName=(currentSelectedValue,backgrounds=[],defaultName)=>{if(currentSelectedValue===\"transparent\")return \"transparent\";if(backgrounds.find(background=>background.value===currentSelectedValue))return currentSelectedValue;let defaultBackground=backgrounds.find(background=>background.name===defaultName);if(defaultBackground)return defaultBackground.value;if(defaultName){let availableColors=backgrounds.map(background=>background.name).join(\", \");logger.warn(dedent`\n        Backgrounds Addon: could not find the default color \"${defaultName}\".\n        These are the available colors for your story based on your configuration:\n        ${availableColors}.\n      `);}return \"transparent\"},clearStyles=selector=>{(Array.isArray(selector)?selector:[selector]).forEach(clearStyle);},clearStyle=selector=>{let element=document.getElementById(selector);element&&element.parentElement.removeChild(element);},addGridStyle=(selector,css)=>{let existingStyle=document.getElementById(selector);if(existingStyle)existingStyle.innerHTML!==css&&(existingStyle.innerHTML=css);else {let style=document.createElement(\"style\");style.setAttribute(\"id\",selector),style.innerHTML=css,document.head.appendChild(style);}},addBackgroundStyle=(selector,css,storyId)=>{let existingStyle=document.getElementById(selector);if(existingStyle)existingStyle.innerHTML!==css&&(existingStyle.innerHTML=css);else {let style=document.createElement(\"style\");style.setAttribute(\"id\",selector),style.innerHTML=css;let gridStyleSelector=`addon-backgrounds-grid${storyId?`-docs-${storyId}`:\"\"}`,existingGridStyle=document.getElementById(gridStyleSelector);existingGridStyle?existingGridStyle.parentElement.insertBefore(style,existingGridStyle):document.head.appendChild(style);}};\n\nexport { ADDON_ID, PARAM_KEY, addBackgroundStyle, addGridStyle, clearStyles, getBackgroundColorByName, isReduceMotionEnabled };\n","import { PARAM_KEY } from './chunk-2DMOCDBJ.mjs';\nimport { useMemo, useEffect } from '@storybook/preview-api';\nimport { global } from '@storybook/global';\nimport { dedent } from 'ts-dedent';\n\nvar clearStyles=selector=>{(Array.isArray(selector)?selector:[selector]).forEach(clearStyle);},clearStyle=input=>{let selector=typeof input==\"string\"?input:input.join(\"\"),element=global.document.getElementById(selector);element&&element.parentElement&&element.parentElement.removeChild(element);},addOutlineStyles=(selector,css)=>{let existingStyle=global.document.getElementById(selector);if(existingStyle)existingStyle.innerHTML!==css&&(existingStyle.innerHTML=css);else {let style=global.document.createElement(\"style\");style.setAttribute(\"id\",selector),style.innerHTML=css,global.document.head.appendChild(style);}};function outlineCSS(selector){return dedent`\n    ${selector} body {\n      outline: 1px solid #2980b9 !important;\n    }\n\n    ${selector} article {\n      outline: 1px solid #3498db !important;\n    }\n\n    ${selector} nav {\n      outline: 1px solid #0088c3 !important;\n    }\n\n    ${selector} aside {\n      outline: 1px solid #33a0ce !important;\n    }\n\n    ${selector} section {\n      outline: 1px solid #66b8da !important;\n    }\n\n    ${selector} header {\n      outline: 1px solid #99cfe7 !important;\n    }\n\n    ${selector} footer {\n      outline: 1px solid #cce7f3 !important;\n    }\n\n    ${selector} h1 {\n      outline: 1px solid #162544 !important;\n    }\n\n    ${selector} h2 {\n      outline: 1px solid #314e6e !important;\n    }\n\n    ${selector} h3 {\n      outline: 1px solid #3e5e85 !important;\n    }\n\n    ${selector} h4 {\n      outline: 1px solid #449baf !important;\n    }\n\n    ${selector} h5 {\n      outline: 1px solid #c7d1cb !important;\n    }\n\n    ${selector} h6 {\n      outline: 1px solid #4371d0 !important;\n    }\n\n    ${selector} main {\n      outline: 1px solid #2f4f90 !important;\n    }\n\n    ${selector} address {\n      outline: 1px solid #1a2c51 !important;\n    }\n\n    ${selector} div {\n      outline: 1px solid #036cdb !important;\n    }\n\n    ${selector} p {\n      outline: 1px solid #ac050b !important;\n    }\n\n    ${selector} hr {\n      outline: 1px solid #ff063f !important;\n    }\n\n    ${selector} pre {\n      outline: 1px solid #850440 !important;\n    }\n\n    ${selector} blockquote {\n      outline: 1px solid #f1b8e7 !important;\n    }\n\n    ${selector} ol {\n      outline: 1px solid #ff050c !important;\n    }\n\n    ${selector} ul {\n      outline: 1px solid #d90416 !important;\n    }\n\n    ${selector} li {\n      outline: 1px solid #d90416 !important;\n    }\n\n    ${selector} dl {\n      outline: 1px solid #fd3427 !important;\n    }\n\n    ${selector} dt {\n      outline: 1px solid #ff0043 !important;\n    }\n\n    ${selector} dd {\n      outline: 1px solid #e80174 !important;\n    }\n\n    ${selector} figure {\n      outline: 1px solid #ff00bb !important;\n    }\n\n    ${selector} figcaption {\n      outline: 1px solid #bf0032 !important;\n    }\n\n    ${selector} table {\n      outline: 1px solid #00cc99 !important;\n    }\n\n    ${selector} caption {\n      outline: 1px solid #37ffc4 !important;\n    }\n\n    ${selector} thead {\n      outline: 1px solid #98daca !important;\n    }\n\n    ${selector} tbody {\n      outline: 1px solid #64a7a0 !important;\n    }\n\n    ${selector} tfoot {\n      outline: 1px solid #22746b !important;\n    }\n\n    ${selector} tr {\n      outline: 1px solid #86c0b2 !important;\n    }\n\n    ${selector} th {\n      outline: 1px solid #a1e7d6 !important;\n    }\n\n    ${selector} td {\n      outline: 1px solid #3f5a54 !important;\n    }\n\n    ${selector} col {\n      outline: 1px solid #6c9a8f !important;\n    }\n\n    ${selector} colgroup {\n      outline: 1px solid #6c9a9d !important;\n    }\n\n    ${selector} button {\n      outline: 1px solid #da8301 !important;\n    }\n\n    ${selector} datalist {\n      outline: 1px solid #c06000 !important;\n    }\n\n    ${selector} fieldset {\n      outline: 1px solid #d95100 !important;\n    }\n\n    ${selector} form {\n      outline: 1px solid #d23600 !important;\n    }\n\n    ${selector} input {\n      outline: 1px solid #fca600 !important;\n    }\n\n    ${selector} keygen {\n      outline: 1px solid #b31e00 !important;\n    }\n\n    ${selector} label {\n      outline: 1px solid #ee8900 !important;\n    }\n\n    ${selector} legend {\n      outline: 1px solid #de6d00 !important;\n    }\n\n    ${selector} meter {\n      outline: 1px solid #e8630c !important;\n    }\n\n    ${selector} optgroup {\n      outline: 1px solid #b33600 !important;\n    }\n\n    ${selector} option {\n      outline: 1px solid #ff8a00 !important;\n    }\n\n    ${selector} output {\n      outline: 1px solid #ff9619 !important;\n    }\n\n    ${selector} progress {\n      outline: 1px solid #e57c00 !important;\n    }\n\n    ${selector} select {\n      outline: 1px solid #e26e0f !important;\n    }\n\n    ${selector} textarea {\n      outline: 1px solid #cc5400 !important;\n    }\n\n    ${selector} details {\n      outline: 1px solid #33848f !important;\n    }\n\n    ${selector} summary {\n      outline: 1px solid #60a1a6 !important;\n    }\n\n    ${selector} command {\n      outline: 1px solid #438da1 !important;\n    }\n\n    ${selector} menu {\n      outline: 1px solid #449da6 !important;\n    }\n\n    ${selector} del {\n      outline: 1px solid #bf0000 !important;\n    }\n\n    ${selector} ins {\n      outline: 1px solid #400000 !important;\n    }\n\n    ${selector} img {\n      outline: 1px solid #22746b !important;\n    }\n\n    ${selector} iframe {\n      outline: 1px solid #64a7a0 !important;\n    }\n\n    ${selector} embed {\n      outline: 1px solid #98daca !important;\n    }\n\n    ${selector} object {\n      outline: 1px solid #00cc99 !important;\n    }\n\n    ${selector} param {\n      outline: 1px solid #37ffc4 !important;\n    }\n\n    ${selector} video {\n      outline: 1px solid #6ee866 !important;\n    }\n\n    ${selector} audio {\n      outline: 1px solid #027353 !important;\n    }\n\n    ${selector} source {\n      outline: 1px solid #012426 !important;\n    }\n\n    ${selector} canvas {\n      outline: 1px solid #a2f570 !important;\n    }\n\n    ${selector} track {\n      outline: 1px solid #59a600 !important;\n    }\n\n    ${selector} map {\n      outline: 1px solid #7be500 !important;\n    }\n\n    ${selector} area {\n      outline: 1px solid #305900 !important;\n    }\n\n    ${selector} a {\n      outline: 1px solid #ff62ab !important;\n    }\n\n    ${selector} em {\n      outline: 1px solid #800b41 !important;\n    }\n\n    ${selector} strong {\n      outline: 1px solid #ff1583 !important;\n    }\n\n    ${selector} i {\n      outline: 1px solid #803156 !important;\n    }\n\n    ${selector} b {\n      outline: 1px solid #cc1169 !important;\n    }\n\n    ${selector} u {\n      outline: 1px solid #ff0430 !important;\n    }\n\n    ${selector} s {\n      outline: 1px solid #f805e3 !important;\n    }\n\n    ${selector} small {\n      outline: 1px solid #d107b2 !important;\n    }\n\n    ${selector} abbr {\n      outline: 1px solid #4a0263 !important;\n    }\n\n    ${selector} q {\n      outline: 1px solid #240018 !important;\n    }\n\n    ${selector} cite {\n      outline: 1px solid #64003c !important;\n    }\n\n    ${selector} dfn {\n      outline: 1px solid #b4005a !important;\n    }\n\n    ${selector} sub {\n      outline: 1px solid #dba0c8 !important;\n    }\n\n    ${selector} sup {\n      outline: 1px solid #cc0256 !important;\n    }\n\n    ${selector} time {\n      outline: 1px solid #d6606d !important;\n    }\n\n    ${selector} code {\n      outline: 1px solid #e04251 !important;\n    }\n\n    ${selector} kbd {\n      outline: 1px solid #5e001f !important;\n    }\n\n    ${selector} samp {\n      outline: 1px solid #9c0033 !important;\n    }\n\n    ${selector} var {\n      outline: 1px solid #d90047 !important;\n    }\n\n    ${selector} mark {\n      outline: 1px solid #ff0053 !important;\n    }\n\n    ${selector} bdi {\n      outline: 1px solid #bf3668 !important;\n    }\n\n    ${selector} bdo {\n      outline: 1px solid #6f1400 !important;\n    }\n\n    ${selector} ruby {\n      outline: 1px solid #ff7b93 !important;\n    }\n\n    ${selector} rt {\n      outline: 1px solid #ff2f54 !important;\n    }\n\n    ${selector} rp {\n      outline: 1px solid #803e49 !important;\n    }\n\n    ${selector} span {\n      outline: 1px solid #cc2643 !important;\n    }\n\n    ${selector} br {\n      outline: 1px solid #db687d !important;\n    }\n\n    ${selector} wbr {\n      outline: 1px solid #db175b !important;\n    }`}var withOutline=(StoryFn,context)=>{let{globals:globals2}=context,isActive=[!0,\"true\"].includes(globals2[PARAM_KEY]),isInDocs=context.viewMode===\"docs\",outlineStyles=useMemo(()=>outlineCSS(isInDocs?'[data-story-block=\"true\"]':\".sb-show-main\"),[context]);return useEffect(()=>{let selectorId=isInDocs?`addon-outline-docs-${context.id}`:\"addon-outline\";return isActive?addOutlineStyles(selectorId,outlineStyles):clearStyles(selectorId),()=>{clearStyles(selectorId);}},[isActive,outlineStyles,context]),StoryFn()};var decorators=[withOutline],globals={[PARAM_KEY]:!1};\n\nexport { decorators, globals };\n","// node_modules/@storybook/global/dist/index.mjs\nvar scope = (() => {\n  let win;\n  return typeof window < \"u\" ? win = window : typeof globalThis < \"u\" ? win = globalThis : typeof global < \"u\" ? win = global : typeof self < \"u\" ? win = self : win = {}, win;\n})();\n\n// node_modules/@storybook/client-logger/dist/index.mjs\nvar { LOGLEVEL } = scope, levels = { trace: 1, debug: 2, info: 3, warn: 4, error: 5, silent: 10 }, currentLogLevelString = LOGLEVEL, currentLogLevelNumber = levels[currentLogLevelString] || levels.info, logger = { trace: (message, ...rest) => {\n  currentLogLevelNumber <= levels.trace && console.trace(message, ...rest);\n}, debug: (message, ...rest) => {\n  currentLogLevelNumber <= levels.debug && console.debug(message, ...rest);\n}, info: (message, ...rest) => {\n  currentLogLevelNumber <= levels.info && console.info(message, ...rest);\n}, warn: (message, ...rest) => {\n  currentLogLevelNumber <= levels.warn && console.warn(message, ...rest);\n}, error: (message, ...rest) => {\n  currentLogLevelNumber <= levels.error && console.error(message, ...rest);\n}, log: (message, ...rest) => {\n  currentLogLevelNumber < levels.silent && console.log(message, ...rest);\n} }, logged = /* @__PURE__ */ new Set(), once = (type) => (message, ...rest) => {\n  if (!logged.has(message))\n    return logged.add(message), logger[type](message, ...rest);\n};\nonce.clear = () => logged.clear();\nonce.trace = once(\"trace\");\nonce.debug = once(\"debug\");\nonce.info = once(\"info\");\nonce.warn = once(\"warn\");\nonce.error = once(\"error\");\nonce.log = once(\"log\");\nvar deprecate = once(\"warn\"), pretty = (type) => (...args) => {\n  let argArray = [];\n  if (args.length) {\n    let startTagRe = /<span\\s+style=(['\"])([^'\"]*)\\1\\s*>/gi, endTagRe = /<\\/span>/gi, reResultArray;\n    for (argArray.push(args[0].replace(startTagRe, \"%c\").replace(endTagRe, \"%c\")); reResultArray = startTagRe.exec(args[0]); )\n      argArray.push(reResultArray[2]), argArray.push(\"\");\n    for (let j = 1; j < args.length; j++)\n      argArray.push(args[j]);\n  }\n  logger[type].apply(logger, argArray);\n};\npretty.trace = pretty(\"trace\");\npretty.debug = pretty(\"debug\");\npretty.info = pretty(\"info\");\npretty.warn = pretty(\"warn\");\npretty.error = pretty(\"error\");\n\n// node_modules/@storybook/channels/dist/index.mjs\nvar generateRandomId = () => Math.random().toString(16).slice(2), Channel = class {\n  constructor({ transport, async = !1 } = {}) {\n    this.sender = generateRandomId(), this.events = {}, this.data = {}, this.transport = void 0, this.isAsync = async, transport && (this.transport = transport, this.transport.setHandler((event) => this.handleEvent(event)));\n  }\n  get hasTransport() {\n    return !!this.transport;\n  }\n  addListener(eventName, listener) {\n    this.events[eventName] = this.events[eventName] || [], this.events[eventName].push(listener);\n  }\n  emit(eventName, ...args) {\n    let event = { type: eventName, args, from: this.sender }, options = {};\n    args.length >= 1 && args[0] && args[0].options && (options = args[0].options);\n    let handler = () => {\n      this.transport && this.transport.send(event, options), this.handleEvent(event);\n    };\n    this.isAsync ? setImmediate(handler) : handler();\n  }\n  last(eventName) {\n    return this.data[eventName];\n  }\n  eventNames() {\n    return Object.keys(this.events);\n  }\n  listenerCount(eventName) {\n    let listeners = this.listeners(eventName);\n    return listeners ? listeners.length : 0;\n  }\n  listeners(eventName) {\n    return this.events[eventName] || void 0;\n  }\n  once(eventName, listener) {\n    let onceListener = this.onceListener(eventName, listener);\n    this.addListener(eventName, onceListener);\n  }\n  removeAllListeners(eventName) {\n    eventName ? this.events[eventName] && delete this.events[eventName] : this.events = {};\n  }\n  removeListener(eventName, listener) {\n    let listeners = this.listeners(eventName);\n    listeners && (this.events[eventName] = listeners.filter((l) => l !== listener));\n  }\n  on(eventName, listener) {\n    this.addListener(eventName, listener);\n  }\n  off(eventName, listener) {\n    this.removeListener(eventName, listener);\n  }\n  handleEvent(event) {\n    let listeners = this.listeners(event.type);\n    listeners && listeners.length && listeners.forEach((fn) => {\n      fn.apply(event, event.args);\n    }), this.data[event.type] = event.args;\n  }\n  onceListener(eventName, listener) {\n    let onceListener = (...args) => (this.removeListener(eventName, onceListener), listener(...args));\n    return onceListener;\n  }\n};\n\n// node_modules/@storybook/core-events/dist/index.mjs\nvar events = ((events2) => (events2.CHANNEL_CREATED = \"channelCreated\", events2.CONFIG_ERROR = \"configError\", events2.STORY_INDEX_INVALIDATED = \"storyIndexInvalidated\", events2.STORY_SPECIFIED = \"storySpecified\", events2.SET_CONFIG = \"setConfig\", events2.SET_STORIES = \"setStories\", events2.SET_INDEX = \"setIndex\", events2.SET_CURRENT_STORY = \"setCurrentStory\", events2.CURRENT_STORY_WAS_SET = \"currentStoryWasSet\", events2.FORCE_RE_RENDER = \"forceReRender\", events2.FORCE_REMOUNT = \"forceRemount\", events2.PRELOAD_ENTRIES = \"preloadStories\", events2.STORY_PREPARED = \"storyPrepared\", events2.DOCS_PREPARED = \"docsPrepared\", events2.STORY_CHANGED = \"storyChanged\", events2.STORY_UNCHANGED = \"storyUnchanged\", events2.STORY_RENDERED = \"storyRendered\", events2.STORY_MISSING = \"storyMissing\", events2.STORY_ERRORED = \"storyErrored\", events2.STORY_THREW_EXCEPTION = \"storyThrewException\", events2.STORY_RENDER_PHASE_CHANGED = \"storyRenderPhaseChanged\", events2.PLAY_FUNCTION_THREW_EXCEPTION = \"playFunctionThrewException\", events2.UPDATE_STORY_ARGS = \"updateStoryArgs\", events2.STORY_ARGS_UPDATED = \"storyArgsUpdated\", events2.RESET_STORY_ARGS = \"resetStoryArgs\", events2.SET_GLOBALS = \"setGlobals\", events2.UPDATE_GLOBALS = \"updateGlobals\", events2.GLOBALS_UPDATED = \"globalsUpdated\", events2.REGISTER_SUBSCRIPTION = \"registerSubscription\", events2.PREVIEW_KEYDOWN = \"previewKeydown\", events2.PREVIEW_BUILDER_PROGRESS = \"preview_builder_progress\", events2.SELECT_STORY = \"selectStory\", events2.STORIES_COLLAPSE_ALL = \"storiesCollapseAll\", events2.STORIES_EXPAND_ALL = \"storiesExpandAll\", events2.DOCS_RENDERED = \"docsRendered\", events2.SHARED_STATE_CHANGED = \"sharedStateChanged\", events2.SHARED_STATE_SET = \"sharedStateSet\", events2.NAVIGATE_URL = \"navigateUrl\", events2.UPDATE_QUERY_PARAMS = \"updateQueryParams\", events2))(events || {});\nvar { CHANNEL_CREATED, CONFIG_ERROR, CURRENT_STORY_WAS_SET, DOCS_PREPARED, DOCS_RENDERED, FORCE_RE_RENDER, FORCE_REMOUNT, GLOBALS_UPDATED, NAVIGATE_URL, PLAY_FUNCTION_THREW_EXCEPTION, PRELOAD_ENTRIES, PREVIEW_BUILDER_PROGRESS, PREVIEW_KEYDOWN, REGISTER_SUBSCRIPTION, RESET_STORY_ARGS, SELECT_STORY, SET_CONFIG, SET_CURRENT_STORY, SET_GLOBALS, SET_INDEX, SET_STORIES, SHARED_STATE_CHANGED, SHARED_STATE_SET, STORIES_COLLAPSE_ALL, STORIES_EXPAND_ALL, STORY_ARGS_UPDATED, STORY_CHANGED, STORY_ERRORED, STORY_INDEX_INVALIDATED, STORY_MISSING, STORY_PREPARED, STORY_RENDER_PHASE_CHANGED, STORY_RENDERED, STORY_SPECIFIED, STORY_THREW_EXCEPTION, STORY_UNCHANGED, UPDATE_GLOBALS, UPDATE_QUERY_PARAMS, UPDATE_STORY_ARGS } = events, IGNORED_EXCEPTION = new Error(\"ignoredException\");\n\n// node_modules/@storybook/preview-api/dist/chunk-BOMSN7HZ.mjs\nfunction mockChannel() {\n  let transport = { setHandler: () => {\n  }, send: () => {\n  } };\n  return new Channel({ transport });\n}\nvar AddonStore = class {\n  constructor() {\n    this.getChannel = () => {\n      if (!this.channel) {\n        let channel = mockChannel();\n        return this.setChannel(channel), channel;\n      }\n      return this.channel;\n    }, this.getServerChannel = () => {\n      if (!this.serverChannel)\n        throw new Error(\"Accessing non-existent serverChannel\");\n      return this.serverChannel;\n    }, this.ready = () => this.promise, this.hasChannel = () => !!this.channel, this.hasServerChannel = () => !!this.serverChannel, this.setChannel = (channel) => {\n      this.channel = channel, this.resolve();\n    }, this.setServerChannel = (channel) => {\n      this.serverChannel = channel;\n    }, this.promise = new Promise((res) => {\n      this.resolve = () => res(this.getChannel());\n    });\n  }\n}, KEY = \"__STORYBOOK_ADDONS_PREVIEW\";\nfunction getAddonsStore() {\n  return scope[KEY] || (scope[KEY] = new AddonStore()), scope[KEY];\n}\nvar addons = getAddonsStore();\n\n// node_modules/@storybook/instrumenter/dist/index.mjs\nvar CallStates = ((CallStates2) => (CallStates2.DONE = \"done\", CallStates2.ERROR = \"error\", CallStates2.ACTIVE = \"active\", CallStates2.WAITING = \"waiting\", CallStates2))(CallStates || {}), EVENTS = { CALL: \"storybook/instrumenter/call\", SYNC: \"storybook/instrumenter/sync\", START: \"storybook/instrumenter/start\", BACK: \"storybook/instrumenter/back\", GOTO: \"storybook/instrumenter/goto\", NEXT: \"storybook/instrumenter/next\", END: \"storybook/instrumenter/end\" }, controlsDisabled = { start: !1, back: !1, goto: !1, next: !1, end: !1 }, alreadyCompletedException = new Error(\"This function ran after the play function completed. Did you forget to `await` it?\"), isObject = (o) => Object.prototype.toString.call(o) === \"[object Object]\", isModule = (o) => Object.prototype.toString.call(o) === \"[object Module]\", isInstrumentable = (o) => {\n  if (!isObject(o) && !isModule(o))\n    return !1;\n  if (o.constructor === void 0)\n    return !0;\n  let proto = o.constructor.prototype;\n  return !(!isObject(proto) || Object.prototype.hasOwnProperty.call(proto, \"isPrototypeOf\") === !1);\n}, construct = (obj) => {\n  try {\n    return new obj.constructor();\n  } catch {\n    return {};\n  }\n}, getInitialState = () => ({ renderPhase: void 0, isDebugging: !1, isPlaying: !1, isLocked: !1, cursor: 0, calls: [], shadowCalls: [], callRefsByResult: /* @__PURE__ */ new Map(), chainedCallIds: /* @__PURE__ */ new Set(), ancestors: [], playUntil: void 0, resolvers: {}, syncTimeout: void 0 }), getRetainedState = (state, isDebugging = !1) => {\n  let calls = (isDebugging ? state.shadowCalls : state.calls).filter((call) => call.retain);\n  if (!calls.length)\n    return;\n  let callRefsByResult = new Map(Array.from(state.callRefsByResult.entries()).filter(([, ref]) => ref.retain));\n  return { cursor: calls.length, calls, callRefsByResult };\n}, Instrumenter = class {\n  constructor() {\n    this.initialized = !1, this.channel = addons.getChannel(), this.state = scope.window.parent.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER_STATE__ || {};\n    let resetState = ({ storyId, isPlaying = !0, isDebugging = !1 }) => {\n      let state = this.getState(storyId);\n      this.setState(storyId, { ...getInitialState(), ...getRetainedState(state, isDebugging), shadowCalls: isDebugging ? state.shadowCalls : [], chainedCallIds: isDebugging ? state.chainedCallIds : /* @__PURE__ */ new Set(), playUntil: isDebugging ? state.playUntil : void 0, isPlaying, isDebugging }), this.sync(storyId);\n    };\n    this.channel.on(FORCE_REMOUNT, resetState), this.channel.on(STORY_RENDER_PHASE_CHANGED, ({ storyId, newPhase }) => {\n      let { isDebugging } = this.getState(storyId);\n      this.setState(storyId, { renderPhase: newPhase }), newPhase === \"preparing\" && isDebugging && resetState({ storyId }), newPhase === \"playing\" && resetState({ storyId, isDebugging }), newPhase === \"played\" && this.setState(storyId, { isLocked: !1, isPlaying: !1, isDebugging: !1 }), newPhase === \"errored\" && this.setState(storyId, { isLocked: !1, isPlaying: !1 });\n    }), this.channel.on(SET_CURRENT_STORY, () => {\n      this.initialized ? this.cleanup() : this.initialized = !0;\n    });\n    let start = ({ storyId, playUntil }) => {\n      this.getState(storyId).isDebugging || this.setState(storyId, ({ calls }) => ({ calls: [], shadowCalls: calls.map((call) => ({ ...call, status: \"waiting\" })), isDebugging: !0 }));\n      let log = this.getLog(storyId);\n      this.setState(storyId, ({ shadowCalls }) => {\n        if (playUntil || !log.length)\n          return { playUntil };\n        let firstRowIndex = shadowCalls.findIndex((call) => call.id === log[0].callId);\n        return { playUntil: shadowCalls.slice(0, firstRowIndex).filter((call) => call.interceptable && !call.ancestors.length).slice(-1)[0]?.id };\n      }), this.channel.emit(FORCE_REMOUNT, { storyId, isDebugging: !0 });\n    }, back = ({ storyId }) => {\n      let log = this.getLog(storyId).filter((call) => !call.ancestors.length), last = log.reduceRight((res, item, index) => res >= 0 || item.status === \"waiting\" ? res : index, -1);\n      start({ storyId, playUntil: log[last - 1]?.callId });\n    }, goto = ({ storyId, callId }) => {\n      let { calls, shadowCalls, resolvers } = this.getState(storyId), call = calls.find(({ id }) => id === callId), shadowCall = shadowCalls.find(({ id }) => id === callId);\n      if (!call && shadowCall && Object.values(resolvers).length > 0) {\n        let nextId = this.getLog(storyId).find((c) => c.status === \"waiting\")?.callId;\n        shadowCall.id !== nextId && this.setState(storyId, { playUntil: shadowCall.id }), Object.values(resolvers).forEach((resolve) => resolve());\n      } else\n        start({ storyId, playUntil: callId });\n    }, next = ({ storyId }) => {\n      let { resolvers } = this.getState(storyId);\n      if (Object.values(resolvers).length > 0)\n        Object.values(resolvers).forEach((resolve) => resolve());\n      else {\n        let nextId = this.getLog(storyId).find((c) => c.status === \"waiting\")?.callId;\n        nextId ? start({ storyId, playUntil: nextId }) : end({ storyId });\n      }\n    }, end = ({ storyId }) => {\n      this.setState(storyId, { playUntil: void 0, isDebugging: !1 }), Object.values(this.getState(storyId).resolvers).forEach((resolve) => resolve());\n    };\n    this.channel.on(EVENTS.START, start), this.channel.on(EVENTS.BACK, back), this.channel.on(EVENTS.GOTO, goto), this.channel.on(EVENTS.NEXT, next), this.channel.on(EVENTS.END, end);\n  }\n  getState(storyId) {\n    return this.state[storyId] || getInitialState();\n  }\n  setState(storyId, update) {\n    let state = this.getState(storyId), patch = typeof update == \"function\" ? update(state) : update;\n    this.state = { ...this.state, [storyId]: { ...state, ...patch } }, scope.window.parent.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER_STATE__ = this.state;\n  }\n  cleanup() {\n    this.state = Object.entries(this.state).reduce((acc, [storyId, state]) => {\n      let retainedState = getRetainedState(state);\n      return retainedState && (acc[storyId] = Object.assign(getInitialState(), retainedState)), acc;\n    }, {});\n    let payload = { controlStates: controlsDisabled, logItems: [] };\n    this.channel.emit(EVENTS.SYNC, payload), scope.window.parent.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER_STATE__ = this.state;\n  }\n  getLog(storyId) {\n    let { calls, shadowCalls } = this.getState(storyId), merged = [...shadowCalls];\n    calls.forEach((call, index) => {\n      merged[index] = call;\n    });\n    let seen = /* @__PURE__ */ new Set();\n    return merged.reduceRight((acc, call) => (call.args.forEach((arg) => {\n      arg?.__callId__ && seen.add(arg.__callId__);\n    }), call.path.forEach((node) => {\n      node.__callId__ && seen.add(node.__callId__);\n    }), (call.interceptable || call.exception) && !seen.has(call.id) && (acc.unshift({ callId: call.id, status: call.status, ancestors: call.ancestors }), seen.add(call.id)), acc), []);\n  }\n  instrument(obj, options) {\n    if (!isInstrumentable(obj))\n      return obj;\n    let { mutate = !1, path = [] } = options;\n    return Object.keys(obj).reduce((acc, key) => {\n      let value = obj[key];\n      return typeof value != \"function\" ? (acc[key] = this.instrument(value, { ...options, path: path.concat(key) }), acc) : typeof value.__originalFn__ == \"function\" ? (acc[key] = value, acc) : (acc[key] = (...args) => this.track(key, value, args, options), acc[key].__originalFn__ = value, Object.defineProperty(acc[key], \"name\", { value: key, writable: !1 }), Object.keys(value).length > 0 && Object.assign(acc[key], this.instrument({ ...value }, { ...options, path: path.concat(key) })), acc);\n    }, mutate ? obj : construct(obj));\n  }\n  track(method, fn, args, options) {\n    let storyId = args?.[0]?.__storyId__ || scope.__STORYBOOK_PREVIEW__?.selectionStore?.selection?.storyId, { cursor, ancestors } = this.getState(storyId);\n    this.setState(storyId, { cursor: cursor + 1 });\n    let id = `${ancestors.slice(-1)[0] || storyId} [${cursor}] ${method}`, { path = [], intercept = !1, retain = !1 } = options, interceptable = typeof intercept == \"function\" ? intercept(method, path) : intercept, call = { id, cursor, storyId, ancestors, path, method, args, interceptable, retain }, result = (interceptable && !ancestors.length ? this.intercept : this.invoke).call(this, fn, call, options);\n    return this.instrument(result, { ...options, mutate: !0, path: [{ __callId__: call.id }] });\n  }\n  intercept(fn, call, options) {\n    let { chainedCallIds, isDebugging, playUntil } = this.getState(call.storyId), isChainedUpon = chainedCallIds.has(call.id);\n    return !isDebugging || isChainedUpon || playUntil ? (playUntil === call.id && this.setState(call.storyId, { playUntil: void 0 }), this.invoke(fn, call, options)) : new Promise((resolve) => {\n      this.setState(call.storyId, ({ resolvers }) => ({ isLocked: !1, resolvers: { ...resolvers, [call.id]: resolve } }));\n    }).then(() => (this.setState(call.storyId, (state) => {\n      let { [call.id]: _, ...resolvers } = state.resolvers;\n      return { isLocked: !0, resolvers };\n    }), this.invoke(fn, call, options)));\n  }\n  invoke(fn, call, options) {\n    let { callRefsByResult, renderPhase } = this.getState(call.storyId), serializeValues = (value) => {\n      if (callRefsByResult.has(value))\n        return callRefsByResult.get(value);\n      if (value instanceof Array)\n        return value.map(serializeValues);\n      if (value instanceof Date)\n        return { __date__: { value: value.toISOString() } };\n      if (value instanceof Error) {\n        let { name, message, stack } = value;\n        return { __error__: { name, message, stack } };\n      }\n      if (value instanceof RegExp) {\n        let { flags, source } = value;\n        return { __regexp__: { flags, source } };\n      }\n      if (value instanceof scope.window.HTMLElement) {\n        let { prefix, localName, id, classList, innerText } = value, classNames = Array.from(classList);\n        return { __element__: { prefix, localName, id, classNames, innerText } };\n      }\n      return typeof value == \"function\" ? { __function__: { name: value.name } } : typeof value == \"symbol\" ? { __symbol__: { description: value.description } } : typeof value == \"object\" && value?.constructor?.name && value?.constructor?.name !== \"Object\" ? { __class__: { name: value.constructor.name } } : Object.prototype.toString.call(value) === \"[object Object]\" ? Object.fromEntries(Object.entries(value).map(([key, val]) => [key, serializeValues(val)])) : value;\n    }, info = { ...call, args: call.args.map(serializeValues) };\n    call.path.forEach((ref) => {\n      ref?.__callId__ && this.setState(call.storyId, ({ chainedCallIds }) => ({ chainedCallIds: new Set(Array.from(chainedCallIds).concat(ref.__callId__)) }));\n    });\n    let handleException = (e) => {\n      if (e instanceof Error) {\n        let { name, message, stack, callId = call.id } = e, exception = { name, message, stack, callId };\n        if (this.update({ ...info, status: \"error\", exception }), this.setState(call.storyId, (state) => ({ callRefsByResult: new Map([...Array.from(state.callRefsByResult.entries()), [e, { __callId__: call.id, retain: call.retain }]]) })), call.ancestors.length)\n          throw Object.prototype.hasOwnProperty.call(e, \"callId\") || Object.defineProperty(e, \"callId\", { value: call.id }), e;\n        if (e !== alreadyCompletedException)\n          throw logger.warn(e), IGNORED_EXCEPTION;\n      }\n      throw e;\n    };\n    try {\n      if (renderPhase === \"played\" && !call.retain)\n        throw alreadyCompletedException;\n      let finalArgs = (options.getArgs ? options.getArgs(call, this.getState(call.storyId)) : call.args).map((arg) => typeof arg != \"function\" || Object.keys(arg).length ? arg : (...args) => {\n        let { cursor, ancestors } = this.getState(call.storyId);\n        this.setState(call.storyId, { cursor: 0, ancestors: [...ancestors, call.id] });\n        let restore = () => this.setState(call.storyId, { cursor, ancestors }), willRestore = !1;\n        try {\n          let res = arg(...args);\n          return res instanceof Promise ? (willRestore = !0, res.finally(restore)) : res;\n        } finally {\n          willRestore || restore();\n        }\n      }), result = fn(...finalArgs);\n      return result && [\"object\", \"function\", \"symbol\"].includes(typeof result) && this.setState(call.storyId, (state) => ({ callRefsByResult: new Map([...Array.from(state.callRefsByResult.entries()), [result, { __callId__: call.id, retain: call.retain }]]) })), this.update({ ...info, status: result instanceof Promise ? \"active\" : \"done\" }), result instanceof Promise ? result.then((value) => (this.update({ ...info, status: \"done\" }), value), handleException) : result;\n    } catch (e) {\n      return handleException(e);\n    }\n  }\n  update(call) {\n    this.channel.emit(EVENTS.CALL, call), this.setState(call.storyId, ({ calls }) => {\n      let callsById = calls.concat(call).reduce((a, c) => Object.assign(a, { [c.id]: c }), {});\n      return { calls: Object.values(callsById).sort((a, b) => a.id.localeCompare(b.id, void 0, { numeric: !0 })) };\n    }), this.sync(call.storyId);\n  }\n  sync(storyId) {\n    let synchronize = () => {\n      let { isLocked, isPlaying } = this.getState(storyId), logItems = this.getLog(storyId), pausedAt = logItems.filter(({ ancestors }) => !ancestors.length).find((item) => item.status === \"waiting\")?.callId, hasActive = logItems.some((item) => item.status === \"active\");\n      if (isLocked || hasActive || logItems.length === 0) {\n        let payload2 = { controlStates: controlsDisabled, logItems };\n        this.channel.emit(EVENTS.SYNC, payload2);\n        return;\n      }\n      let hasPrevious = logItems.some((item) => [\"done\", \"error\"].includes(item.status)), payload = { controlStates: { start: hasPrevious, back: hasPrevious, goto: !0, next: isPlaying, end: isPlaying }, logItems, pausedAt };\n      this.channel.emit(EVENTS.SYNC, payload);\n    };\n    this.setState(storyId, ({ syncTimeout }) => (clearTimeout(syncTimeout), { syncTimeout: setTimeout(synchronize, 0) }));\n  }\n};\nfunction instrument(obj, options = {}) {\n  try {\n    let forceInstrument = !1, skipInstrument = !1;\n    return scope.window.location?.search?.includes(\"instrument=true\") ? forceInstrument = !0 : scope.window.location?.search?.includes(\"instrument=false\") && (skipInstrument = !0), scope.window.parent === scope.window && !forceInstrument || skipInstrument ? obj : (scope.window.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER__ || (scope.window.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER__ = new Instrumenter()), scope.window.__STORYBOOK_ADDON_INTERACTIONS_INSTRUMENTER__.instrument(obj, options));\n  } catch (e) {\n    return once.warn(e), obj;\n  }\n}\n\n// src/index.ts\nimport * as domTestingLibrary from \"@testing-library/dom\";\nimport _userEventObj from \"@testing-library/user-event\";\nimport dedent from \"ts-dedent\";\nvar _userEvent = _userEventObj.default || _userEventObj, testingLibrary = instrument(\n  { ...domTestingLibrary },\n  {\n    intercept: (method, path) => path[0] === \"fireEvent\" || method.startsWith(\"findBy\") || method.startsWith(\"waitFor\")\n  }\n);\ntestingLibrary.screen = Object.entries(testingLibrary.screen).reduce(\n  (acc, [key, val]) => Object.defineProperty(acc, key, {\n    get() {\n      return once.warn(dedent`\n          You are using Testing Library's \\`screen\\` object. Use \\`within(canvasElement)\\` instead.\n          More info: https://storybook.js.org/docs/react/essentials/interactions\n        `), val;\n    }\n  }),\n  { ...testingLibrary.screen }\n);\nvar {\n  buildQueries,\n  configure,\n  createEvent,\n  findAllByAltText,\n  findAllByDisplayValue,\n  findAllByLabelText,\n  findAllByPlaceholderText,\n  findAllByRole,\n  findAllByTestId,\n  findAllByText,\n  findAllByTitle,\n  findByAltText,\n  findByDisplayValue,\n  findByLabelText,\n  findByPlaceholderText,\n  findByRole,\n  findByTestId,\n  findByText,\n  findByTitle,\n  fireEvent,\n  getAllByAltText,\n  getAllByDisplayValue,\n  getAllByLabelText,\n  getAllByPlaceholderText,\n  getAllByRole,\n  getAllByTestId,\n  getAllByText,\n  getAllByTitle,\n  getByAltText,\n  getByDisplayValue,\n  getByLabelText,\n  getByPlaceholderText,\n  getByRole,\n  getByTestId,\n  getByText,\n  getByTitle,\n  getConfig,\n  getDefaultNormalizer,\n  getElementError,\n  getNodeText,\n  getQueriesForElement,\n  getRoles,\n  getSuggestedQuery,\n  isInaccessible,\n  logDOM,\n  logRoles,\n  prettyDOM,\n  queries,\n  queryAllByAltText,\n  queryAllByAttribute,\n  queryAllByDisplayValue,\n  queryAllByLabelText,\n  queryAllByPlaceholderText,\n  queryAllByRole,\n  queryAllByTestId,\n  queryAllByText,\n  queryAllByTitle,\n  queryByAltText,\n  queryByAttribute,\n  queryByDisplayValue,\n  queryByLabelText,\n  queryByPlaceholderText,\n  queryByRole,\n  queryByTestId,\n  queryByText,\n  queryByTitle,\n  queryHelpers,\n  screen,\n  waitFor,\n  waitForElementToBeRemoved,\n  within,\n  prettyFormat\n} = testingLibrary, userEvent = instrument(\n  { userEvent: _userEvent },\n  { intercept: !0 }\n).userEvent;\nexport {\n  buildQueries,\n  configure,\n  createEvent,\n  findAllByAltText,\n  findAllByDisplayValue,\n  findAllByLabelText,\n  findAllByPlaceholderText,\n  findAllByRole,\n  findAllByTestId,\n  findAllByText,\n  findAllByTitle,\n  findByAltText,\n  findByDisplayValue,\n  findByLabelText,\n  findByPlaceholderText,\n  findByRole,\n  findByTestId,\n  findByText,\n  findByTitle,\n  fireEvent,\n  getAllByAltText,\n  getAllByDisplayValue,\n  getAllByLabelText,\n  getAllByPlaceholderText,\n  getAllByRole,\n  getAllByTestId,\n  getAllByText,\n  getAllByTitle,\n  getByAltText,\n  getByDisplayValue,\n  getByLabelText,\n  getByPlaceholderText,\n  getByRole,\n  getByTestId,\n  getByText,\n  getByTitle,\n  getConfig,\n  getDefaultNormalizer,\n  getElementError,\n  getNodeText,\n  getQueriesForElement,\n  getRoles,\n  getSuggestedQuery,\n  isInaccessible,\n  logDOM,\n  logRoles,\n  prettyDOM,\n  prettyFormat,\n  queries,\n  queryAllByAltText,\n  queryAllByAttribute,\n  queryAllByDisplayValue,\n  queryAllByLabelText,\n  queryAllByPlaceholderText,\n  queryAllByRole,\n  queryAllByTestId,\n  queryAllByText,\n  queryAllByTitle,\n  queryByAltText,\n  queryByAttribute,\n  queryByDisplayValue,\n  queryByLabelText,\n  queryByPlaceholderText,\n  queryByRole,\n  queryByTestId,\n  queryByText,\n  queryByTitle,\n  queryHelpers,\n  screen,\n  userEvent,\n  waitFor,\n  waitForElementToBeRemoved,\n  within\n};\n"],"names":[],"sourceRoot":""}