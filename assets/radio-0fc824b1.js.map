{"version":3,"file":"radio-0fc824b1.js","sources":["../../packages/wonder-blocks-form/src/components/checkbox-core.tsx","../../packages/wonder-blocks-form/src/components/radio-core.tsx","../../packages/wonder-blocks-form/src/components/choice-internal.tsx","../../packages/wonder-blocks-form/src/components/radio.tsx"],"sourcesContent":["import * as React from \"react\";\nimport {StyleSheet} from \"aphrodite\";\n\nimport Color, {mix, fade} from \"@khanacademy/wonder-blocks-color\";\nimport {addStyle} from \"@khanacademy/wonder-blocks-core\";\nimport Icon from \"@khanacademy/wonder-blocks-icon\";\n\nimport type {IconAsset} from \"@khanacademy/wonder-blocks-icon\";\nimport type {ChoiceCoreProps, Checked} from \"../util/types\";\n\n// `AriaChecked` and `mapCheckedToAriaChecked()` are used to convert the\n// `checked` prop value to a value that a screen reader can understand via the\n// `aria-checked` attribute\ntype AriaChecked = \"true\" | \"false\" | \"mixed\";\n\nfunction mapCheckedToAriaChecked(value: Checked): AriaChecked {\n    switch (value) {\n        case true:\n            return \"true\";\n        case false:\n            return \"false\";\n        default:\n            return \"mixed\";\n    }\n}\n\nconst {blue, red, white, offWhite, offBlack16, offBlack32, offBlack50} = Color;\n\nconst StyledInput = addStyle(\"input\");\n\nconst checkPath: IconAsset = {\n    small: \"M11.263 4.324a1 1 0 1 1 1.474 1.352l-5.5 6a1 1 0 0 1-1.505-.036l-2.5-3a1 1 0 1 1 1.536-1.28L6.536 9.48l4.727-5.157z\",\n};\n\nconst indeterminatePath: IconAsset = {\n    small: \"M3 8C3 7.44772 3.44772 7 4 7H12C12.5523 7 13 7.44772 13 8C13 8.55228 12.5523 9 12 9H4C3.44772 9 3 8.55228 3 8Z\",\n};\n\n/**\n * The internal stateless ‚òëÔ∏è Checkbox\n */\nconst CheckboxCore = React.forwardRef(\n    (props: ChoiceCoreProps, ref: React.ForwardedRef<HTMLInputElement>) => {\n        const {\n            checked,\n            disabled,\n            error,\n            groupName,\n            id,\n            testId,\n            ...sharedProps\n        } = props;\n\n        const innerRef = React.useRef<HTMLInputElement>(null);\n\n        React.useEffect(() => {\n            // Keep the indeterminate state in sync with the checked prop\n            if (innerRef.current != null) {\n                innerRef.current.indeterminate = checked == null;\n            }\n        }, [checked, innerRef]);\n\n        const handleChange: () => void = () => {\n            // Empty because change is handled by ClickableBehavior\n            return;\n        };\n\n        const stateStyles = _generateStyles(checked, error);\n\n        const defaultStyle = [\n            sharedStyles.inputReset,\n            sharedStyles.default,\n            !disabled && stateStyles.default,\n            disabled && sharedStyles.disabled,\n        ];\n\n        const checkboxIcon = (\n            <Icon\n                color={disabled ? offBlack32 : white}\n                icon={checked ? checkPath : indeterminatePath}\n                size=\"small\"\n                style={sharedStyles.checkboxIcon}\n            />\n        );\n\n        const ariaChecked = mapCheckedToAriaChecked(checked);\n\n        return (\n            <React.Fragment>\n                <StyledInput\n                    {...sharedProps}\n                    ref={(node) => {\n                        // @ts-expect-error: current is not actually read-only\n                        innerRef.current = node;\n                        if (typeof ref === \"function\") {\n                            ref(node);\n                        } else if (ref != null) {\n                            ref.current = node;\n                        }\n                    }}\n                    type=\"checkbox\"\n                    aria-checked={ariaChecked}\n                    aria-invalid={error}\n                    checked={checked ?? undefined}\n                    disabled={disabled}\n                    id={id}\n                    name={groupName}\n                    // Need to specify because this is a controlled React form\n                    // component, but we handle the click via ClickableBehavior\n                    onChange={handleChange}\n                    style={defaultStyle}\n                    data-test-id={testId}\n                />\n                {checked || checked == null ? checkboxIcon : <></>}\n            </React.Fragment>\n        );\n    },\n);\n\nconst size = 16;\n\nconst sharedStyles = StyleSheet.create({\n    // Reset the default styled input element\n    inputReset: {\n        appearance: \"none\",\n        WebkitAppearance: \"none\",\n        MozAppearance: \"none\",\n    },\n\n    default: {\n        height: size,\n        width: size,\n        minHeight: size,\n        minWidth: size,\n        margin: 0,\n        outline: \"none\",\n        boxSizing: \"border-box\",\n        borderStyle: \"solid\",\n        borderWidth: 1,\n        borderRadius: 3,\n    },\n\n    disabled: {\n        cursor: \"auto\",\n        backgroundColor: offWhite,\n        borderColor: offBlack16,\n        borderWidth: 1,\n    },\n\n    checkboxIcon: {\n        position: \"absolute\",\n        pointerEvents: \"none\",\n    },\n});\n\nconst fadedBlue = mix(fade(blue, 0.16), white);\nconst activeBlue = mix(offBlack32, blue);\nconst fadedRed = mix(fade(red, 0.08), white);\nconst activeRed = mix(offBlack32, red);\n\nconst colors = {\n    default: {\n        faded: fadedBlue,\n        base: blue,\n        active: activeBlue,\n    },\n    error: {\n        faded: fadedRed,\n        base: red,\n        active: activeRed,\n    },\n} as const;\n\nconst styles: Record<string, any> = {};\n\nconst _generateStyles = (checked: Checked, error: boolean) => {\n    // \"hash\" the parameters\n    const styleKey = `${String(checked)}-${String(error)}`;\n    if (styles[styleKey]) {\n        return styles[styleKey];\n    }\n\n    const palette = error ? colors.error : colors.default;\n\n    let newStyles: Record<string, any> = {};\n    if (checked || checked == null) {\n        newStyles = {\n            default: {\n                backgroundColor: palette.base,\n                borderWidth: 0,\n\n                // Focus and hover have the same style. Focus style only shows\n                // up with keyboard navigation.\n                \":focus-visible\": {\n                    boxShadow: `0 0 0 1px ${white}, 0 0 0 3px ${palette.base}`,\n                },\n\n                \":hover\": {\n                    boxShadow: `0 0 0 1px ${white}, 0 0 0 3px ${palette.base}`,\n                },\n\n                \":active\": {\n                    boxShadow: `0 0 0 1px ${white}, 0 0 0 3px ${palette.active}`,\n                    background: palette.active,\n                },\n            },\n        };\n    } else {\n        newStyles = {\n            default: {\n                backgroundColor: error ? fadedRed : white,\n                borderColor: error ? red : offBlack50,\n\n                // Focus and hover have the same style. Focus style only shows\n                // up with keyboard navigation.\n                \":focus-visible\": {\n                    backgroundColor: error ? fadedRed : white,\n                    borderColor: palette.base,\n                    borderWidth: 2,\n                },\n\n                \":hover\": {\n                    backgroundColor: error ? fadedRed : white,\n                    borderColor: palette.base,\n                    borderWidth: 2,\n                },\n\n                \":active\": {\n                    backgroundColor: palette.faded,\n                    borderColor: error ? activeRed : blue,\n                    borderWidth: 2,\n                },\n            },\n        };\n    }\n    styles[styleKey] = StyleSheet.create(newStyles);\n    return styles[styleKey];\n};\n\nexport default CheckboxCore;\n","import * as React from \"react\";\nimport {StyleSheet} from \"aphrodite\";\n\nimport Color, {mix, fade} from \"@khanacademy/wonder-blocks-color\";\nimport {addStyle} from \"@khanacademy/wonder-blocks-core\";\n\nimport type {ChoiceCoreProps, Checked} from \"../util/types\";\n\nconst {blue, red, white, offWhite, offBlack16, offBlack32, offBlack50} = Color;\n\nconst StyledInput = addStyle(\"input\");\n\n/**\n * The internal stateless üîò Radio button\n */ const RadioCore = React.forwardRef(\n    (props: ChoiceCoreProps, ref: React.ForwardedRef<HTMLInputElement>) => {\n        const handleChange = () => {\n            // Empty because change is handled by ClickableBehavior\n            return;\n        };\n\n        const {\n            checked,\n            disabled,\n            error,\n            groupName,\n            id,\n            testId,\n            ...sharedProps\n        } = props;\n\n        const stateStyles = _generateStyles(checked, error);\n        const defaultStyle = [\n            sharedStyles.inputReset,\n            sharedStyles.default,\n            !disabled && stateStyles.default,\n            disabled && sharedStyles.disabled,\n        ];\n\n        return (\n            <React.Fragment>\n                <StyledInput\n                    {...sharedProps}\n                    type=\"radio\"\n                    aria-invalid={error}\n                    checked={checked ?? undefined}\n                    disabled={disabled}\n                    id={id}\n                    name={groupName}\n                    // Need to specify because this is a controlled React form\n                    // component, but we handle the click via ClickableBehavior\n                    onChange={handleChange}\n                    style={defaultStyle}\n                    data-test-id={testId}\n                    ref={ref}\n                />\n                {disabled && checked && <span style={disabledChecked} />}\n            </React.Fragment>\n        );\n    },\n);\n\nconst size = 16; // circle with a different color. Here, we add that center circle. // If the checkbox is disabled and selected, it has a border but also an inner\nconst disabledChecked = {\n    position: \"absolute\",\n    top: size / 4,\n    left: size / 4,\n    height: size / 2,\n    width: size / 2,\n    borderRadius: \"50%\",\n    backgroundColor: offBlack32,\n} as const;\nconst sharedStyles = StyleSheet.create({\n    // Reset the default styled input element\n    inputReset: {\n        appearance: \"none\",\n        WebkitAppearance: \"none\",\n        MozAppearance: \"none\",\n    },\n    default: {\n        height: size,\n        width: size,\n        minHeight: size,\n        minWidth: size,\n        margin: 0,\n        outline: \"none\",\n        boxSizing: \"border-box\",\n        borderStyle: \"solid\",\n        borderWidth: 1,\n        borderRadius: \"50%\",\n    },\n    disabled: {\n        cursor: \"auto\",\n        backgroundColor: offWhite,\n        borderColor: offBlack16,\n        borderWidth: 1,\n    },\n});\nconst fadedBlue = mix(fade(blue, 0.16), white);\nconst activeBlue = mix(offBlack32, blue);\nconst fadedRed = mix(fade(red, 0.08), white);\nconst activeRed = mix(offBlack32, red);\nconst colors = {\n    default: {\n        faded: fadedBlue,\n        base: blue,\n        active: activeBlue,\n    },\n    error: {\n        faded: fadedRed,\n        base: red,\n        active: activeRed,\n    },\n} as const;\nconst styles: Record<string, any> = {};\nconst _generateStyles = (checked: Checked, error: boolean) => {\n    // \"hash\" the parameters\n    const styleKey = `${String(checked)}-${String(error)}`;\n    if (styles[styleKey]) {\n        return styles[styleKey];\n    }\n    const palette = error ? colors.error : colors.default;\n    let newStyles: Record<string, any> = {};\n    if (checked) {\n        newStyles = {\n            default: {\n                backgroundColor: white,\n                borderColor: palette.base,\n                borderWidth: size / 4,\n\n                // Focus and hover have the same style. Focus style only shows\n                // up with keyboard navigation.\n                \":focus-visible\": {\n                    boxShadow: `0 0 0 1px ${white}, 0 0 0 3px ${palette.base}`,\n                },\n\n                \":hover\": {\n                    boxShadow: `0 0 0 1px ${white}, 0 0 0 3px ${palette.base}`,\n                },\n\n                \":active\": {\n                    boxShadow: `0 0 0 1px ${white}, 0 0 0 3px ${palette.active}`,\n                    borderColor: palette.active,\n                },\n            },\n        };\n    } else {\n        newStyles = {\n            default: {\n                backgroundColor: error ? fadedRed : white,\n                borderColor: error ? red : offBlack50,\n\n                // Focus and hover have the same style. Focus style only shows\n                // up with keyboard navigation.\n                \":focus-visible\": {\n                    backgroundColor: error ? fadedRed : white,\n                    borderColor: palette.base,\n                    borderWidth: 2,\n                },\n\n                \":hover\": {\n                    backgroundColor: error ? fadedRed : white,\n                    borderColor: palette.base,\n                    borderWidth: 2,\n                },\n\n                \":active\": {\n                    backgroundColor: palette.faded,\n                    borderColor: error ? activeRed : blue,\n                    borderWidth: 2,\n                },\n            },\n        };\n    }\n    styles[styleKey] = StyleSheet.create(newStyles);\n    return styles[styleKey];\n};\n\nexport default RadioCore;\n","import * as React from \"react\";\nimport {StyleSheet} from \"aphrodite\";\n\nimport Color from \"@khanacademy/wonder-blocks-color\";\nimport {View, UniqueIDProvider} from \"@khanacademy/wonder-blocks-core\";\nimport {Strut} from \"@khanacademy/wonder-blocks-layout\";\nimport Spacing from \"@khanacademy/wonder-blocks-spacing\";\nimport {LabelMedium, LabelSmall} from \"@khanacademy/wonder-blocks-typography\";\nimport type {AriaProps, StyleType} from \"@khanacademy/wonder-blocks-core\";\nimport CheckboxCore from \"./checkbox-core\";\nimport RadioCore from \"./radio-core\";\n\ntype Props = AriaProps & {\n    /** Whether this choice is checked. */\n    checked: boolean | null | undefined;\n    /** Whether this choice option is disabled. */\n    disabled?: boolean;\n    /** Whether this choice is in error mode. */\n    error?: boolean;\n    /** Returns the new checked state of the component. */\n    onChange: (newCheckedState: boolean) => unknown;\n    /**\n     * Used for accessibility purposes, where the label id should match the\n     * input id.\n     */\n    id?: string;\n    /**\n     * Optional additional styling.\n     */\n    style?: StyleType;\n    /**\n     * Adds CSS classes to the Button.\n     */\n    className?: string;\n    /**\n     * Optional id for testing purposes.\n     */\n    testId?: string;\n    /**\n     * Label for the field.\n     */\n    label?: React.ReactNode;\n    /** Optional description for the field. */\n    description?: React.ReactNode;\n    /** Auto-populated by parent's groupName prop if in a group. */\n    groupName?: string;\n    /** Takes either \"radio\" or \"checkbox\" value. */\n    variant: \"radio\" | \"checkbox\";\n};\n\n/**\n * This is a potentially labeled üîò or ‚òëÔ∏è item. This is an internal component\n * that's wrapped by Checkbox and Radio. Choice is a wrapper for Checkbox and\n * Radio with many of its props auto-populated, to be used with CheckboxGroup\n * and RadioGroup. This design allows for more explicit prop typing. For\n * example, we can make onChange a required prop on Checkbox but not on Choice\n * (because for Choice, that prop would be auto-populated by CheckboxGroup).\n */ const ChoiceInternal = React.forwardRef(\n    (props: Props, ref: React.ForwardedRef<HTMLInputElement>) => {\n        const {\n            checked,\n            description,\n            disabled = false,\n            error = false,\n            id,\n            label,\n            // eslint-disable-next-line @typescript-eslint/no-unused-vars\n            onChange,\n            style,\n            className,\n            // eslint-disable-next-line @typescript-eslint/no-unused-vars\n            variant,\n            // ...coreProps\n        } = props;\n\n        const handleClick: () => void = () => {\n            // Radio buttons cannot be unchecked\n            if (variant === \"radio\" && checked) {\n                return;\n            }\n            onChange(!checked);\n        };\n\n        const getChoiceCoreComponent = ():\n            | typeof RadioCore\n            | typeof CheckboxCore => {\n            if (variant === \"radio\") {\n                return RadioCore;\n            } else {\n                return CheckboxCore;\n            }\n        };\n\n        const getLabel = (id: string): React.ReactNode => {\n            return (\n                <LabelMedium\n                    style={[styles.label, disabled && styles.disabledLabel]}\n                >\n                    <label htmlFor={id}>{label}</label>\n                </LabelMedium>\n            );\n        };\n\n        const getDescription = (id?: string): React.ReactNode => {\n            return (\n                <LabelSmall style={styles.description} id={id}>\n                    {description}\n                </LabelSmall>\n            );\n        };\n\n        const ChoiceCore = getChoiceCoreComponent();\n\n        return (\n            <UniqueIDProvider mockOnFirstRender={true} scope=\"choice\">\n                {(ids) => {\n                    // A choice element should always have a unique ID set\n                    // so that the label can always refer to this element.\n                    // This guarantees that clicking on the label will\n                    // always click on the choice as well. If an ID is\n                    // passed in as a prop, use that one. Otherwise,\n                    // create a unique ID using the provider.\n                    const uniqueId = id || ids.get(\"main\");\n\n                    // Create a unique ID for the description section to be\n                    // used by this element's `aria-describedby`.\n                    const descriptionId = description\n                        ? ids.get(\"description\")\n                        : undefined;\n\n                    return (\n                        <View style={style} className={className}>\n                            <View\n                                style={styles.wrapper}\n                                // We are resetting the tabIndex=0 from handlers\n                                // because the ChoiceCore component will receive\n                                // focus on basis of it being an input element.\n                                tabIndex={-1}\n                            >\n                                <ChoiceCore\n                                    {...props}\n                                    id={uniqueId}\n                                    aria-describedby={descriptionId}\n                                    onClick={handleClick}\n                                    disabled={disabled}\n                                    error={error}\n                                    ref={ref}\n                                />\n                                <Strut size={Spacing.xSmall_8} />\n                                {label && getLabel(uniqueId)}\n                            </View>\n                            {description && getDescription(descriptionId)}\n                        </View>\n                    );\n                }}\n            </UniqueIDProvider>\n        );\n    },\n);\n\nconst styles = StyleSheet.create({\n    wrapper: {\n        flexDirection: \"row\",\n        alignItems: \"flex-start\",\n        outline: \"none\",\n    },\n    label: {\n        // NOTE: The checkbox/radio button (height 16px) should be center\n        // aligned with the first line of the label. However, LabelMedium has a\n        // declared line height of 20px, so we need to adjust the top to get the\n        // desired alignment.\n        marginTop: -2,\n    },\n    disabledLabel: {\n        color: Color.offBlack32,\n    },\n    description: {\n        // 16 for icon + 8 for spacing strut\n        marginLeft: Spacing.medium_16 + Spacing.xSmall_8,\n        marginTop: Spacing.xxxSmall_4,\n        color: Color.offBlack64,\n    },\n});\n\nexport default ChoiceInternal;\n","import * as React from \"react\";\n\nimport type {AriaProps, StyleType} from \"@khanacademy/wonder-blocks-core\";\nimport ChoiceInternal from \"./choice-internal\";\n\n// Keep synced with ChoiceComponentProps in ../util/types.js\ntype ChoiceComponentProps = AriaProps & {\n    /**\n     * Whether this component is checked\n     */\n    checked: boolean;\n    /**\n     * Whether this component is disabled\n     */\n    disabled?: boolean;\n    /**\n     * Whether this component should show an error state\n     */\n    error?: boolean;\n    /**\n     * Callback when this component is selected. The newCheckedState is the\n     * new checked state of the component.\n     */\n    onChange: (newCheckedState: boolean) => unknown;\n    /**\n     * Optional label for the field.\n     */\n    label?: React.ReactNode;\n    /**\n     * Optional description for the field.\n     */\n    description?: React.ReactNode;\n    /**\n     * Unique identifier attached to the HTML input element. If used, need to\n     * guarantee that the ID is unique within everything rendered on a page.\n     * Used to match `<label>` with `<input>` elements for screenreaders.\n     */\n    id?: string;\n    /**\n     * Optional styling for the container. Does not style the component.\n     */\n    style?: StyleType;\n    /**\n     * Adds CSS classes to the Checkbox.\n     */\n    className?: string;\n    /**\n     * Optional test ID for e2e testing\n     */\n    testId?: string;\n    /**\n     * Name for the checkbox or radio button group. Only applicable for group\n     * contexts, auto-populated by group components via Choice.\n     * @ignore\n     */\n    groupName?: string;\n};\n\n/**\n * üîò A nicely styled radio button for all your non-AMFM radio button needs. Can\n * optionally take label and description props.\n *\n * This component should not really be used by itself because radio buttons are\n * often grouped together. See RadioGroup.\n */ const Radio = React.forwardRef(\n    (\n        props: ChoiceComponentProps,\n        ref: React.ForwardedRef<HTMLInputElement>,\n    ) => {\n        const {disabled = false, error = false, ...otherProps} = props;\n\n        return (\n            <ChoiceInternal\n                {...otherProps}\n                variant=\"radio\"\n                disabled={disabled}\n                error={error}\n                ref={ref}\n            />\n        );\n    },\n);\n\nexport default Radio;\n"],"names":["mapCheckedToAriaChecked","value","blue","red","white","offWhite","offBlack16","offBlack32","offBlack50","Color","StyledInput","addStyle","checkPath","indeterminatePath","CheckboxCore","React.forwardRef","props","ref","checked","disabled","error","groupName","id","testId","sharedProps","innerRef","React.useRef","React.useEffect","handleChange","stateStyles","_generateStyles","defaultStyle","sharedStyles","checkboxIcon","jsx","Icon","ariaChecked","jsxs","React.Fragment","node","Fragment","size","StyleSheet","fadedBlue","mix","fade","activeBlue","fadedRed","activeRed","colors","styles","styleKey","palette","newStyles","RadioCore","disabledChecked","ChoiceInternal","description","label","onChange","style","className","variant","handleClick","getChoiceCoreComponent","getLabel","id2","LabelMedium","getDescription","LabelSmall","ChoiceCore","UniqueIDProvider","ids","uniqueId","descriptionId","View","Strut","Spacing","Radio","otherProps","Radio$1"],"mappings":"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"}