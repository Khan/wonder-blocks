{"version":3,"file":"icon-a4f17d53.js","sources":["../../packages/wonder-blocks-icon/src/util/icon-util.ts","../../packages/wonder-blocks-icon/src/components/icon.tsx"],"sourcesContent":["import type {IconAsset, IconSize} from \"./icon-assets\";\n\n/**\n * A simple function that tells us how many viewport pixels each icon size\n * corresponds to.\n */\nexport const viewportPixelsForSize = (size: IconSize): number =>\n    ({\n        small: 16,\n        medium: 24,\n        large: 48,\n        xlarge: 96,\n    }[size]);\n\n/**\n * A utility to find the right asset from an IconAsset to display in an icon\n * at a given IconSize. We're looking for, in the following order:\n *   1. The path for the IconSize (e.g. small, medium) requested\n *   2. A path that's _smaller_ than the size we requested\n *   3. Any path (what remains is one for a larger IconSize)\n *\n * The goal here is to provide a path that looks good at the given size...\n * obviously, if the size that we want is provided, we'll use it. Otherwise we'd\n * rather blow up a smaller, simpler icon than scrunch down a more complex one.\n */\nexport const getPathForIcon = (\n    icon: IconAsset,\n    size: IconSize,\n): {\n    assetSize: IconSize;\n    path: string;\n} => {\n    if (typeof icon[size] === \"number\") {\n        // Great, we have the IconSize we actually requested\n        // @ts-expect-error [FEI-5019] - TS2322 - Type 'string | undefined' is not assignable to type 'string'.\n        return {assetSize: size, path: icon[size]};\n    } else {\n        // Oh, no, we don't have the right IconSize! Let's find the next best\n        // one...we prefer to find a smaller icon and blow it up instead of\n        // using a larger icon and shrinking it such that detail may be lost.\n        const desiredPixelSize = viewportPixelsForSize(size);\n        const availableSizes = Object.keys(icon);\n        const sortFn = (availableSize: IconSize) => {\n            const availablePixelSize = viewportPixelsForSize(availableSize);\n            const tooLargeByPixels = availablePixelSize - desiredPixelSize;\n            return tooLargeByPixels > 0\n                ? Number.POSITIVE_INFINITY\n                : Math.abs(tooLargeByPixels);\n        };\n        // @ts-expect-error [FEI-5019] - TS2345 - Argument of type 'string' is not assignable to parameter of type 'keyof IconAsset'. | TS2345 - Argument of type 'string' is not assignable to parameter of type 'keyof IconAsset'.\n        const assetSizes = availableSizes.sort((a, b) => sortFn(a) - sortFn(b));\n        const bestAssetSize = assetSizes[0];\n        // @ts-expect-error [FEI-5019] - TS7053 - Element implicitly has an 'any' type because expression of type 'string' can't be used to index type 'IconAsset'.\n        if (bestAssetSize && icon[bestAssetSize]) {\n            // @ts-expect-error [FEI-5019] - TS2322 - Type 'string' is not assignable to type 'keyof IconAsset'. | TS7053 - Element implicitly has an 'any' type because expression of type 'string' can't be used to index type 'IconAsset'.\n            return {assetSize: bestAssetSize, path: icon[bestAssetSize]};\n        } else {\n            throw new Error(\"Icon does not contain any valid asset sizes!\");\n        }\n    }\n};\n","import * as React from \"react\";\nimport {StyleSheet} from \"aphrodite\";\n\nimport {addStyle} from \"@khanacademy/wonder-blocks-core\";\nimport type {AriaProps, StyleType} from \"@khanacademy/wonder-blocks-core\";\nimport {getPathForIcon, viewportPixelsForSize} from \"../util/icon-util\";\n\nimport type {IconAsset, IconSize} from \"../util/icon-assets\";\n\ntype Props = AriaProps & {\n    /**\n     * The color of the icon. Will default to `currentColor`, which means that\n     * it will take on the CSS `color` value from the parent element.\n     */\n    color?: string;\n    /**\n     * One of our named icons from icon-assets.js\n     */\n    icon: IconAsset;\n    /**\n     * One of `small` (16px), `medium` (24px), `large` (48px),\n     * or `xlarge` (96px).\n     */\n    size: IconSize;\n    /**\n     * Styles that can be processed by `addStyle` â€” bare style objects,\n     * Aphrodite style objects, or arrays thereof.\n     */\n    style?: StyleType;\n    /**\n     * Adds CSS classes to the Icon.\n     */\n    className?: string;\n    /**\n     * Test ID used for e2e testing.\n     */\n    testId?: string;\n};\n\ntype DefaultProps = {\n    color: Props[\"color\"];\n    size: Props[\"size\"];\n};\n\nconst StyledSVG = addStyle(\"svg\");\n\n/**\n * An Icon displays a small informational or decorative image as an SVG.\n *\n * ```js\n * import Icon, {icons} from \"@khanacademy/wonder-blocks-icon\";\n *\n * <Icon\n *     icon={icons.search}\n *     color={Color.white}\n *     size=\"medium\"\n *     style={{margin: 4}}\n * />\n * ```\n *\n * Wonder Blocks comes with a fixed set of icons available by importing `icons`,\n * but you can also provide your own `IconAsset`.\n *\n * ```js\n * import Icon from \"@khanacademy/wonder-blocks-icon\";\n * import type {IconAsset} from \"@khanacademy/wonder-blocks-icon\";\n *\n * // Easter egg: what shape am I?\n * const customIcon: IconAsset = {\n *     small: \"M6.92820 0L13.85640 4L13.85640 12L6.92820 16L0 12L0 4Z\",\n * };\n * ```\n *\n * `IconAsset` should be in the following format:\n * ```js\n * {small?: string, medium?: string, large?: string, xlarge?: string}\n * ```\n *\n * These icons should fit into a viewport of 16, 24, 48, and 96 pixels,\n * respectively.\n */\nexport default class Icon extends React.PureComponent<Props> {\n    static defaultProps: DefaultProps = {\n        color: \"currentColor\",\n        size: \"small\",\n    };\n\n    render(): React.ReactNode {\n        const {color, icon, size, style, testId, ...sharedProps} = this.props;\n\n        const {assetSize, path} = getPathForIcon(icon, size);\n        const pixelSize = viewportPixelsForSize(size);\n        const viewboxPixelSize = viewportPixelsForSize(assetSize);\n        return (\n            <StyledSVG\n                {...sharedProps}\n                style={[styles.svg, style]}\n                width={pixelSize}\n                height={pixelSize}\n                viewBox={`0 0 ${viewboxPixelSize} ${viewboxPixelSize}`}\n                data-test-id={testId}\n            >\n                <path fill={color} d={path} />\n            </StyledSVG>\n        );\n    }\n}\n\nconst styles = StyleSheet.create({\n    svg: {\n        display: \"inline-block\",\n        verticalAlign: \"text-bottom\",\n        flexShrink: 0,\n        flexGrow: 0,\n    },\n});\n"],"names":["viewportPixelsForSize","size","getPathForIcon","icon","desiredPixelSize","availableSizes","sortFn","availableSize","tooLargeByPixels","bestAssetSize","a","b","StyledSVG","addStyle","Icon","React.PureComponent","color","style","testId","sharedProps","assetSize","path","pixelSize","viewboxPixelSize","jsx","styles","StyleSheet"],"mappings":"iJAMa,MAAAA,EAAyBC,IACjC,CACG,MAAO,GACP,OAAQ,GACR,MAAO,GACP,OAAQ,EACZ,GAAEA,CAAI,EAaGC,EAAiB,CAC1BC,EACAF,IAIC,CACD,GAAI,OAAOE,EAAKF,CAAI,GAAM,SAGtB,MAAO,CAAC,UAAWA,EAAM,KAAME,EAAKF,CAAI,GACrC,CAIG,MAAAG,EAAmBJ,EAAsBC,CAAI,EAC7CI,EAAiB,OAAO,KAAKF,CAAI,EACjCG,EAAUC,GAA4B,CAExC,MAAMC,EADqBR,EAAsBO,CAAa,EAChBH,EAC9C,OAAOI,EAAmB,EACpB,OAAO,kBACP,KAAK,IAAIA,CAAgB,CAAA,EAI7BC,EADaJ,EAAe,KAAK,CAACK,EAAGC,IAAML,EAAOI,CAAC,EAAIJ,EAAOK,CAAC,CAAC,EACrC,CAAC,EAE9B,GAAAF,GAAiBN,EAAKM,CAAa,EAEnC,MAAO,CAAC,UAAWA,EAAe,KAAMN,EAAKM,CAAa,GAEpD,MAAA,IAAI,MAAM,8CAA8C,CAEtE,CACJ,EChBAG,EAAAC,EAAA,KAAA,EAqCA,MAAAC,UAAAC,EAAAA,aAAA,CAA6D,QAAA,CAOrD,KAAA,CAAA,MAAAC,EAAA,KAAAb,EAAA,KAAAF,EAAA,MAAAgB,EAAA,OAAAC,EAAA,GAAAC,CAAA,EAAA,KAAA,MAEA,CAAA,UAAAC,EAAA,KAAAC,CAAA,EAAAnB,EAAAC,EAAAF,CAAA,EACAqB,EAAAtB,EAAAC,CAAA,EACAsB,EAAAvB,EAAAoB,CAAA,EACA,OAAAI,EACIZ,EAAC,CAAA,GAAAO,EACO,MAAA,CAAAM,EAAA,IAAAR,CAAA,EACqB,MAAAK,EAClB,OAAAA,EACC,QAAA,OAAAC,CAAA,IAAAA,CAAA,GAC4C,eAAAL,EACtC,SAAAM,EAAA,OAAA,CAAA,KAAAR,EAAA,EAAAK,EAAA,CAEc,CAAA,CAChC,CAGZ,CAzBqBP,EAAA,aAAA,CACmB,MAAA,eACzB,KAAA,OAEX,EAuBJ,MAAAW,EAAAC,EAAA,WAAA,OAAA,CAAiC,IAAA,CACxB,QAAA,eACQ,cAAA,cACM,WAAA,EACH,SAAA,CACF,CAElB,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}