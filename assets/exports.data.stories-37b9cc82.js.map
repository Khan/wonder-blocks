{"version":3,"file":"exports.data.stories-37b9cc82.js","sources":["../../packages/wonder-blocks-core/src/hooks/use-force-update.ts","../../packages/wonder-blocks-data/src/util/types.ts","../../packages/wonder-blocks-data/src/hooks/use-shared-cache.ts","../../packages/wonder-blocks-data/src/util/status.ts","../../packages/wonder-blocks-data/src/util/result-from-cache-response.ts","../../packages/wonder-blocks-data/src/hooks/use-request-interception.ts","../../packages/wonder-blocks-data/src/hooks/use-server-effect.ts","../../packages/wonder-blocks-data/src/hooks/use-cached-effect.ts","../../packages/wonder-blocks-data/src/hooks/use-hydratable-effect.ts","../../packages/wonder-blocks-data/src/components/data.ts","../../__docs__/wonder-blocks-data/exports.data.stories.mdx"],"sourcesContent":["import * as React from \"react\";\n\n/**\n * Hook for forcing a component to update on demand.\n *\n * This is for use inside other hooks that do some advanced\n * trickery with storing state outside of React's own state\n * mechanisms. As such this should never be called directly\n * outside of a hook, and more often than not, is the wrong\n * choice for whatever you are trying to do. If in doubt,\n * don't use it.\n *\n * @returns {() => void} A function that forces the component to update.\n */\nexport const useForceUpdate = (): (() => void) => {\n    const [, setUpdateState] = React.useState({});\n\n    const forceUpdate = React.useCallback(() => {\n        // We leverage here that every new object instance will be seen\n        // as a state change. This is a little hacky but it works better than\n        // a boolean that would just flip-flop and could not trigger a render,\n        // or a random number that could repeat values and also then not\n        // trigger a render. This will always work.\n        setUpdateState({});\n    }, []);\n\n    return forceUpdate;\n};\n","import type {Metadata} from \"@khanacademy/wonder-stuff-core\";\n\n/**\n * Defines the various fetch policies that can be applied to requests.\n */\n// TODO(FEI-5000): Convert to TS enum after all codebases have been migrated\nexport const FetchPolicy = {\n    /**\n     * If the data is in the cache, return that; otherwise, fetch from the\n     * server.\n     */\n    CacheBeforeNetwork: \"CacheBeforeNetwork\" as const,\n\n    /**\n     * If the data is in the cache, return that; always fetch from the server\n     * regardless of cache.\n     */\n    CacheAndNetwork: \"CacheAndNetwork\" as const,\n\n    /**\n     * If the data is in the cache, return that; otherwise, do nothing.\n     */\n    CacheOnly: \"CacheOnly\" as const,\n\n    /**\n     * Ignore any existing cached result; always fetch from the server.\n     */\n    NetworkOnly: \"NetworkOnly\" as const,\n} as const;\n\n/**\n * Define what can be cached.\n *\n * We disallow functions and undefined as undefined represents a cache miss\n * and functions are not allowed.\n */\nexport type ValidCacheData =\n    | string\n    | boolean\n    | number\n    | Record<any, any>\n    | Array<ValidCacheData | null | undefined>;\n\n/**\n * The normalized result of a request.\n */\nexport type Result<TData extends ValidCacheData> =\n    | {\n          status: \"loading\";\n      }\n    | {\n          status: \"success\";\n          data: TData;\n      }\n    | {\n          status: \"error\";\n          error: Error;\n      }\n    | {\n          status: \"aborted\";\n      };\n\n/**\n * A cache entry for a fulfilled request response.\n */\nexport type CachedResponse<TData extends ValidCacheData> =\n    | {\n          readonly error: string;\n          readonly data?: undefined;\n      }\n    | {\n          readonly data: TData;\n          readonly error?: undefined;\n      };\n\n/**\n * A cache of fulfilled request responses.\n */\nexport type ResponseCache = {\n    [key: string]: CachedResponse<any>;\n};\n\n/**\n * A cache with scoped sections.\n */\nexport type RawScopedCache = {\n    /**\n     * The cache is scoped to allow easier clearing of different types of usage.\n     */\n    [scope: string]: {\n        /**\n         * Each value in the cache is then identified within a given scope.\n         */\n        [id: string]: ValidCacheData;\n    };\n};\n\n/**\n * Options to pass to error construction.\n */\nexport type ErrorOptions = {\n    /**\n     * Metadata to attach to the error.\n     */\n    metadata?: Metadata | null | undefined;\n    /**\n     * The error that caused the error being constructed.\n     */\n    cause?: Error | null | undefined;\n};\n\nexport interface ScopedCache {\n    set(scope: string, id: string, value: ValidCacheData): void;\n    /**\n     * Retrieve a value from the cache.\n     */\n    get(scope: string, id: string): ValidCacheData | null | undefined;\n    /**\n     * Purge an item from the cache.\n     */\n    purge(scope: string, id: string): void;\n    /**\n     * Purge a scope of items that match the given predicate.\n     *\n     * If the predicate is omitted, then all items in the scope are purged.\n     */\n    purgeScope(\n        scope: string,\n        predicate?: (id: string, value: ValidCacheData) => boolean,\n    ): void;\n    /**\n     * Purge all items from the cache that match the given predicate.\n     *\n     * If the predicate is omitted, then all items in the cache are purged.\n     */\n    purgeAll(\n        predicate?: (\n            scope: string,\n            id: string,\n            value: ValidCacheData,\n        ) => boolean,\n    ): void;\n}\n","import * as React from \"react\";\nimport {DataError, DataErrors} from \"../util/data-error\";\nimport {ScopedInMemoryCache} from \"../util/scoped-in-memory-cache\";\nimport type {ValidCacheData, ScopedCache} from \"../util/types\";\n\n/**\n * A function for inserting a value into the cache or clearing it.\n */\ntype CacheValueFn<TValue extends ValidCacheData> = (\n    value?: TValue | null | undefined,\n) => void;\n\n/**\n * This is the cache.\n * It's incredibly complex.\n * Very in-memory. So cache. Such complex. Wow.\n */\nconst cache = new ScopedInMemoryCache();\n\n/**\n * Access to the shared in-memory cache.\n *\n * This is the cache used by `useSharedCache` and related hooks and\n * components.\n */\nexport const SharedCache: ScopedCache = cache;\n\n/**\n * Hook to retrieve data from and store data in an in-memory cache.\n *\n * @returns {[?ReadOnlyCacheValue, CacheValueFn]}\n * Returns an array containing the current cache entry (or undefined), a\n * function to set the cache entry (passing null or undefined to this function\n * will delete the entry).\n *\n * NOTE: Unlike useState or useReducer, we don't automatically update folks\n * if the value they reference changes. We might add it later (if we need to),\n * but the likelihood here is that things won't be changing in this cache in a\n * way where we would need that. If we do (and likely only in specific\n * circumstances), we should consider adding a simple boolean useState that can\n * be toggled to cause a rerender whenever the referenced cached data changes\n * so that callers can re-render on cache changes. However, we should make\n * sure this toggling is optional - or we could use a callback argument, to\n * achieve this on an as-needed basis.\n */\nexport const useSharedCache = <TValue extends ValidCacheData>(\n    id: string,\n    scope: string,\n    initialValue?:\n        | TValue\n        | null\n        | undefined\n        | (() => TValue | null | undefined),\n): [TValue | null | undefined, CacheValueFn<TValue>] => {\n    // Verify arguments.\n    if (!id || typeof id !== \"string\") {\n        throw new DataError(\n            \"id must be a non-empty string\",\n            DataErrors.InvalidInput,\n        );\n    }\n\n    if (!scope || typeof scope !== \"string\") {\n        throw new DataError(\n            \"scope must be a non-empty string\",\n            DataErrors.InvalidInput,\n        );\n    }\n\n    // Memoize our APIs.\n    // This one allows callers to set or replace the cached value.\n    const cacheValue = React.useCallback(\n        (value?: TValue | null) =>\n            value == null\n                ? cache.purge(scope, id)\n                : cache.set(scope, id, value),\n        [id, scope],\n    );\n\n    // We don't memo-ize the current value, just in case the cache was updated\n    // since our last run through. Also, our cache does not know what type it\n    // stores, so we have to cast it to the type we're exporting. This is a\n    // dev time courtesy, rather than a runtime thing.\n    // @ts-expect-error [FEI-5019] - TS2322 - Type 'ValidCacheData | null | undefined' is not assignable to type 'TValue | null | undefined'.\n    let currentValue: TValue | null | undefined = cache.get(scope, id);\n\n    // If we have an initial value, we need to add it to the cache\n    // and use it as our current value.\n    if (currentValue == null && initialValue !== undefined) {\n        // Get the initial value.\n        const value =\n            typeof initialValue === \"function\" ? initialValue() : initialValue;\n\n        if (value != null) {\n            // Update the cache.\n            cacheValue(value);\n\n            // Make sure we return this value as our current value.\n            currentValue = value;\n        }\n    }\n\n    // Now we have everything, let's return it.\n    return [currentValue, cacheValue];\n};\n","import type {Result, ValidCacheData} from \"./types\";\n\nconst loadingStatus = Object.freeze({\n    status: \"loading\",\n});\n\nconst abortedStatus = Object.freeze({\n    status: \"aborted\",\n});\n\n/**\n * Create Result<TData> instances with specific statuses.\n */\nexport const Status = Object.freeze({\n    loading: <TData extends ValidCacheData = ValidCacheData>(): Result<TData> =>\n        loadingStatus,\n    aborted: <TData extends ValidCacheData = ValidCacheData>(): Result<TData> =>\n        abortedStatus,\n    success: <TData extends ValidCacheData>(data: TData): Result<TData> => ({\n        status: \"success\",\n        data,\n    }),\n    error: <TData extends ValidCacheData = ValidCacheData>(\n        error: Error,\n    ): Result<TData> => ({\n        status: \"error\",\n        error,\n    }),\n});\n","import {Status} from \"./status\";\nimport {DataError, DataErrors} from \"./data-error\";\nimport type {ValidCacheData, CachedResponse, Result} from \"./types\";\n\n/**\n * Turns a cache entry into a stateful result.\n */\nexport const resultFromCachedResponse = <TData extends ValidCacheData>(\n    cacheEntry?: CachedResponse<TData> | null,\n): Result<TData> | null | undefined => {\n    // No cache entry means no result to be hydrated.\n    if (cacheEntry == null) {\n        return null;\n    }\n\n    const {data, error} = cacheEntry;\n    if (error != null) {\n        // Let's hydrate the error. We don't persist everything about the\n        // original error on the server, hence why we only superficially\n        // hydrate it to a GqlHydratedError.\n        return Status.error(new DataError(error, DataErrors.Hydrated));\n    }\n\n    if (data != null) {\n        return Status.success(data);\n    }\n\n    // We shouldn't get here since we don't actually cache null data.\n    return Status.aborted();\n};\n","import * as React from \"react\";\n\nimport InterceptContext from \"../components/intercept-context\";\nimport type {ValidCacheData} from \"../util/types\";\n\n/**\n * Allow request handling to be intercepted.\n *\n * Hook to take a uniquely identified request handler and return a\n * method that will support request interception from the InterceptRequest\n * component.\n *\n * If you want request interception to be supported with `useServerEffect` or\n * any client-side effect that uses the handler, call this first to generate\n * an intercepted handler, and then invoke `useServerEffect` (or other things)\n * with that intercepted handler.\n */\nexport const useRequestInterception = <TData extends ValidCacheData>(\n    requestId: string,\n    handler: () => Promise<TData>,\n): (() => Promise<TData>) => {\n    // Get the interceptors that have been registered.\n    const interceptors = React.useContext(InterceptContext);\n\n    // Now, we need to create a new handler that will check if the\n    // request is intercepted before ultimately calling the original handler\n    // if nothing intercepted it.\n    // We memoize this so that it only changes if something related to it\n    // changes.\n    const interceptedHandler = React.useCallback((): Promise<TData> => {\n        // Call the interceptors from closest to furthest.\n        // If one returns a non-null result, then we keep that.\n        const interceptResponse = interceptors.reduceRight(\n            // @ts-expect-error [FEI-5019] - TS2769 - No overload matches this call.\n            (prev, interceptor) => {\n                if (prev != null) {\n                    return prev;\n                }\n                return interceptor(requestId);\n            },\n            null,\n        );\n        // If nothing intercepted this request, invoke the original handler.\n        // NOTE: We can't guarantee all interceptors return the same type\n        // as our handler, so how can TypeScript know? Let's just suppress that.\n        // @ts-expect-error [FEI-5019] - TS2739 - Type '(requestId: string) => Promise<ValidCacheData | null | undefined> | null | undefined' is missing the following properties from type 'Promise<TData>': then, catch, finally, [Symbol.toStringTag]\n        return interceptResponse ?? handler();\n    }, [handler, interceptors, requestId]);\n\n    return interceptedHandler;\n};\n","import {Server} from \"@khanacademy/wonder-blocks-core\";\nimport {useContext} from \"react\";\nimport {TrackerContext} from \"../util/request-tracking\";\nimport {SsrCache} from \"../util/ssr-cache\";\nimport {resultFromCachedResponse} from \"../util/result-from-cache-response\";\nimport {useRequestInterception} from \"./use-request-interception\";\n\nimport type {Result, ValidCacheData} from \"../util/types\";\n\ntype ServerEffectOptions = {\n    /**\n     * When `true`, the result of the effect when fulfilled using Wonder Blocks\n     * Data will be stored in the hydration cache for hydrating client-side;\n     * otherwise, the result will be stored in the server-side-only cache.\n     *\n     * This should only be set to `false` if something else will be responsible\n     * for hydration of the data on the client-side (for example, if Apollo's\n     * hydration support is used).\n     *\n     * Default is `true`.\n     */\n    hydrate?: boolean;\n    /**\n     * When `true`, the effect will not be tracked for fulfillment; otherwise,\n     * the effect will be tracked for fulfillment.\n     *\n     * Default is `false`.\n     */\n    skip?: boolean;\n};\n\n/**\n * Hook to perform an asynchronous action during server-side rendering.\n *\n * This hook registers an asynchronous action to be performed during\n * server-side rendering. The action is performed only once, and the result\n * is cached against the given identifier so that subsequent calls return that\n * cached result allowing components to render more of the component.\n *\n * This hook requires the Wonder Blocks Data functionality for resolving\n * pending requests, as well as support for the hydration cache to be\n * embedded into a page so that the result can by hydrated (if that is a\n * requirement).\n *\n * The asynchronous action is never invoked on the client-side.\n */\nexport const useServerEffect = <TData extends ValidCacheData>(\n    requestId: string,\n    handler: () => Promise<TData>,\n    options: ServerEffectOptions = {} as Partial<ServerEffectOptions>,\n): Result<TData> | null | undefined => {\n    const {hydrate = true, skip = false} = options;\n\n    // Plug in to the request interception framework for code that wants\n    // to use that.\n    const interceptedHandler = useRequestInterception(requestId, handler);\n\n    // If we're server-side or hydrating, we'll have a cached entry to use.\n    // So we get that and use it to initialize our state.\n    // This works in both hydration and SSR because the very first call to\n    // this will have cached data in those cases as it will be present on the\n    // initial render - and subsequent renders on the client it will be null.\n    const cachedResult = SsrCache.Default.getEntry<TData>(requestId);\n\n    // We only track data requests when we are server-side, we are not skipping\n    // the request, and we don't already have a result, as given by the\n    // cachedData (which is also the initial value for the result state).\n    const maybeTrack = useContext(TrackerContext);\n    if (!skip && cachedResult == null && Server.isServerSide()) {\n        maybeTrack?.(requestId, interceptedHandler, hydrate);\n    }\n\n    // A null result means there was no result to hydrate.\n    return cachedResult == null ? null : resultFromCachedResponse(cachedResult);\n};\n","import * as React from \"react\";\nimport {useForceUpdate} from \"@khanacademy/wonder-blocks-core\";\nimport {DataError, DataErrors} from \"../util/data-error\";\n\nimport {RequestFulfillment} from \"../util/request-fulfillment\";\nimport {Status} from \"../util/status\";\n\nimport {useSharedCache} from \"./use-shared-cache\";\nimport {useRequestInterception} from \"./use-request-interception\";\n\nimport type {Result, ValidCacheData} from \"../util/types\";\n\nimport {FetchPolicy} from \"../util/types\";\n\ntype CachedEffectOptions<TData extends ValidCacheData> = {\n    /**\n     * The policy to use when determining how to retrieve the request data from\n     * cache and network.\n     *\n     * Defaults to `FetchPolicy.CacheBeforeNetwork`.\n     */\n    fetchPolicy?: typeof FetchPolicy[keyof typeof FetchPolicy];\n    /**\n     * When `true`, the effect will not be executed; otherwise, the effect will\n     * be executed.\n     *\n     * If this is set to `true` while the effect is still pending, the pending\n     * effect will be cancelled.\n     *\n     * Default is `false`.\n     */\n    skip?: boolean;\n    /**\n     * When `true`, the effect will not reset the result to the loading status\n     * while executing if the requestId changes, instead, returning\n     * the existing result from before the change; otherwise, the result will\n     * be set to loading status.\n     *\n     * If the status is loading when the changes are made, it will remain as\n     * loading; old pending effects are discarded on changes and as such this\n     * value has no effect in that case.\n     */\n    retainResultOnChange?: boolean;\n    /**\n     * Callback that is invoked if the result for the given hook has changed.\n     *\n     * When defined, the hook will invoke this callback whenever it has reason\n     * to change the result and will not otherwise affect component rendering\n     * directly.\n     *\n     * When not defined, the hook will ensure the component re-renders to pick\n     * up the latest result.\n     */\n    onResultChanged?: (result: Result<TData>) => void;\n    /**\n     * Scope to use with the shared cache.\n     *\n     * When specified, the given scope will be used to isolate this hook's\n     * cached results. Otherwise, a shared default scope will be used.\n     *\n     * Changing this value after the first call is not supported.\n     */\n    scope?: string;\n};\n\nconst DefaultScope = \"useCachedEffect\";\n\n/**\n * Hook to execute and cache an async operation on the client.\n *\n * This hook executes the given handler on the client if there is no\n * cached result to use.\n *\n * Results are cached so they can be shared between equivalent invocations.\n * In-flight requests are also shared, so that concurrent calls will\n * behave as one might exect. Cache updates invoked by one hook instance\n * do not trigger renders in components that use the same requestID; however,\n * that should not matter since concurrent requests will share the same\n * in-flight request, and subsequent renders will grab from the cache.\n *\n * Once the request has been tried once and a non-loading response has been\n * cached, the request will not executed made again.\n */\nexport const useCachedEffect = <TData extends ValidCacheData>(\n    requestId: string,\n    handler: () => Promise<TData>,\n    options: CachedEffectOptions<TData> = {} as Partial<\n        CachedEffectOptions<TData>\n    >,\n): [Result<TData>, () => void] => {\n    const {\n        fetchPolicy = FetchPolicy.CacheBeforeNetwork,\n        skip: hardSkip = false,\n        retainResultOnChange = false,\n        onResultChanged,\n        scope = DefaultScope,\n    } = options;\n\n    // Plug in to the request interception framework for code that wants\n    // to use that.\n    const interceptedHandler = useRequestInterception(requestId, handler);\n\n    // Instead of using state, which would be local to just this hook instance,\n    // we use a shared in-memory cache.\n    const [mostRecentResult, setMostRecentResult] = useSharedCache<\n        Result<TData>\n    >( // The key of the cached item\n        requestId, // The scope of the cached items\n        // No default value. We don't want the loading status there; to ensure\n        // that all calls when the request is in-flight will update once that\n        // request is done, we want the cache to be empty until that point.\n        scope,\n    );\n    const forceUpdate = useForceUpdate();\n    // For the NetworkOnly fetch policy, we ignore the cached value.\n    // So we need somewhere else to store the network value.\n    const networkResultRef = React.useRef();\n\n    // Set up the function that will do the fetching.\n    const currentRequestRef = React.useRef();\n    const fetchRequest = React.useMemo(() => {\n        // We aren't using useCallback here because we need to make sure that\n        // if we are rememo-izing, we cancel any inflight request for the old\n        // callback.\n        // @ts-expect-error [FEI-5019] - TS2339 - Property 'cancel' does not exist on type 'never'.\n        currentRequestRef.current?.cancel();\n        // @ts-expect-error [FEI-5019] - TS2322 - Type 'null' is not assignable to type 'undefined'.\n        currentRequestRef.current = null;\n        // @ts-expect-error [FEI-5019] - TS2322 - Type 'null' is not assignable to type 'undefined'.\n        networkResultRef.current = null;\n\n        const fetchFn = () => {\n            if (fetchPolicy === FetchPolicy.CacheOnly) {\n                throw new DataError(\n                    \"Cannot fetch with CacheOnly policy\",\n                    DataErrors.NotAllowed,\n                );\n            }\n            // We use our request fulfillment here so that in-flight\n            // requests are shared. In order to ensure that we don't share\n            // in-flight requests for different scopes, we add the scope to the\n            // requestId.\n            // We do this as a courtesy to simplify usage in sandboxed\n            // uses like storybook where we want each story to perform their\n            // own requests from scratch and not share inflight requests across\n            // stories.\n            // Since this only occurs here, nothing else will care about this\n            // change except the request tracking.\n            const request = RequestFulfillment.Default.fulfill(\n                `${requestId}|${scope}`,\n                {\n                    handler: interceptedHandler,\n                },\n            );\n\n            // @ts-expect-error [FEI-5019] - TS2339 - Property 'request' does not exist on type 'never'.\n            if (request === currentRequestRef.current?.request) {\n                // The request inflight is the same, so do nothing.\n                // NOTE: Perhaps if invoked via a refetch, we will want to\n                // override this behavior and force a new request?\n                return;\n            }\n\n            // Clear the last network result.\n            // @ts-expect-error [FEI-5019] - TS2322 - Type 'null' is not assignable to type 'undefined'.\n            networkResultRef.current = null;\n\n            // Cancel the previous request.\n            // @ts-expect-error [FEI-5019] - TS2339 - Property 'cancel' does not exist on type 'never'.\n            currentRequestRef.current?.cancel();\n\n            // TODO(somewhatabstract, FEI-4276):\n            // Until our RequestFulfillment API supports cancelling/aborting, we\n            // will have to do it.\n            let cancel = false;\n\n            // NOTE: Our request fulfillment handles the error cases here.\n            // Catching shouldn't serve a purpose.\n            // eslint-disable-next-line promise/catch-or-return\n            request.then((result) => {\n                // @ts-expect-error [FEI-5019] - TS2322 - Type 'null' is not assignable to type 'undefined'.\n                currentRequestRef.current = null;\n                if (cancel) {\n                    // We don't modify our result if the request was cancelled\n                    // as it means that this hook no longer cares about that old\n                    // request.\n                    return;\n                }\n\n                // Now we need to update the cache and notify or force a rerender.\n                setMostRecentResult(result);\n                // @ts-expect-error [FEI-5019] - TS2322 - Type 'Result<TData>' is not assignable to type 'undefined'.\n                networkResultRef.current = result;\n\n                if (onResultChanged != null) {\n                    // If we have a callback, call it to let our caller know we\n                    // got a result.\n                    onResultChanged(result);\n                } else {\n                    // If there's no callback, and this is using cache in some\n                    // capacity, just force a rerender.\n                    forceUpdate();\n                }\n                return; // Shut up eslint always-return rule.\n            });\n\n            // @ts-expect-error [FEI-5019] - TS2322 - Type '{ requestId: string; request: Promise<Result<TData>>; cancel(): void; }' is not assignable to type 'undefined'.\n            currentRequestRef.current = {\n                requestId,\n                request,\n                cancel() {\n                    cancel = true;\n                    RequestFulfillment.Default.abort(requestId);\n                },\n            };\n        };\n\n        // Now we can return the new fetch function.\n        return fetchFn;\n\n        // We deliberately ignore the handler here because we want folks to use\n        // interceptor functions inline in props for simplicity. This is OK\n        // since changing the handler without changing the requestId doesn't\n        // really make sense - the same requestId should be handled the same as\n        // each other.\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        requestId,\n        onResultChanged,\n        forceUpdate,\n        setMostRecentResult,\n        fetchPolicy,\n    ]);\n\n    // Calculate if we want to fetch the result or not.\n    // If this is true, we will do a new fetch, cancelling the previous fetch\n    // if there is one inflight.\n    const shouldFetch = React.useMemo(() => {\n        if (hardSkip) {\n            // We don't fetch if we've been told to hard skip.\n            return false;\n        }\n\n        switch (fetchPolicy) {\n            case FetchPolicy.CacheOnly:\n                // Don't want to do a network request if we're only\n                // interested in the cache.\n                return false;\n\n            case FetchPolicy.CacheBeforeNetwork:\n                // If we don't have a cached value then we need to fetch.\n                return mostRecentResult == null;\n\n            case FetchPolicy.CacheAndNetwork:\n            case FetchPolicy.NetworkOnly:\n                // We don't care about the cache. If we don't have a network\n                // result, then we need to fetch one.\n                return networkResultRef.current == null;\n        }\n    }, [mostRecentResult, fetchPolicy, hardSkip]);\n\n    React.useEffect(() => {\n        if (!shouldFetch) {\n            return;\n        }\n        fetchRequest();\n        return () => {\n            // @ts-expect-error [FEI-5019] - TS2339 - Property 'cancel' does not exist on type 'never'.\n            currentRequestRef.current?.cancel();\n            // @ts-expect-error [FEI-5019] - TS2322 - Type 'null' is not assignable to type 'undefined'.\n            currentRequestRef.current = null;\n        };\n    }, [shouldFetch, fetchRequest]);\n\n    // We track the last result we returned in order to support the\n    // \"retainResultOnChange\" option.\n    const lastResultAgnosticOfIdRef = React.useRef(Status.loading());\n    const loadingResult = retainResultOnChange\n        ? lastResultAgnosticOfIdRef.current\n        : Status.loading();\n\n    // Loading is a transient state, so we only use it here; it's not something\n    // we cache.\n    const result =\n        (fetchPolicy === FetchPolicy.NetworkOnly\n            ? networkResultRef.current\n            : mostRecentResult) ?? loadingResult;\n    lastResultAgnosticOfIdRef.current = result;\n\n    // We return the result and a function for triggering a refetch.\n    // @ts-expect-error [FEI-5019] - TS2322 - Type '{ status: \"loading\"; } | { status: \"error\"; error: Error; } | { status: \"aborted\"; } | { status: \"success\"; data: ValidCacheData; }' is not assignable to type 'Result<TData>'.\n    return [result, fetchRequest];\n};\n","import * as React from \"react\";\n\nimport {useServerEffect} from \"./use-server-effect\";\nimport {useSharedCache} from \"./use-shared-cache\";\nimport {useCachedEffect} from \"./use-cached-effect\";\n\nimport {FetchPolicy} from \"../util/types\";\nimport type {Result, ValidCacheData} from \"../util/types\";\n\n/**\n * Policies to define how a hydratable effect should behave client-side.\n */\n// TODO(FEI-5000): Convert to TS enum after all codebases have been migrated\nexport const WhenClientSide = {\n    /**\n     * The result from executing the effect server-side will not be hydrated.\n     * The effect will always be executed client-side.\n     *\n     * This should only be used if there is something else that is responsible\n     * for properly hydrating this component (for example, the action invokes\n     * Apollo which manages its own cache to ensure things render properly).\n     */\n    DoNotHydrate: \"DoNotHydrate\" as const,\n\n    /**\n     * The result from executing the effect server-side will be hydrated.\n     * The effect will only execute client-side if there was no result to\n     * be hydrated (i.e. both error and success hydration results prevent the\n     * effect running client-side).\n     */\n    ExecuteWhenNoResult: \"ExecuteWhenNoResult\" as const,\n\n    /**\n     * The result from executing the effect server-side will be hydrated.\n     * If the hydrated result is a success result, the effect will not be\n     * executed client-side.\n     * If the hydrated result was not a success result, or there was no\n     * hydrated result, the effect will not be executed.\n     */\n    ExecuteWhenNoSuccessResult: \"ExecuteWhenNoSuccessResult\" as const,\n\n    /**\n     * The result from executing the effect server-side will be hydrated.\n     * The effect will always be executed client-side, regardless of the\n     * hydrated result status.\n     */\n    AlwaysExecute: \"AlwaysExecute\" as const,\n} as const;\n\ntype HydratableEffectOptions<TData extends ValidCacheData> = {\n    /**\n     * How the hook should behave when rendering client-side for the first time.\n     *\n     * This controls how the hook hydrates and executes when client-side.\n     *\n     * Default is `WhenClientSide.ExecuteWhenNoSuccessResult`.\n     *\n     * Changing this value after the first call is irrelevant as it only\n     * affects the initial render behavior.\n     */\n    clientBehavior?: typeof WhenClientSide[keyof typeof WhenClientSide];\n    /**\n     * When `true`, the effect will not be executed; otherwise, the effect will\n     * be executed.\n     *\n     * If this is set to `true` while the effect is still pending, the pending\n     * effect will be cancelled.\n     *\n     * Default is `false`.\n     */\n    skip?: boolean;\n    /**\n     * When `true`, the effect will not reset the result to the loading status\n     * while executing if the requestId changes, instead, returning\n     * the existing result from before the change; otherwise, the result will\n     * be set to loading status.\n     *\n     * If the status is loading when the changes are made, it will remain as\n     * loading; old pending effects are discarded on changes and as such this\n     * value has no effect in that case.\n     */\n    retainResultOnChange?: boolean;\n    /**\n     * Callback that is invoked if the result for the given hook has changed.\n     *\n     * When defined, the hook will invoke this callback whenever it has reason\n     * to change the result and will not otherwise affect component rendering\n     * directly.\n     *\n     * When not defined, the hook will ensure the component re-renders to pick\n     * up the latest result.\n     */\n    onResultChanged?: (result: Result<TData>) => void;\n    /**\n     * Scope to use with the shared cache.\n     *\n     * When specified, the given scope will be used to isolate this hook's\n     * cached results. Otherwise, a shared default scope will be used.\n     *\n     * Changing this value after the first call is not supported.\n     */\n    scope?: string;\n};\n\nconst DefaultScope = \"useHydratableEffect\";\n\n/**\n * Hook to execute an async operation on server and client.\n *\n * This hook executes the given handler on the server and on the client,\n * and, depending on the given options, can hydrate the server-side result.\n *\n * Results are cached on the client so they can be shared between equivalent\n * invocations. Cache changes from one hook instance do not trigger renders\n * in components that use the same requestID.\n */\nexport const useHydratableEffect = <TData extends ValidCacheData>(\n    requestId: string,\n    handler: () => Promise<TData>,\n    options: HydratableEffectOptions<TData> = {} as Partial<\n        HydratableEffectOptions<TData>\n    >,\n): Result<TData> => {\n    const {\n        clientBehavior = WhenClientSide.ExecuteWhenNoSuccessResult,\n        skip = false,\n        retainResultOnChange = false,\n        onResultChanged,\n        scope = DefaultScope,\n    } = options;\n\n    // Now we instruct the server to perform the operation.\n    // When client-side, this will look up any response for hydration; it does\n    // not invoke the handler.\n    const serverResult = useServerEffect(requestId, handler, {\n        // Only hydrate if our behavior isn't telling us not to.\n        hydrate: clientBehavior !== WhenClientSide.DoNotHydrate,\n        skip,\n    });\n\n    const getDefaultCacheValue: () => Result<TData> | null | undefined =\n        React.useCallback(() => {\n            // If we don't have a requestId, it's our first render, the one\n            // where we hydrated. So defer to our clientBehavior value.\n            switch (clientBehavior) {\n                case WhenClientSide.DoNotHydrate:\n                case WhenClientSide.AlwaysExecute:\n                    // Either we weren't hydrating at all, or we don't care\n                    // if we hydrated something or not, either way, we're\n                    // doing a request.\n                    return null;\n\n                case WhenClientSide.ExecuteWhenNoResult:\n                    // We only execute if we didn't hydrate something.\n                    // So, returning the hydration result as default for our\n                    // cache, will then prevent the cached effect running.\n                    return serverResult;\n\n                case WhenClientSide.ExecuteWhenNoSuccessResult:\n                    // We only execute if we didn't hydrate a success result.\n                    if (serverResult?.status === \"success\") {\n                        // So, returning the hydration result as default for our\n                        // cache, will then prevent the cached effect running.\n                        return serverResult;\n                    }\n                    return null;\n            }\n            // There is no reason for this to change after the first render,\n            // you might think, but the function closes around serverResult and if\n            // the requestId changes, it still returns the hydrate result of the\n            // first render of the previous requestId. This then means that the\n            // hydrate result is still the same, and the effect is not re-executed\n            // because the cache gets incorrectly defaulted.\n            // However, we don't want to bother doing anything with this on\n            // client behavior changing since that truly is irrelevant.\n            // eslint-disable-next-line react-hooks/exhaustive-deps\n        }, [serverResult]);\n\n    // Instead of using state, which would be local to just this hook instance,\n    // we use a shared in-memory cache.\n    useSharedCache<Result<TData>>( // The key of the cached item\n        requestId, // The scope of the cached items\n        scope,\n        getDefaultCacheValue,\n    );\n\n    // When we're client-side, we ultimately want the result from this call.\n    const [clientResult] = useCachedEffect(requestId, handler, {\n        skip,\n        onResultChanged,\n        retainResultOnChange,\n        scope,\n        // Be explicit about our fetch policy for clarity.\n        fetchPolicy: FetchPolicy.CacheBeforeNetwork,\n    });\n\n    // OK, now which result do we return.\n    // Well, we return the serverResult on our very first call and then\n    // the clientResult thereafter. The great thing is that after the very\n    // first call, the serverResult is going to be `null` anyway.\n    return serverResult ?? clientResult;\n};\n","import * as React from \"react\";\n\nimport {\n    useHydratableEffect,\n    WhenClientSide,\n} from \"../hooks/use-hydratable-effect\";\n\nimport type {Result, ValidCacheData} from \"../util/types\";\n\ntype Props<\n    /**\n     * The type of data resolved by the handler's fulfillRequest method.\n     */\n    TData extends ValidCacheData,\n> = {\n    /**\n     * A unique identifier for the request.\n     *\n     * This should not be shared by other uses of this component.\n     */\n    requestId: string;\n    /**\n     * This defines how the request is fulfilled.\n     *\n     * If this is changed without changing the ID, there are cases where the\n     * old handler result may be given. This is not a supported mode of\n     * operation.\n     */\n    handler: () => Promise<TData>;\n    /**\n     * How the hook should behave when rendering client-side for the first time.\n     *\n     * This controls how the hook hydrates and executes when client-side.\n     *\n     * Default is `OnClientRender.ExecuteWhenNoSuccessResult`.\n     */\n    clientBehavior?: typeof WhenClientSide[keyof typeof WhenClientSide];\n    /**\n     * When true, the children will be rendered with the existing result\n     * until the pending load is completed. Otherwise, the children will be\n     * given a loading state until the request is fulfilled.\n     *\n     * Defaults to false.\n     */\n    retainResultOnChange?: boolean;\n    /**\n     * A function that will render the content of this component using the\n     * loading state and data or error that gets retrieved from cache or loaded\n     * via the request if no cached value is available.\n     */\n    children: (result: Result<TData>) => React.ReactNode;\n};\n\n/**\n * This component is the main component of Wonder Blocks Data. With this, data\n * requirements can be placed in a React application in a manner that will\n * support server-side rendering and efficient caching.\n */\nconst Data = <TData extends ValidCacheData>({\n    requestId,\n    handler,\n    children,\n    retainResultOnChange = false,\n    clientBehavior = WhenClientSide.ExecuteWhenNoSuccessResult,\n}: Props<TData>): React.ReactElement => {\n    const result = useHydratableEffect(requestId, handler, {\n        retainResultOnChange,\n        clientBehavior,\n    });\n    // @ts-expect-error: React TS types don't allow functional components to return\n    // ReactNodes even though React itself does.\n    return children(result);\n};\n\nexport default Data;\n","import {Meta} from \"@storybook/blocks\";\nimport {Data} from \"@khanacademy/wonder-blocks-data\";\n\n<Meta\n    title=\"Data / Exports / Data\"\n    component={Data}\n    parameters={{\n        chromatic: {\n            disableSnapshot: true,\n        },\n    }}\n/>\n\n# Data\n\nThe `Data` component is the frontend piece of our data architecture.\nIt describes a data requirement in terms of a handler and an identifier.\nIt also has props to govern hydrate behavior as well as loading and client-side\nrequest behavior.\n\nThe handler is responsible for fulfilling the request when asked to do so.\n\n#### Server-side Rendering and Hydration\n\nThe Wonder Blocks Data framework uses an in-memory cache for supporting\nserver-side rendering (SSR) and hydration.\n\n##### Server-side behavior\n\n###### Cache miss\n\nWhen the `Data` component does not get data or an error from the cache and it\nis rendering server-side, it tells our request tracking that it wants data, and\nit renders in its `loading` state. It will always render in this state if there\nis no cached response.\n\n###### Cache hit\n\nWhen the `Data` component gets data or an error from the cache and it is\nrendering server-side, it will render as loaded, with that data or error,\nas it would client-side. In this situation, it does not track the request it\nwould have made, as it already has the data and doesn't need to.\n\n##### Client-side behavior\n\n###### Cache miss\n\nWhen the hydration cache does not contain the data, the data will be requested.\nWhile the request is pending, the data is rendered in the loading state.\nIn this example, we use a 3 second delayed promise to simulate the request.\nWe start out without any data and so the request is made. Upon receipt of that\ndata or an error, we re-render.\n\n```jsx\nimport {Body, BodyMonospace} from \"@khanacademy/wonder-blocks-typography\";\nimport {View} from \"@khanacademy/wonder-blocks-core\";\nimport {Data} from \"@khanacademy/wonder-blocks-data\";\nimport {Strut} from \"@khanacademy/wonder-blocks-layout\";\nimport Color from \"@khanacademy/wonder-blocks-color\";\nimport Spacing from \"@khanacademy/wonder-blocks-spacing\";\n\nconst myValidHandler = () =>\n    new Promise((resolve, reject) =>\n        setTimeout(() => resolve(\"I'm DATA from a request\"), 3000),\n    );\n\nconst myInvalidHandler = () =>\n    new Promise((resolve, reject) =>\n        setTimeout(() => reject(\"I'm an ERROR from a request\"), 3000),\n    );\n\n<View>\n    <View>\n        <Body>This request will succeed and give us data!</Body>\n        <Data handler={myValidHandler} requestId=\"VALID\">\n            {(result) => {\n                if (result.status === \"loading\") {\n                    return \"Loading...\";\n                }\n\n                return <BodyMonospace>{result.data}</BodyMonospace>;\n            }}\n        </Data>\n    </View>\n    <Strut size={Spacing.small_12} />\n    <View>\n        <Body>This request will go boom and give us an error!</Body>\n        <Data handler={myInvalidHandler} requestId=\"INVALID\">\n            {(result) => {\n                if (result.status === \"loading\") {\n                    return \"Loading...\";\n                }\n\n                return (\n                    <BodyMonospace style={{color: Color.red}}>\n                        ERROR: {result.error}\n                    </BodyMonospace>\n                );\n            }}\n        </Data>\n    </View>\n</View>;\n```\n\n###### Cache hit\n\nIf the hydration cache already contains data or an error for our request, then\nthe `Data` component will render it immediately. The hydration cache is\npopulated using the `initializeHydrationCache` method before rendering.\n\n```jsx\nimport {Body, BodyMonospace} from \"@khanacademy/wonder-blocks-typography\";\nimport {View} from \"@khanacademy/wonder-blocks-core\";\nimport {Data, initializeHydrationCache} from \"@khanacademy/wonder-blocks-data\";\nimport {Strut} from \"@khanacademy/wonder-blocks-layout\";\nimport Color from \"@khanacademy/wonder-blocks-color\";\nimport Spacing from \"@khanacademy/wonder-blocks-spacing\";\n\nconst myHandler = () => {\n    throw new Error(\n        \"If you're seeing this error, the examples are broken and data isn't in the cache that should be.\",\n    );\n};\n\ninitializeHydrationCache({\n    DATA: {\n        data: \"I'm DATA from the hydration cache\",\n    },\n});\n\n<View>\n    <View>\n        <Body>This cache has data!</Body>\n        <Data handler={myHandler} requestId=\"DATA\">\n            {(result) => {\n                if (result.status !== \"success\") {\n                    return \"If you see this, the example is broken!\";\n                }\n\n                return <BodyMonospace>{result.data}</BodyMonospace>;\n            }}\n        </Data>\n    </View>\n</View>;\n```\n"],"names":["useForceUpdate","setUpdateState","React.useState","React.useCallback","FetchPolicy","cache","ScopedInMemoryCache","useSharedCache","id","scope","initialValue","DataError","DataErrors","cacheValue","value","currentValue","loadingStatus","abortedStatus","Status","data","error","resultFromCachedResponse","cacheEntry","useRequestInterception","requestId","handler","interceptors","React.useContext","InterceptContext","prev","interceptor","useServerEffect","options","hydrate","skip","interceptedHandler","cachedResult","SsrCache","maybeTrack","useContext","TrackerContext","Server","DefaultScope","useCachedEffect","fetchPolicy","hardSkip","retainResultOnChange","onResultChanged","mostRecentResult","setMostRecentResult","forceUpdate","networkResultRef","React.useRef","currentRequestRef","fetchRequest","React.useMemo","_a","request","RequestFulfillment","_b","cancel","result","shouldFetch","React.useEffect","lastResultAgnosticOfIdRef","loadingResult","WhenClientSide","useHydratableEffect","clientBehavior","serverResult","getDefaultCacheValue","clientResult","Data","children","_createMdxContent","props","_components","_provideComponents","_jsxs","_Fragment","_jsx","Meta","MDXContent","MDXLayout","__page","componentMeta","__namedExportsOrder"],"mappings":"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"}