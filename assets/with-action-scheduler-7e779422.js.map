{"version":3,"file":"with-action-scheduler-7e779422.js","sources":["../../packages/wonder-blocks-timing/src/util/policies.ts","../../packages/wonder-blocks-timing/src/util/timeout.ts","../../packages/wonder-blocks-timing/src/util/interval.ts","../../packages/wonder-blocks-timing/src/util/animation-frame.ts","../../packages/wonder-blocks-timing/src/util/action-scheduler.ts","../../packages/wonder-blocks-timing/src/components/action-scheduler-provider.ts","../../packages/wonder-blocks-timing/src/components/with-action-scheduler.tsx"],"sourcesContent":["export const SchedulePolicy = {\n    Immediately: \"schedule-immediately\",\n    OnDemand: \"schedule-on-demand\",\n} as const;\n\nexport const ClearPolicy = {\n    Resolve: \"resolve-on-clear\",\n    Cancel: \"cancel-on-clear\",\n} as const;\n","import {\n    SchedulePolicy as SchedulePolicies,\n    ClearPolicy as ClearPolicies,\n} from \"./policies\";\n\nimport type {ITimeout, SchedulePolicy, ClearPolicy} from \"./types\";\n\n/**\n * Encapsulates everything associated with calling setTimeout/clearTimeout, and\n * managing the lifecycle of that timer, including the ability to resolve or\n * cancel a pending timeout action.\n *\n * @export\n * @class Timeout\n * @implements {ITimeout}\n */\nexport default class Timeout implements ITimeout {\n    _timeoutId: number | null | undefined;\n    _action: () => unknown;\n    _timeoutMs: number;\n\n    /**\n     * Creates a timeout that will invoke the given action after\n     * the given period. The timeout does not start until set is called.\n     *\n     * @param {() => mixed} action The action to be invoked when the timeout\n     * period has passed.\n     * @param {number} timeoutMs The timeout period.\n     * @param {SchedulePolicy} [schedulePolicy] When SchedulePolicy.Immediately,\n     * the timer is set immediately on instantiation; otherwise, `set` must be\n     * called to set the timeout.\n     * Defaults to `SchedulePolicy.Immediately`.\n     * @memberof Timeout\n     */\n    constructor(\n        action: () => unknown,\n        timeoutMs: number,\n        schedulePolicy: SchedulePolicy = SchedulePolicies.Immediately,\n    ) {\n        if (typeof action !== \"function\") {\n            throw new Error(\"Action must be a function\");\n        }\n\n        if (timeoutMs < 0) {\n            throw new Error(\"Timeout period must be >= 0\");\n        }\n\n        this._action = action;\n        this._timeoutMs = timeoutMs;\n\n        if (schedulePolicy === SchedulePolicies.Immediately) {\n            this.set();\n        }\n    }\n\n    /**\n     * Determine if the timeout is set or not.\n     *\n     * @returns {boolean} true if the timeout is set (aka pending), otherwise\n     * false.\n     * @memberof Timeout\n     */\n    get isSet(): boolean {\n        return this._timeoutId != null;\n    }\n\n    /**\n     * Set the timeout.\n     *\n     * If the timeout is pending, this cancels that pending timeout and\n     * sets the timeout afresh. If the timeout is not pending, this\n     * sets a new timeout.\n     *\n     * @memberof Timeout\n     */\n    set(): void {\n        if (this.isSet) {\n            this.clear(ClearPolicies.Cancel);\n        }\n        // @ts-expect-error [FEI-5019] - TS2322 - Type 'Timeout' is not assignable to type 'number'.\n        this._timeoutId = setTimeout(\n            () => this.clear(ClearPolicies.Resolve),\n            this._timeoutMs,\n        );\n    }\n\n    /**\n     * Clear the set timeout.\n     *\n     * If the timeout is pending, this cancels that pending timeout without\n     * invoking the action. If no timeout is pending, this does nothing.\n     *\n     * @param {ClearPolicy} [policy] When ClearPolicy.Resolve, if the request\n     * was set when called, the request action is invoked after cancelling\n     * the request; otherwise, the pending action is cancelled.\n     * Defaults to `ClearPolicy.Cancel`.\n     *\n     * @returns {void}\n     * @memberof Timeout\n     */\n    clear(policy: ClearPolicy = ClearPolicies.Cancel): void {\n        const timeoutId = this._timeoutId;\n        this._timeoutId = null;\n        if (timeoutId == null) {\n            return;\n        }\n        clearTimeout(timeoutId);\n        if (policy === ClearPolicies.Resolve) {\n            this._action();\n        }\n    }\n}\n","import {\n    SchedulePolicy as SchedulePolicies,\n    ClearPolicy as ClearPolicies,\n} from \"./policies\";\n\nimport type {IInterval, SchedulePolicy, ClearPolicy} from \"./types\";\n\n/**\n * Encapsulates everything associated with calling setInterval/clearInterval,\n * and managing the lifecycle of that interval. This includes the ability to\n * cancel the interval, and knowing if the interval is active.\n *\n * @export\n * @class Interval\n * @implements {IInterval}\n */\nexport default class Interval implements IInterval {\n    _intervalId: number | null | undefined;\n    _action: () => unknown;\n    _intervalMs: number;\n\n    /**\n     * Creates an interval that will invoke the given action after\n     * the given period. The interval does not start until set is called.\n     *\n     * @param {() => mixed} action The action to be invoked each time the\n     * interval period has passed.\n     * @param {number} intervalMs The interval period.\n     * @param {SchedulePolicy} [schedulePolicy] When SchedulePolicy.Immediately,\n     * the interval is set immediately on instantiation; otherwise, `set` must be\n     * called to set the interval.\n     * Defaults to `SchedulePolicy.Immediately`.\n     * @memberof Interval\n     */\n    constructor(\n        action: () => unknown,\n        intervalMs: number,\n        schedulePolicy: SchedulePolicy = SchedulePolicies.Immediately,\n    ) {\n        if (typeof action !== \"function\") {\n            throw new Error(\"Action must be a function\");\n        }\n\n        if (intervalMs < 1) {\n            throw new Error(\"Interval period must be >= 1\");\n        }\n\n        this._action = action;\n        this._intervalMs = intervalMs;\n\n        if (schedulePolicy === SchedulePolicies.Immediately) {\n            this.set();\n        }\n    }\n\n    /**\n     * Determine if the interval is active or not.\n     *\n     * @returns {boolean} true if the interval is active, otherwise false.\n     * @memberof Interval\n     */\n    get isSet(): boolean {\n        return this._intervalId != null;\n    }\n\n    /**\n     * Activate the interval.\n     *\n     * If the interval is active, this cancels that interval and starts the\n     * interval afresh. If the interval is not active, this starts it.\n     *\n     * @memberof Interval\n     */\n    set(): void {\n        if (this.isSet) {\n            this.clear(ClearPolicies.Cancel);\n        }\n        // @ts-expect-error [FEI-5019] - TS2322 - Type 'Timer' is not assignable to type 'number'.\n        this._intervalId = setInterval(() => this._action(), this._intervalMs);\n    }\n\n    /**\n     * Clear the active interval.\n     *\n     * If the interval is active, this cancels that interval. If no interval is\n     * pending, this does nothing.\n     *\n     * @param {ClearPolicy} [policy] When ClearPolicy.Resolve, if the request\n     * was set when called, the request action is invoked after cancelling\n     * the request; otherwise, the pending action is cancelled.\n     * Defaults to `ClearPolicy.Cancel`.\n     *\n     * @returns {void}\n     * @memberof Interval\n     */\n    clear(policy: ClearPolicy = ClearPolicies.Cancel): void {\n        const intervalId = this._intervalId;\n        this._intervalId = null;\n        if (intervalId == null) {\n            return;\n        }\n        clearInterval(intervalId);\n        if (policy === ClearPolicies.Resolve) {\n            this._action();\n        }\n    }\n}\n","import {\n    SchedulePolicy as SchedulePolicies,\n    ClearPolicy as ClearPolicies,\n} from \"./policies\";\n\nimport type {IAnimationFrame, SchedulePolicy, ClearPolicy} from \"./types\";\n\n/**\n * Encapsulates everything associated with calling requestAnimationFrame/\n * cancelAnimationFrame, and managing the lifecycle of that request, including\n * the ability to resolve or cancel a pending request action.\n *\n * @export\n * @class AnimationFrame\n * @implements {IAnimationFrame}\n */\nexport default class AnimationFrame implements IAnimationFrame {\n    _animationFrameId: number | null | undefined;\n    _action: (time: DOMHighResTimeStamp) => unknown;\n\n    /**\n     * Creates an animation frame request that will invoke the given action.\n     * The request is not made until set is called.\n     *\n     * @param {(time: DOMHighResTimeStamp) => mixed} action The action to be invoked.\n     * @param {SchedulePolicy} [schedulePolicy] When SchedulePolicy.Immediately,\n     * the interval is set immediately on instantiation; otherwise, `set` must be\n     * called to set the interval.\n     * Defaults to `SchedulePolicy.Immediately`.\n     * @memberof AnimationFrame\n     */\n    constructor(\n        action: (time: DOMHighResTimeStamp) => unknown,\n        schedulePolicy: SchedulePolicy = SchedulePolicies.Immediately,\n    ) {\n        if (typeof action !== \"function\") {\n            throw new Error(\"Action must be a function\");\n        }\n\n        this._action = action;\n\n        if (schedulePolicy === SchedulePolicies.Immediately) {\n            this.set();\n        }\n    }\n\n    /**\n     * Determine if the request is pending or not.\n     *\n     * @returns {boolean} true if the request is pending, otherwise\n     * false.\n     * @memberof AnimationFrame\n     */\n    get isSet(): boolean {\n        return this._animationFrameId != null;\n    }\n\n    /**\n     * Make the animation frame request.\n     *\n     * If the request is pending, this cancels that pending request and\n     * makes the request afresh. If the request is not pending, this\n     * makes a new request.\n     *\n     * @memberof AnimationFrame\n     */\n    set(): void {\n        if (this.isSet) {\n            this.clear(ClearPolicies.Cancel);\n        }\n        this._animationFrameId = requestAnimationFrame((time) =>\n            this.clear(ClearPolicies.Resolve, time),\n        );\n    }\n\n    /**\n     * Clear the pending request.\n     *\n     * If the request is pending, this cancels that pending request without\n     * invoking the action. If no request is pending, this does nothing.\n     *\n     * @param {ClearPolicy} [policy] When ClearPolicy.Resolve, if the request\n     * was set when called, the request action is invoked after cancelling\n     * the request; otherwise, the pending action is cancelled.\n     * Defaults to `ClearPolicy.Cancel`.\n     * @param {DOMHighResTimeStamp} [time] Timestamp to pass to the action when\n     * ClearPolicy.Resolve is specified. Ignored when ClearPolicy.Cancel is\n     * specified.\n     *\n     * @returns {void}\n     * @memberof AnimationFrame\n     */\n    clear(\n        policy: ClearPolicy = ClearPolicies.Cancel,\n        time?: DOMHighResTimeStamp,\n    ): void {\n        const animationFrameId = this._animationFrameId;\n        this._animationFrameId = null;\n        if (animationFrameId == null) {\n            return;\n        }\n        cancelAnimationFrame(animationFrameId);\n        if (policy === ClearPolicies.Resolve) {\n            this._action(time || performance.now());\n        }\n    }\n}\n","import Timeout from \"./timeout\";\nimport Interval from \"./interval\";\nimport AnimationFrame from \"./animation-frame\";\n\nimport type {\n    IAnimationFrame,\n    IInterval,\n    ITimeout,\n    IScheduleActions,\n    Options,\n} from \"./types\";\n\n/**\n * Implements the `IScheduleActions` API to provide timeout, interval, and\n * animation frame support. This is not intended for direct use, but instead\n * is to be used solely by the `ActionSchedulerProvider` to provide an\n * `IScheduleActions` instance.\n */\nexport default class ActionScheduler implements IScheduleActions {\n    _disabled = false;\n    _registeredActions: Array<() => void> = [];\n    static readonly NoopAction: ITimeout & IAnimationFrame & IInterval = {\n        set: () => {},\n        get isSet() {\n            return false;\n        },\n        clear: () => {},\n    };\n\n    timeout(\n        action: () => unknown,\n        period: number,\n        options?: Options,\n    ): ITimeout {\n        if (this._disabled) {\n            return ActionScheduler.NoopAction;\n        }\n        const timeout = new Timeout(action, period, options?.schedulePolicy);\n        this._registeredActions.push(() => timeout.clear(options?.clearPolicy));\n        return timeout;\n    }\n\n    interval(\n        action: () => unknown,\n        period: number,\n        options?: Options,\n    ): IInterval {\n        if (this._disabled) {\n            return ActionScheduler.NoopAction;\n        }\n        const interval = new Interval(action, period, options?.schedulePolicy);\n        this._registeredActions.push(() =>\n            interval.clear(options?.clearPolicy),\n        );\n        return interval;\n    }\n\n    animationFrame(\n        action: (arg1: DOMHighResTimeStamp) => void,\n        options?: Options,\n    ): IAnimationFrame {\n        if (this._disabled) {\n            return ActionScheduler.NoopAction;\n        }\n        const animationFrame = new AnimationFrame(\n            action,\n            options?.schedulePolicy,\n        );\n        this._registeredActions.push(() =>\n            animationFrame.clear(options?.clearPolicy),\n        );\n        return animationFrame;\n    }\n\n    clearAll(): void {\n        const registered = [...this._registeredActions];\n        this._registeredActions = [];\n        registered.forEach((clearFn) => clearFn());\n    }\n\n    /**\n     * Prevents this scheduler from creating any additional actions.\n     * This also clears any pending actions.\n     */\n    disable(): void {\n        this._disabled = true;\n        this.clearAll();\n    }\n}\n","import * as React from \"react\";\nimport ActionScheduler from \"../util/action-scheduler\";\n\nimport type {IScheduleActions} from \"../util/types\";\n\ntype Props = {\n    /**\n     * A function that, when given an instance of `IScheduleActions` will\n     * render a `React.Node`.\n     */\n    children: (arg1: IScheduleActions) => React.ReactNode;\n};\n\n/**\n * A provider component that passes our action scheduling API to its children\n * and ensures that all scheduled actions are cleared on unmount.\n *\n * ```jsx\n * <ActionSchedulerProvider>\n *     {schedule => this.renderThingThatNeedsTimers(schedule)}\n * </ActionSchedulerProvider>\n * ```\n */\nexport default class ActionSchedulerProvider extends React.Component<Props> {\n    componentWillUnmount() {\n        this._actionScheduler.disable();\n    }\n\n    _actionScheduler: ActionScheduler = new ActionScheduler();\n\n    render(): React.ReactNode {\n        const {children} = this.props;\n        return children(this._actionScheduler);\n    }\n}\n","import * as React from \"react\";\n\nimport ActionSchedulerProvider from \"./action-scheduler-provider\";\n\nimport type {IScheduleActions, WithActionSchedulerProps} from \"../util/types\";\n\ntype WithoutActionScheduler<T> = Omit<T, \"schedule\">;\n\n/**\n * A higher order component that attaches the given component to an\n * `IScheduleActions` instance. Any actions scheduled will automatically be\n * cleared on unmount.\n *\n * @template TOwnProps The own props of the component being rendered, without\n * the additional action scheduler prop. To attach the additional prop to\n * these props use the `WithActionScheduler` type.\n */\nexport default function withActionScheduler<\n    Props extends WithActionSchedulerProps,\n>(WrappedComponent: React.ComponentType<Props>) {\n    return (props: WithoutActionScheduler<Props>) => (\n        <ActionSchedulerProvider>\n            {(schedule: IScheduleActions) => (\n                <WrappedComponent {...(props as Props)} schedule={schedule} />\n            )}\n        </ActionSchedulerProvider>\n    );\n}\n"],"names":["SchedulePolicy","ClearPolicy","Timeout","action","timeoutMs","schedulePolicy","SchedulePolicies","ClearPolicies","policy","timeoutId","Interval","intervalMs","intervalId","AnimationFrame","time","animationFrameId","_ActionScheduler","period","options","timeout","interval","animationFrame","registered","clearFn","ActionScheduler","ActionSchedulerProvider","React.Component","children","withActionScheduler","WrappedComponent","props","jsx","schedule"],"mappings":"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"}