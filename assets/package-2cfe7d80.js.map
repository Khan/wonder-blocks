{"version":3,"file":"package-2cfe7d80.js","sources":["../../packages/wonder-blocks-popover/src/components/popover-context.ts","../../packages/wonder-blocks-popover/src/components/popover-anchor.ts","../../packages/wonder-blocks-popover/src/components/popover-dialog.tsx","../../packages/wonder-blocks-popover/src/util/util.ts","../../packages/wonder-blocks-popover/src/components/initial-focus.ts","../../packages/wonder-blocks-popover/src/components/focus-manager.tsx","../../packages/wonder-blocks-popover/src/components/popover-event-listener.ts","../../packages/wonder-blocks-popover/src/components/popover.tsx","../../packages/wonder-blocks-popover/src/components/close-button.tsx","../../packages/wonder-blocks-popover/src/components/popover-content-core.tsx","../../packages/wonder-blocks-popover/src/components/popover-content.tsx"],"sourcesContent":["import * as React from \"react\";\n\nimport type {Placement} from \"@khanacademy/wonder-blocks-tooltip\";\n\nexport type PopoverContextType = {\n    /**\n     * Facilitates passing the `onClose` handler from the Popover down to its\n     * children.\n     */\n    close?: () => unknown;\n    /**\n     * Facilitates passing this value from Popover (via TooltipPopper) down to\n     * PopoverContent. This is needed here to reposition the illustration to the\n     * start or the end of the content, in case the popper changes its\n     * placement.\n     */\n    placement?: Placement;\n};\n\nconst defaultContext: PopoverContextType = {\n    close: undefined,\n    placement: \"top\",\n};\n\n/**\n * This context is being used for two reasons:\n *\n * 1. Pass down the `close` method from the `Popover` component to its children\n *    (`PopoverContent` and `CloseButton`). This way, these components can use\n *    this handler internally.\n *\n * 2. Keeps a reference of the TooltipPopper's `placement` value. It can be one\n *    of the following values: \"top\", \"bottom\", \"left\" or \"right\".\n */\nconst PopoverContext = React.createContext<PopoverContextType>(\n    defaultContext,\n) as React.Context<PopoverContextType>;\nPopoverContext.displayName = \"PopoverContext\";\n\nexport default PopoverContext;\n","import * as React from \"react\";\nimport * as ReactDOM from \"react-dom\";\n\nimport type {AriaProps} from \"@khanacademy/wonder-blocks-core\";\n\ntype Props = AriaProps & {\n    /**\n     * Callback to be invoked when the anchored content is mounted.\n     * This provides a reference to the anchored content, which can then be\n     * used for calculating popover content positioning.\n     */\n    anchorRef: (arg1?: HTMLElement) => unknown;\n    /**\n     * The element that triggers the popover. This element will be used to\n     * position the popover. It can be either a Node or a function using the\n     * children-as-function pattern to pass an open function for use anywhere\n     * within children. The latter provides a lot of flexibility in terms of\n     * what actions may trigger the `Popover` to launch the\n     * [PopoverDialog](#PopoverDialog).\n     */\n    children:\n        | React.ReactElement<any>\n        | ((arg1: {open: () => void}) => React.ReactElement<any>);\n    /**\n     * The unique identifier to give to the anchor.\n     */\n    id?: string;\n    /**\n     * Called when the anchor is clicked\n     */\n    onClick: () => void;\n};\n\n/**\n * The element that triggers the popover dialog. This is also used as reference\n * to position the dialog itself.\n */\nexport default class PopoverAnchor extends React.Component<Props> {\n    componentDidMount() {\n        const anchorNode = ReactDOM.findDOMNode(this) as HTMLElement;\n\n        if (anchorNode) {\n            this.props.anchorRef(anchorNode);\n        }\n    }\n\n    render(): React.ReactNode {\n        const {\n            children,\n            id,\n            onClick,\n            \"aria-controls\": ariaControls,\n            \"aria-expanded\": ariaExpanded,\n        } = this.props;\n\n        // props that will be injected to both children versions\n        const sharedProps = {\n            id: id,\n            \"aria-controls\": ariaControls,\n            \"aria-expanded\": ariaExpanded,\n        } as const;\n\n        if (typeof children === \"function\") {\n            const renderedChildren = children({\n                open: onClick,\n            });\n\n            // we clone it to allow injecting the sharedProps defined before\n            return React.cloneElement(renderedChildren, sharedProps);\n        } else {\n            // add onClick handler to automatically open the dialog after\n            // clicking on this anchor element\n            // @ts-expect-error [FEI-5019] - TS2769 - No overload matches this call.\n            return React.cloneElement(children, {\n                // @ts-expect-error [FEI-5019] - TS2339 - Property 'props' does not exist on type 'ReactElement<any, string | JSXElementConstructor<any>> | (ReactElement<any, string | JSXElementConstructor<any>> & string) | ... 9 more ... | (((arg1: { ...; }) => ReactElement<...>) & true)'.\n                ...children.props,\n                ...sharedProps,\n                // @ts-expect-error [FEI-5019] - TS2339 - Property 'props' does not exist on type 'ReactElement<any, string | JSXElementConstructor<any>> | (ReactElement<any, string | JSXElementConstructor<any>> & string) | ... 9 more ... | (((arg1: { ...; }) => ReactElement<...>) & true)'.\n                onClick: children.props.onClick\n                    ? // @ts-expect-error [FEI-5019] - TS7006 - Parameter 'e' implicitly has an 'any' type.\n                      (e) => {\n                          e.stopPropagation();\n                          // This is done to avoid overriding a custom onClick\n                          // handler inside the children node\n                          // @ts-expect-error [FEI-5019] - TS2339 - Property 'props' does not exist on type 'ReactElement<any, string | JSXElementConstructor<any>> | (ReactElement<any, string | JSXElementConstructor<any>> & string) | ... 9 more ... | (((arg1: { ...; }) => ReactElement<...>) & true)'.\n                          children.props.onClick();\n                          onClick();\n                      }\n                    : onClick,\n            });\n        }\n    }\n}\n","import * as React from \"react\";\nimport {StyleSheet} from \"aphrodite\";\n\nimport {View} from \"@khanacademy/wonder-blocks-core\";\nimport {TooltipTail} from \"@khanacademy/wonder-blocks-tooltip\";\nimport Color from \"@khanacademy/wonder-blocks-color\";\n\nimport type {AriaProps} from \"@khanacademy/wonder-blocks-core\";\nimport type {\n    Placement,\n    PopperElementProps,\n} from \"@khanacademy/wonder-blocks-tooltip\";\n\nimport PopoverContent from \"./popover-content\";\nimport PopoverContentCore from \"./popover-content-core\";\n\ntype Props = AriaProps &\n    /**\n     * Required to correctly position the elements inside the dialog\n     * @ignore\n     */ PopperElementProps & {\n        /**\n         * The content to render inside the dialog.\n         */\n        children:\n            | React.ReactElement<React.ComponentProps<typeof PopoverContent>>\n            | React.ReactElement<\n                  React.ComponentProps<typeof PopoverContentCore>\n              >;\n        /**\n         * The unique identifier to give to the popover content.\n         */\n        id?: string;\n        /**\n         * Called when popper changes its placement\n         */\n        onUpdate: (placement: Placement) => unknown;\n        /**\n         * Whether to show the popover tail or not.\n         */\n        showTail: boolean;\n    };\n\n/**\n * This is an internal component that we use to render the stuff that appears\n * when a popover shows. It's composed by two elements: The popover content,\n * that can be of type [PopoverContent](#PopoverContent) or\n * [PopoverContentCore](#PopoverContentCore), and the\n * [TooltipTail](#TooltipTail).\n *\n * The main difference with [TooltipBubble](#TooltipBubble) is that bubble\n * handles hover states and PopoverDialog doesn't need to handle any states at\n * all (for now). Also, PopoverDialog needs to coordinate different background\n * colors for the content and tail components.\n *\n * Note that without explicit positioning, the tail will not be centered.\n */\nexport default class PopoverDialog extends React.Component<Props> {\n    componentDidUpdate(prevProps: Props) {\n        // if the placement has changed, then we need to notify this to the\n        // parent component (`Popover`). This way, the context will update its\n        // `placement` value.\n        if (prevProps.placement !== this.props.placement) {\n            this.props.onUpdate(this.props.placement);\n        }\n    }\n\n    render(): React.ReactNode {\n        const {\n            placement,\n            children,\n            id,\n            isReferenceHidden,\n            updateBubbleRef,\n            updateTailRef,\n            tailOffset,\n            style,\n            showTail,\n            \"aria-describedby\": ariaDescribedby,\n        } = this.props;\n\n        const contentProps = children.props as any;\n\n        // extract the background color from the popover content\n        const color: keyof typeof Color = contentProps.emphasized\n            ? \"blue\"\n            : contentProps.color;\n\n        return (\n            <React.Fragment>\n                <View\n                    aria-describedby={ariaDescribedby}\n                    id={id}\n                    role=\"dialog\"\n                    ref={updateBubbleRef}\n                    data-placement={placement}\n                    style={[\n                        isReferenceHidden && styles.hide,\n                        styles[`content-${placement}`],\n                        style,\n                    ]}\n                >\n                    {children}\n                    <TooltipTail\n                        show={showTail}\n                        color={color}\n                        updateRef={updateTailRef}\n                        placement={placement}\n                        offset={tailOffset}\n                    />\n                </View>\n            </React.Fragment>\n        );\n    }\n}\n\nconst styles = StyleSheet.create({\n    /**\n     * The hide style ensures that the bounds of the popover stay unchanged.\n     * This is because popper.js calculates the bubble position based off its\n     * bounds and if we stopped rendering it entirely, it wouldn't know where to\n     * place it when it reappeared.\n     */\n    hide: {\n        pointerEvents: \"none\",\n        opacity: 0,\n        backgroundColor: \"transparent\",\n        color: \"transparent\",\n    },\n\n    /**\n     * Ensure the content and tail are properly arranged.\n     */\n    \"content-top\": {\n        flexDirection: \"column\",\n    },\n    \"content-right\": {\n        flexDirection: \"row-reverse\",\n    },\n    \"content-bottom\": {\n        flexDirection: \"column-reverse\",\n    },\n    \"content-left\": {\n        flexDirection: \"row\",\n    },\n});\n","/**\n * List of elements that can be focused\n * @see https://www.w3.org/TR/html5/editing.html#can-be-focused\n */\nconst FOCUSABLE_ELEMENTS =\n    'button, [href], input, select, textarea, [tabindex]:not([tabindex=\"-1\"])';\n\nexport function findFocusableNodes(\n    root: HTMLElement | Document,\n): Array<HTMLElement> {\n    return Array.from(root.querySelectorAll(FOCUSABLE_ELEMENTS));\n}\n","import * as React from \"react\";\nimport * as ReactDOM from \"react-dom\";\n\nimport {findFocusableNodes} from \"../util/util\";\n\ntype Props = {\n    /**\n     * The container to apply the initial focus\n     */\n    children: React.ReactElement<any>;\n    /**\n     * The selector for the element that will be focused when the component shows.\n     * When not set, the first tabbable element within the component will be used.\n     */\n    initialFocusId?: string;\n};\n\n/**\n * This component finds which element (from within the children) needs to\n * receive focus. After that, the children is rendered with the focus assigned.\n */\nexport default class InitialFocus extends React.Component<Props> {\n    componentDidMount() {\n        const node: HTMLElement = ReactDOM.findDOMNode(this) as any;\n\n        if (!node) {\n            return;\n        }\n        // try to focus on the first focussable element\n        this.setInitialFocusableElement(node);\n    }\n\n    /**\n     * Gets the focusable element and applies focus to it\n     */\n    setInitialFocusableElement: (node: HTMLElement) => void = (node) => {\n        // 1. try to get element specified by the user\n        // 2. get first occurence from list of focusable elements\n        // 3. If no focusable elements are found, get the container itself\n        const firstFocusableElement =\n            this.maybeGetInitialFocusElement(node) ||\n            this.maybeGetFirstFocusableElement(node) ||\n            node;\n\n        if (firstFocusableElement === node) {\n            // add tabIndex to make the container focusable\n            node.tabIndex = -1;\n        }\n\n        // using timeout to prevent page jumps when focusing on this element\n        setTimeout(() => {\n            firstFocusableElement.focus();\n        }, 0);\n    };\n\n    /**\n     * Returns an element specified by the user\n     */\n    maybeGetInitialFocusElement(node: HTMLElement): HTMLElement | null {\n        const {initialFocusId} = this.props;\n\n        if (!initialFocusId) {\n            return null;\n        }\n\n        return node.querySelector(`#${initialFocusId}`);\n    }\n\n    /**\n     * Returns the first focusable element found inside the children\n     */\n    maybeGetFirstFocusableElement(node: HTMLElement): HTMLElement | null {\n        // get a collection of elements that can be focused\n        const focusableElements = findFocusableNodes(node);\n\n        if (!focusableElements.length) {\n            return null;\n        }\n\n        // if found, return the first focusable element\n        return focusableElements[0];\n    }\n\n    render(): React.ReactNode {\n        return this.props.children;\n    }\n}\n","import * as React from \"react\";\nimport * as ReactDOM from \"react-dom\";\nimport {findFocusableNodes} from \"../util/util\";\nimport InitialFocus from \"./initial-focus\";\n\ntype Props = {\n    /**\n     * The popover content container\n     */\n    children: React.ReactElement<any>;\n    /**\n     * A reference to the trigger element\n     */\n    anchorElement: HTMLElement | null | undefined;\n    /**\n     * The selector for the element that will be focused when the dialog shows.\n     * When not set, the first tabbable element within the dialog will be used.\n     */\n    initialFocusId?: string;\n};\n\n/**\n * This component ensures that focus flows correctly when the popover is open.\n *\n * Inside the popover:\n * - `tab`: Moves focus to the next focusable element.\n * - `shift + tab`: Moves focus to the previous focusable element.\n *\n * After the focus reaches the start/end of the popover,  then we handle two\n * different scenarios:\n *\n * 1. If the focus has reached the last focusable element inside the popover,\n *    the next tab will set focus on the next focusable element that exists\n *    after the PopoverAnchor.\n * 2. If the focus is set to the first focusable element inside the popover, the\n *    next shift + tab will set focus on the PopoverAnchor element.\n *\n */\nexport default class FocusManager extends React.Component<Props> {\n    /**\n     * The focusable element that is positioned after the trigger element\n     */\n    nextElementAfterPopover: HTMLElement | null | undefined;\n\n    /**\n     * Tabbing is restricted to descendents of this element.\n     */\n    rootNode: HTMLElement | null | undefined;\n\n    componentDidMount() {\n        this.addEventListeners();\n    }\n\n    componentDidUpdate() {\n        this.addEventListeners();\n    }\n\n    /**\n     * Remove keydown listeners\n     */\n    componentWillUnmount() {\n        const {anchorElement} = this.props;\n\n        if (anchorElement) {\n            // wait for styles to applied, then return the focus to the anchor\n            setTimeout(() => anchorElement.focus(), 0);\n\n            anchorElement.removeEventListener(\n                \"keydown\",\n                this.handleKeydownPreviousFocusableElement,\n                true,\n            );\n        }\n\n        if (this.nextElementAfterPopover) {\n            this.nextElementAfterPopover.removeEventListener(\n                \"keydown\",\n                this.handleKeydownNextFocusableElement,\n                true,\n            );\n        }\n    }\n\n    /**\n     * List of focusable elements within the popover content\n     */\n    focusableElementsInPopover: Array<HTMLElement> = [];\n\n    /**\n     * Add keydown listeners\n     */\n    addEventListeners: () => void = () => {\n        const {anchorElement} = this.props;\n\n        if (anchorElement) {\n            anchorElement.addEventListener(\n                \"keydown\",\n                this.handleKeydownPreviousFocusableElement,\n                true,\n            );\n        }\n\n        // tries to get the next focusable element outside of the popover\n        this.nextElementAfterPopover = this.getNextFocusableElement();\n\n        if (this.nextElementAfterPopover) {\n            this.nextElementAfterPopover.addEventListener(\n                \"keydown\",\n                this.handleKeydownNextFocusableElement,\n                true,\n            );\n        }\n    };\n\n    /**\n     * Gets the next focusable element after the anchor element\n     */\n    getNextFocusableElement: () => HTMLElement | null | undefined = () => {\n        const {anchorElement} = this.props;\n\n        if (!anchorElement) {\n            return;\n        }\n\n        // get the total list of focusable elements within the document\n        const focusableElements = findFocusableNodes(document);\n\n        // get anchor element index\n        const anchorIndex = focusableElements.indexOf(anchorElement);\n\n        if (anchorIndex >= 0) {\n            // guess next focusable element index\n            const nextElementIndex =\n                anchorIndex < focusableElements.length - 1\n                    ? anchorIndex + 1\n                    : 0;\n\n            // get next element's DOM reference\n            return focusableElements[nextElementIndex];\n        }\n\n        return;\n    };\n\n    /**\n     * Gets the list of focusable elements inside the popover\n     */\n    // @ts-expect-error [FEI-5019] - TS2322 - Type '(node: any) => void' is not assignable to type '() => void'.\n    getComponentRootNode: () => void = (node: any) => {\n        if (!node) {\n            // The component is being umounted\n            return;\n        }\n\n        const rootNode: HTMLElement = ReactDOM.findDOMNode(node) as any;\n\n        if (!rootNode) {\n            throw new Error(\n                \"Assertion error: root node should exist after mount\",\n            );\n        }\n\n        this.rootNode = rootNode as HTMLElement;\n\n        // store the list of possible focusable elements inside the popover\n        this.focusableElementsInPopover = findFocusableNodes(this.rootNode);\n    };\n\n    /**\n     * Triggered when the focus is set to the first sentinel. This way, the\n     * focus will be redirected to the anchor element.\n     */\n    handleFocusPreviousFocusableElement: () => void = () => {\n        if (this.props.anchorElement) {\n            this.props.anchorElement.focus();\n        }\n    };\n\n    /**\n     * Triggered when the focus is set to the last sentinel. This way, the focus\n     * will be redirected to next element after the anchor element.\n     */\n    handleFocusNextFocusableElement: () => void = () => {\n        if (this.nextElementAfterPopover) {\n            this.nextElementAfterPopover.focus();\n        }\n    };\n\n    /**\n     * Triggered when the focus is leaving the previous focusable element. This\n     * way, the focus is redirected to the first focusable element inside the\n     * popover.\n     */\n    handleKeydownPreviousFocusableElement: (e: KeyboardEvent) => void = (e) => {\n        // It will try focus only if the user is pressing `tab`\n        if (e.key === \"Tab\" && !e.shiftKey) {\n            e.preventDefault();\n            this.focusableElementsInPopover[0].focus();\n        }\n    };\n\n    /**\n     * Triggered when the focus is leaving the next focusable element. This way,\n     * the focus is redirected to the last focusable element inside the popover.\n     */\n    handleKeydownNextFocusableElement: (e: KeyboardEvent) => void = (e) => {\n        // It will try focus only if the user is pressing `Shift+tab`\n        if (e.key === \"Tab\" && e.shiftKey) {\n            e.preventDefault();\n            const lastElementIndex = this.focusableElementsInPopover.length - 1;\n            this.focusableElementsInPopover[lastElementIndex].focus();\n        }\n    };\n\n    render(): React.ReactNode {\n        const {children} = this.props;\n\n        return (\n            <React.Fragment>\n                {/* First sentinel\n                 * We set the sentinels to be position: fixed to make sure\n                 * they're always in view, this prevents page scrolling when\n                 * tabbing. */}\n                <div\n                    tabIndex={0}\n                    onFocus={this.handleFocusPreviousFocusableElement}\n                    style={{position: \"fixed\"}}\n                />\n                <div ref={this.getComponentRootNode}>\n                    <InitialFocus initialFocusId={this.props.initialFocusId}>\n                        {children}\n                    </InitialFocus>\n                </div>\n                {/* last sentinel */}\n                <div\n                    tabIndex={0}\n                    onFocus={this.handleFocusNextFocusableElement}\n                    style={{position: \"fixed\"}}\n                />\n            </React.Fragment>\n        );\n    }\n}\n","import * as React from \"react\";\nimport * as ReactDOM from \"react-dom\";\n\nimport PopoverContent from \"./popover-content\";\nimport PopoverContentCore from \"./popover-content-core\";\n\ntype Props = {\n    /**\n     * Called when `esc` is pressed\n     */\n    onClose: () => unknown;\n    /**\n     * Popover Content ref.\n     * Will close the popover when clicking outside this element.\n     */\n    contentRef?: React.RefObject<PopoverContentCore | PopoverContent>;\n};\n\ntype State = {\n    /**\n     * Tracks the first click triggered by the click event listener.\n     */\n    isFirstClick: boolean;\n};\n\n/**\n * A component that, when mounted, calls `onClose` when certain events occur.\n * This includes when pressing Escape or clicking outside the Popover.\n * @see @khanacademy/wonder-blocks-modal/components/modal-launcher.js\n */\nexport default class PopoverEventListener extends React.Component<\n    Props,\n    State\n> {\n    state: State = {\n        isFirstClick: true,\n    };\n\n    componentDidMount() {\n        window.addEventListener(\"keyup\", this._handleKeyup);\n        window.addEventListener(\"click\", this._handleClick);\n    }\n\n    componentWillUnmount() {\n        window.removeEventListener(\"keyup\", this._handleKeyup);\n        window.removeEventListener(\"click\", this._handleClick);\n    }\n\n    _handleKeyup: (e: KeyboardEvent) => void = (e) => {\n        // We check the key as that's keyboard layout agnostic and also avoids\n        // the minefield of deprecated number type properties like keyCode and\n        // which, with the replacement code, which uses a string instead.\n        if (e.key === \"Escape\") {\n            // Stop the event going any further.\n            // For cancellation events, like the Escape key, we generally should\n            // air on the side of caution and only allow it to cancel one thing.\n            // So, it's polite for us to stop propagation of the event.\n            // Otherwise, we end up with UX where one Escape key press\n            // unexpectedly cancels multiple things.\n            e.preventDefault();\n            e.stopPropagation();\n            this.props.onClose();\n        }\n    };\n\n    _handleClick: (e: MouseEvent) => void = (e) => {\n        // Prevents the problem where clicking the trigger button\n        // triggers a click event and immediately closes the popover.\n        if (this.state.isFirstClick) {\n            this.setState({isFirstClick: false});\n            return;\n        }\n\n        const node = ReactDOM.findDOMNode(this.props.contentRef?.current);\n        if (node && !node.contains(e.target as any)) {\n            // Stop the event going any further.\n            // Only allow click to cancel one thing at a time.\n            e.preventDefault();\n            e.stopPropagation();\n            this.props.onClose();\n        }\n    };\n\n    render(): React.ReactElement | null {\n        return null;\n    }\n}\n","import * as React from \"react\";\nimport * as ReactDOM from \"react-dom\";\n\nimport {IDProvider} from \"@khanacademy/wonder-blocks-core\";\nimport {TooltipPopper} from \"@khanacademy/wonder-blocks-tooltip\";\nimport {maybeGetPortalMountedModalHostElement} from \"@khanacademy/wonder-blocks-modal\";\n\nimport type {AriaProps} from \"@khanacademy/wonder-blocks-core\";\nimport type {\n    Placement,\n    PopperElementProps,\n} from \"@khanacademy/wonder-blocks-tooltip\";\n\nimport PopoverContent from \"./popover-content\";\nimport PopoverContentCore from \"./popover-content-core\";\nimport PopoverContext from \"./popover-context\";\nimport PopoverAnchor from \"./popover-anchor\";\nimport PopoverDialog from \"./popover-dialog\";\nimport FocusManager from \"./focus-manager\";\nimport PopoverEventListener from \"./popover-event-listener\";\n\ntype PopoverContents =\n    | React.ReactElement<React.ComponentProps<typeof PopoverContent>>\n    | React.ReactElement<React.ComponentProps<typeof PopoverContentCore>>;\n\ntype Props = AriaProps &\n    Readonly<{\n        /**\n         * The element that triggers the popover. This element will be used to\n         * position the popover. It can be either a Node or a function using the\n         * children-as-function pattern to pass an open function for use anywhere\n         * within children. The latter provides a lot of flexibility in terms of\n         * what actions may trigger the `Popover` to launch the popover dialog.\n         */\n        children:\n            | React.ReactElement<any>\n            | ((arg1: {open: () => void}) => React.ReactElement<any>);\n        /**\n         * The content of the popover. You can either use\n         * [PopoverContent](#PopoverContent) with one of the pre-defined variants,\n         * or include your own custom content using\n         * [PopoverContentCore](#PopoverContentCore directly.\n         *\n         * If the popover needs to close itself, the close function provided to this\n         * callback can be called to close the popover.\n         */\n        content:\n            | PopoverContents\n            | ((arg1: {close: () => void}) => PopoverContents);\n        /**\n         * Where the popover should try to appear in relation to the trigger element.\n         */\n        placement: Placement;\n        /**\n         * When enabled, user can hide the popover content by pressing the `esc` key\n         * or clicking/tapping outside of it.\n         */\n        dismissEnabled?: boolean;\n        /**\n         * The unique identifier to give to the popover. Provide this in cases where\n         * you want to override the default accessibility solution. This identifier\n         * will be applied to the popover content.\n         *\n         * By providing this identifier, the children that this popover anchors to\n         * will not be automatically given the\n         * [aria-describedby](https://www.w3.org/TR/wai-aria-1.1/#aria-describedby)\n         * attribute. Instead, the accessibility solution is the responsibility of\n         * the caller.\n         *\n         * If this is not provided, the\n         * [aria-describedby](https://www.w3.org/TR/wai-aria-1.1/#aria-describedby)\n         * attribute will be added to the children with a unique identifier pointing\n         * to the popover dialog.\n         */\n        id?: string;\n        /**\n         * The selector for the element that will be focused when the popover\n         * content shows. When not set, the first focusable element within the\n         * popover content will be used.\n         */\n        initialFocusId?: string;\n        /**\n         * Renders the popover when true, renders nothing when false.\n         *\n         * Using this prop makes the component behave as a controlled component. The\n         * parent is responsible for managing the opening/closing of the popover\n         * when using this prop.\n         */\n        opened?: boolean;\n        /**\n         * Called when the popover closes\n         */\n        onClose?: () => unknown;\n        /**\n         * Test ID used for e2e testing.\n         */\n        testId?: string;\n        /**\n         * Whether to show the popover tail or not. Defaults to true.\n         */\n        showTail: boolean;\n    }>;\n\ntype State = Readonly<{\n    /**\n     * Keeps a reference of the dialog state\n     */\n    opened: boolean;\n    /**\n     * Anchor element DOM reference\n     */\n    anchorElement?: HTMLElement;\n    /**\n     * Current popper placement\n     */\n    placement: Placement;\n}>;\n\ntype DefaultProps = Readonly<{\n    placement: Props[\"placement\"];\n    showTail: Props[\"showTail\"];\n}>;\n\n/**\n * Popovers provide additional information that is related to a particular\n * element and/or content. They can include text, links, icons and\n * illustrations. The main difference with `Tooltip` is that they must be\n * dismissed by clicking an element.\n *\n * This component uses the `PopoverPopper` component to position the\n * `PopoverContentCore` component according to the children it is wrapping.\n *\n * ### Usage\n *\n * ```jsx\n * import {Popover, PopoverContent} from \"@khanacademy/wonder-blocks-popover\";\n *\n * <Popover\n *  onClose={() => {}}\n *  content={\n *      <PopoverContent title=\"Title\" content=\"Some content\" closeButtonVisible />\n *  }>\n *      {({ open }) => <Button onClick={open}>Open popover</Button>}\n *  </Popover>\n * ```\n */\nexport default class Popover extends React.Component<Props, State> {\n    static defaultProps: DefaultProps = {\n        placement: \"top\",\n        showTail: true,\n    };\n\n    /**\n     * Used to sync the `opened` state when Popover acts as a controlled\n     * component\n     */\n    static getDerivedStateFromProps(\n        props: Props,\n        state: State,\n    ): Partial<State> | null | undefined {\n        return {\n            opened:\n                typeof props.opened === \"boolean\" ? props.opened : state.opened,\n        };\n    }\n\n    state: State = {\n        opened: !!this.props.opened,\n        placement: this.props.placement,\n    };\n\n    /**\n     * Popover content ref\n     */\n    contentRef: React.RefObject<PopoverContent | PopoverContentCore> =\n        React.createRef();\n\n    /**\n     * Popover dialog closed\n     */\n    handleClose: () => void = () => {\n        this.setState({opened: false}, () => {\n            this.props.onClose?.();\n        });\n    };\n\n    /**\n     * Popover dialog opened\n     */\n    handleOpen: () => void = () => {\n        if (this.props.dismissEnabled && this.state.opened) {\n            this.setState({opened: false});\n        } else {\n            this.setState({opened: true});\n        }\n    };\n\n    updateRef = (actualRef?: HTMLElement) => {\n        if (actualRef && this.state.anchorElement !== actualRef) {\n            this.setState({\n                anchorElement: actualRef,\n            });\n        }\n    };\n\n    renderContent(): PopoverContents {\n        const {content} = this.props;\n\n        const popoverContents: PopoverContents =\n            typeof content === \"function\"\n                ? content({\n                      close: this.handleClose,\n                  })\n                : content;\n\n        // @ts-expect-error: TS2769 - No overload matches this call.\n        return React.cloneElement(popoverContents, {ref: this.contentRef});\n    }\n\n    renderPopper(uniqueId: string): React.ReactNode {\n        const {initialFocusId, placement, showTail} = this.props;\n        const {anchorElement} = this.state;\n\n        return (\n            <FocusManager\n                anchorElement={anchorElement}\n                initialFocusId={initialFocusId}\n            >\n                <TooltipPopper\n                    anchorElement={anchorElement}\n                    placement={placement}\n                >\n                    {(props: PopperElementProps) => (\n                        <PopoverDialog\n                            {...props}\n                            aria-describedby={`${uniqueId}-anchor`}\n                            id={uniqueId}\n                            onUpdate={(placement) => this.setState({placement})}\n                            showTail={showTail}\n                        >\n                            {this.renderContent()}\n                        </PopoverDialog>\n                    )}\n                </TooltipPopper>\n            </FocusManager>\n        );\n    }\n\n    getHost(): Element | null | undefined {\n        // If we are in a modal, we find where we should be portalling the\n        // popover by using the helper function from the modal package on the\n        // trigger element. If we are not in a modal, we use body as the\n        // location to portal to.\n        return (\n            maybeGetPortalMountedModalHostElement(this.state.anchorElement) ||\n            document.body\n        );\n    }\n\n    render(): React.ReactNode {\n        const {children, dismissEnabled, id} = this.props;\n        const {opened, placement} = this.state;\n        const popperHost = this.getHost();\n\n        return (\n            <PopoverContext.Provider\n                value={{\n                    close: this.handleClose,\n                    placement: placement,\n                }}\n            >\n                <IDProvider id={id} scope=\"popover\">\n                    {(uniqueId) => (\n                        <React.Fragment>\n                            <PopoverAnchor\n                                anchorRef={this.updateRef}\n                                id={`${uniqueId}-anchor`}\n                                aria-controls={uniqueId}\n                                aria-expanded={opened ? \"true\" : \"false\"}\n                                onClick={this.handleOpen}\n                            >\n                                {children}\n                            </PopoverAnchor>\n                            {popperHost &&\n                                opened &&\n                                ReactDOM.createPortal(\n                                    this.renderPopper(uniqueId),\n                                    popperHost,\n                                )}\n                        </React.Fragment>\n                    )}\n                </IDProvider>\n\n                {dismissEnabled && opened && (\n                    <PopoverEventListener\n                        onClose={this.handleClose}\n                        contentRef={this.contentRef}\n                    />\n                )}\n            </PopoverContext.Provider>\n        );\n    }\n}\n","import * as React from \"react\";\n\nimport type {AriaProps, StyleType} from \"@khanacademy/wonder-blocks-core\";\nimport {icons} from \"@khanacademy/wonder-blocks-icon\";\nimport IconButton from \"@khanacademy/wonder-blocks-icon-button\";\n\nimport PopoverContext from \"./popover-context\";\n\ntype Props = AriaProps & {\n    /**\n     * Whether to display the light version of this component instead, for use\n     * when the item is used on a dark background.\n     */\n    light?: boolean;\n    /**\n     * Custom styles applied to the IconButton\n     */\n    style?: StyleType;\n    /**\n     * Test ID used for e2e testing.\n     */\n    testId?: string;\n};\n\ntype DefaultProps = {\n    light: Props[\"light\"];\n    [\"aria-label\"]: Props[\"aria-label\"];\n};\n\n/**\n * This is the visual component rendering the close button that is rendered\n * inside the PopoverContentCore. It’s rendered if closeButtonVisible is set\n * true.\n */\nexport default class CloseButton extends React.Component<Props> {\n    static defaultProps: DefaultProps = {\n        light: true,\n        \"aria-label\": \"Close Popover\",\n    };\n\n    render(): React.ReactNode {\n        const {light, \"aria-label\": ariaLabel, style, testId} = this.props;\n        return (\n            <PopoverContext.Consumer>\n                {({close}) => {\n                    return (\n                        <IconButton\n                            icon={icons.dismiss}\n                            aria-label={ariaLabel}\n                            onClick={close}\n                            kind={light ? \"primary\" : \"tertiary\"}\n                            light={light}\n                            style={style}\n                            testId={testId}\n                        />\n                    );\n                }}\n            </PopoverContext.Consumer>\n        );\n    }\n}\n","import * as React from \"react\";\nimport {StyleSheet} from \"aphrodite\";\n\nimport type {AriaProps, StyleType} from \"@khanacademy/wonder-blocks-core\";\nimport Colors from \"@khanacademy/wonder-blocks-color\";\nimport {View} from \"@khanacademy/wonder-blocks-core\";\nimport Spacing from \"@khanacademy/wonder-blocks-spacing\";\n\nimport CloseButton from \"./close-button\";\n\ntype Props = AriaProps & {\n    /**\n     * The content to render inside the popover.\n     */\n    children: React.ReactNode;\n    /**\n     * Close button color\n     */\n    closeButtonLight?: boolean;\n    /**\n     * Close button label for use in screen readers\n     */\n    closeButtonLabel?: string;\n    /**\n     * When true, the close button is shown; otherwise, the close button is not shown.\n     */\n    closeButtonVisible?: boolean;\n    /**\n     * Whether we should use the default light color scheme or switch to a\n     * different color scheme.\n     */\n    color: \"blue\" | \"darkBlue\" | \"white\";\n    /**\n     * Custom styles applied to the content container\n     */\n    style?: StyleType;\n    /**\n     * Test ID used for e2e testing.\n     */\n    testId?: string;\n};\n\ntype DefaultProps = {\n    color: Props[\"color\"];\n    closeButtonLight: Props[\"closeButtonLight\"];\n    closeButtonVisible: Props[\"closeButtonVisible\"];\n};\n\n/**\n * This is the base popover container. It’s used internally by all the variants.\n * Also, it can be used to create flexible popovers.\n *\n * ### Usage\n *\n * ```jsx\n * import {PopoverContentCore} from \"@khanacademy/wonder-blocks-popover\";\n *\n * <PopoverContentCore>\n *  <>\n *      Some custom layout\n *  </>\n * </PopoverContentCore>\n * ```\n */\nexport default class PopoverContentCore extends React.Component<Props> {\n    static defaultProps: DefaultProps = {\n        color: \"white\",\n        closeButtonLight: false,\n        closeButtonVisible: false,\n    };\n\n    render(): React.ReactNode {\n        const {\n            children,\n            closeButtonLight,\n            closeButtonLabel,\n            closeButtonVisible,\n            color,\n            style,\n            testId,\n        } = this.props;\n\n        return (\n            <View\n                testId={testId}\n                style={[\n                    styles.content,\n                    color !== \"white\" && styles[color],\n                    style,\n                ]}\n            >\n                {closeButtonVisible && (\n                    <CloseButton\n                        aria-label={closeButtonLabel}\n                        light={closeButtonLight || color !== \"white\"}\n                        style={styles.closeButton}\n                        testId={`${testId || \"popover\"}-close-btn`}\n                    />\n                )}\n                {children}\n            </View>\n        );\n    }\n}\n\nconst styles = StyleSheet.create({\n    content: {\n        borderRadius: Spacing.xxxSmall_4,\n        border: `solid 1px ${Colors.offBlack16}`,\n        backgroundColor: Colors.white,\n        boxShadow: `0 ${Spacing.xSmall_8}px ${Spacing.xSmall_8}px 0 ${Colors.offBlack8}`,\n        margin: 0,\n        maxWidth: Spacing.medium_16 * 18, // 288px\n        padding: Spacing.large_24,\n        overflow: \"hidden\",\n        justifyContent: \"center\",\n    },\n    /**\n     * Theming\n     */\n    blue: {\n        backgroundColor: Colors.blue,\n        color: Colors.white,\n    },\n\n    darkBlue: {\n        backgroundColor: Colors.darkBlue,\n        color: Colors.white,\n    },\n\n    /**\n     * elements\n     */\n    closeButton: {\n        position: \"absolute\",\n        right: Spacing.xSmall_8,\n        top: Spacing.xSmall_8,\n        // Allows the button to be above the title and/or custom content\n        zIndex: 1,\n    },\n});\n","import * as React from \"react\";\nimport {StyleSheet} from \"aphrodite\";\n\nimport type {AriaProps, StyleType} from \"@khanacademy/wonder-blocks-core\";\nimport {addStyle, View} from \"@khanacademy/wonder-blocks-core\";\nimport Spacing from \"@khanacademy/wonder-blocks-spacing\";\nimport {Body, HeadingSmall} from \"@khanacademy/wonder-blocks-typography\";\n\nimport type {PopoverContextType} from \"./popover-context\";\n\nimport PopoverContentCore from \"./popover-content-core\";\nimport PopoverContext from \"./popover-context\";\n\n// TODO(FEI-5000): Convert back to conditional props after TS migration is complete.\ntype Props = AriaProps & {\n    /**\n     * The content to render inside the popover.\n     */\n    content: string;\n    /**\n     * The popover title\n     */\n    title: string;\n    /**\n     * User-defined actions.\n     *\n     * It can be either a Node or a function using the children-as-function\n     * pattern to pass a close function for use anywhere within the actions.\n     * This provides a lot of flexibility in terms of what actions may trigger\n     * the Popover to close the popover dialog.\n     */\n    actions?:\n        | React.ReactNode\n        | ((arg1: {close: () => unknown}) => React.ReactElement);\n    /**\n     * Close button label for use in screen readers\n     */\n    closeButtonLabel?: string;\n    /**\n     * When true, the close button is shown; otherwise, the close button is not shown.\n     */\n    closeButtonVisible?: boolean;\n    /**\n     * Custom styles to be injected to the popover content container\n     */\n    style?: StyleType;\n    /**\n     * Test ID used for e2e testing.\n     */\n    testId?: string;\n    /**\n     * Decorate the popover with an illustrated icon. It cannot be used at the\n     * same time with image.\n     */\n    icon?:\n        | string\n        | React.ReactElement<React.ComponentProps<\"img\">>\n        | React.ReactElement<React.ComponentProps<\"svg\">>;\n    /**\n     * Decorate the popover with a full-bleed illustration. It cannot be used at\n     * the same time with icon.\n     */\n    image?:\n        | React.ReactElement<React.ComponentProps<\"img\">>\n        | React.ReactElement<React.ComponentProps<\"svg\">>;\n    /**\n     * When true, changes the popover dialog background to blue; otherwise, the\n     * popover dialog background is not modified. It can be used only with\n     * Text-only popovers. It cannot be used with icon or image.\n     */\n    emphasized?: boolean;\n};\n\ntype DefaultProps = {\n    closeButtonVisible: Props[\"closeButtonVisible\"];\n};\n\n// Created to add custom styles to the icon or image elements\nconst StyledImage = addStyle(\"img\");\n\n/**\n * This is the container that is consumed by all the predefined variations. Its\n * main responsibility is populate the contents depending on the variation used.\n *\n * ### Usage\n *\n * ```jsx\n * import {PopoverContent} from \"@khanacademy/wonder-blocks-popover\";\n *\n * <PopoverContent\n *  closeButtonVisible\n *  content=\"Some content for the popover\"\n *  title=\"Popover with text only\"\n * />\n * ```\n */\nexport default class PopoverContent extends React.Component<Props> {\n    static defaultProps: DefaultProps = {\n        closeButtonVisible: false,\n    };\n\n    componentDidMount() {\n        const {icon, image} = this.props;\n\n        // this runtime check is added to support <svg> and <img> elements\n        // inside the image prop\n        if (image && icon) {\n            throw new Error(\n                \"'image' and 'icon' cannot be used at the same time. You can fix this by either removing 'image' or 'icon' from your instance.\",\n            );\n        }\n    }\n\n    /**\n     * Runtime validation in case we try to use an invalid shape\n     */\n    validateProps({placement}: PopoverContextType) {\n        // illustration popover can't be placed horizontally\n        if (\n            this.props.image &&\n            (placement === \"left\" || placement === \"right\")\n        ) {\n            throw new Error(\n                \"'image' can only be vertically placed. You can fix this by either changing `placement` to `top` or `bottom` or removing the `image` prop inside `content`.\",\n            );\n        }\n    }\n\n    // @ts-expect-error [FEI-5019] - TS2322 - Type '({ placement, }: PopoverContextType) => Element | null' is not assignable to type '(context: PopoverContextType) => ReactElement<any, string | JSXElementConstructor<any>>'.\n    maybeRenderImage: (context: PopoverContextType) => React.ReactElement = ({\n        placement,\n    }) => {\n        const {image} = this.props;\n\n        if (!image) {\n            return null;\n        }\n\n        return (\n            <View\n                style={[\n                    styles.image,\n                    placement === \"bottom\" && styles.imageToBottom,\n                ]}\n            >\n                {image}\n            </View>\n        );\n    };\n\n    // @ts-expect-error [FEI-5019] - TS2322 - Type '() => JSX.Element | null' is not assignable to type '() => ReactElement<any, string | JSXElementConstructor<any>>'.\n    maybeRenderIcon: () => React.ReactElement = () => {\n        const {icon} = this.props;\n\n        if (!icon) {\n            return null;\n        }\n\n        return (\n            <View style={styles.iconContainer}>\n                {typeof icon !== \"string\" ? (\n                    icon\n                ) : (\n                    <StyledImage src={icon} style={styles.icon} />\n                )}\n            </View>\n        );\n    };\n\n    // @ts-expect-error [FEI-5019] - TS2322 - Type '(close: () => unknown) => Element | null' is not assignable to type '(close: () => unknown) => ReactElement<any, string | JSXElementConstructor<any>>'.\n    maybeRenderActions: (close: () => unknown) => React.ReactElement = (\n        close,\n    ) => {\n        const {actions} = this.props;\n\n        if (!actions) {\n            return null;\n        }\n\n        return (\n            <View style={styles.actions}>\n                {typeof actions === \"function\"\n                    ? actions({\n                          close: close,\n                      })\n                    : actions}\n            </View>\n        );\n    };\n\n    render(): React.ReactNode {\n        const {\n            closeButtonLabel,\n            closeButtonVisible,\n            content,\n            emphasized = undefined,\n            icon,\n            image,\n            style,\n            title,\n            testId,\n        } = this.props;\n\n        return (\n            <PopoverContext.Consumer>\n                {({close, placement}) => {\n                    // verify if the props are correct\n                    this.validateProps({close, placement});\n\n                    return (\n                        <PopoverContentCore\n                            color={emphasized ? \"blue\" : \"white\"}\n                            closeButtonLight={image && placement === \"top\"}\n                            closeButtonLabel={closeButtonLabel}\n                            closeButtonVisible={closeButtonVisible}\n                            style={style}\n                            testId={testId}\n                        >\n                            <View style={!!icon && styles.withIcon}>\n                                {this.maybeRenderImage({placement})}\n\n                                {this.maybeRenderIcon()}\n\n                                <View style={styles.text}>\n                                    <HeadingSmall style={styles.title}>\n                                        {title}\n                                    </HeadingSmall>\n                                    <Body>{content}</Body>\n                                </View>\n                            </View>\n\n                            {this.maybeRenderActions(close as any)}\n                        </PopoverContentCore>\n                    );\n                }}\n            </PopoverContext.Consumer>\n        );\n    }\n}\n\nconst styles = StyleSheet.create({\n    /**\n     * Shared styles\n     */\n    actions: {\n        marginTop: Spacing.large_24,\n        flexDirection: \"row\",\n        alignItems: \"center\",\n        justifyContent: \"flex-end\",\n    },\n\n    text: {\n        justifyContent: \"center\",\n    },\n\n    title: {\n        marginBottom: Spacing.xSmall_8,\n    },\n\n    /**\n     * Icon styles\n     */\n    iconContainer: {\n        alignItems: \"center\",\n        justifyContent: \"center\",\n        height: Spacing.xxxLarge_64,\n        width: Spacing.xxxLarge_64,\n        minWidth: Spacing.xxxLarge_64,\n        marginRight: Spacing.medium_16,\n        overflow: \"hidden\",\n    },\n\n    icon: {\n        width: \"100%\",\n    },\n\n    withIcon: {\n        flexDirection: \"row\",\n    },\n\n    /**\n     * Illustration styles\n     */\n    image: {\n        marginBottom: Spacing.large_24,\n        marginLeft: -Spacing.large_24,\n        marginRight: -Spacing.large_24,\n        marginTop: -Spacing.large_24,\n        width: `calc(100% + ${Spacing.large_24 * 2}px)`,\n    },\n\n    imageToBottom: {\n        marginBottom: -Spacing.large_24,\n        marginTop: Spacing.large_24,\n        order: 1,\n    },\n});\n"],"names":["defaultContext","PopoverContext","React.createContext","PopoverContext$1","PopoverAnchor","React.Component","anchorNode","ReactDOM.findDOMNode","children","id","onClick","ariaControls","ariaExpanded","sharedProps","renderedChildren","React.cloneElement","e","PopoverDialog","prevProps","placement","isReferenceHidden","updateBubbleRef","updateTailRef","tailOffset","style","showTail","ariaDescribedby","contentProps","color","jsx","React.Fragment","jsxs","View","styles","TooltipTail","StyleSheet","FOCUSABLE_ELEMENTS","findFocusableNodes","root","InitialFocus","node","firstFocusableElement","initialFocusId","focusableElements","FocusManager","anchorElement","anchorIndex","nextElementIndex","rootNode","lastElementIndex","PopoverEventListener","_a","Popover","React.createRef","_b","actualRef","props","state","content","popoverContents","uniqueId","TooltipPopper","placement2","maybeGetPortalMountedModalHostElement","dismissEnabled","opened","popperHost","IDProvider","ReactDOM.createPortal","CloseButton","light","ariaLabel","testId","close","IconButton","icons.dismiss","PopoverContentCore","closeButtonLight","closeButtonLabel","closeButtonVisible","Spacing","Colors","StyledImage","addStyle","PopoverContent","image","icon","actions","emphasized","title","HeadingSmall","Body"],"mappings":"2kBAmBA,MAAMA,EAAqC,CACvC,MAAO,OACP,UAAW,KACf,EAYMC,EAAiBC,EAAM,cACzBF,CACJ,EACAC,EAAe,YAAc,iBAE7B,MAAAE,EAAeF,ECFM,MAAAG,UAAsBC,EAAAA,SAAuB,CAC9D,mBAAoB,CACV,MAAAC,EAAaC,cAAqB,IAAI,EAExCD,GACK,KAAA,MAAM,UAAUA,CAAU,CAEvC,CAEA,QAA0B,CAChB,KAAA,CACF,SAAAE,EACA,GAAAC,EACA,QAAAC,EACA,gBAAiBC,EACjB,gBAAiBC,CAAA,EACjB,KAAK,MAGHC,EAAc,CAChB,GAAAJ,EACA,gBAAiBE,EACjB,gBAAiBC,CAAA,EAGjB,GAAA,OAAOJ,GAAa,WAAY,CAChC,MAAMM,EAAmBN,EAAS,CAC9B,KAAME,CAAA,CACT,EAGM,OAAAK,EAAmB,aAAAD,EAAkBD,CAAW,CAAA,KAKhD,QAAAE,EAAAA,aAAmBP,EAAU,CAEhC,GAAGA,EAAS,MACZ,GAAGK,EAEH,QAASL,EAAS,MAAM,QAEjBQ,GAAM,CACHA,EAAE,gBAAgB,EAIlBR,EAAS,MAAM,UACPE,GACZ,EACAA,CAAA,CACT,CAET,CACJ,CCnCA,MAAAO,UAAAZ,EAAAA,SAAA,CAAkE,mBAAAa,EAAA,CAK1DA,EAAA,YAAA,KAAA,MAAA,WACI,KAAA,MAAA,SAAA,KAAA,MAAA,SAAA,CACJ,CACJ,QAAA,CAGI,KAAA,CAAM,UAAAC,EACF,SAAAX,EACA,GAAAC,EACA,kBAAAW,EACA,gBAAAC,EACA,cAAAC,EACA,WAAAC,EACA,MAAAC,EACA,SAAAC,EACA,mBAAAC,CACoB,EAAA,KAAA,MAGxBC,EAAAnB,EAAA,MAGAoB,EAAAD,EAAA,WAAA,OAAAA,EAAA,MAIA,OAAAE,EAAAC,EAAAA,SAAA,CAAA,SAAAC,EAEQC,EAAC,CAAA,mBAAAN,EACqB,GAAAjB,EAClB,KAAA,SACK,IAAAY,EACA,iBAAAF,EACW,MAAA,CACTC,GAAAa,EAAA,KACyBA,EAAA,WAAAd,CAAA,EAAA,EACCK,CAC7B,EACJ,SAAA,CAEChB,EAAAqB,EACDK,EAAC,CAAA,KAAAT,EACS,MAAAG,EACN,UAAAN,EACW,UAAAH,EACX,OAAAI,CACQ,CAAA,CACZ,CAAA,CAAA,CAAA,CAAA,CAER,CAGZ,CAEA,MAAAU,EAAAE,EAAA,WAAA,OAAA,CAAiC,KAAA,CAOvB,cAAA,OACa,QAAA,EACN,gBAAA,cACQ,MAAA,aACV,EACX,cAAA,CAKe,cAAA,QACI,EACnB,gBAAA,CACiB,cAAA,aACE,EACnB,iBAAA,CACkB,cAAA,gBACC,EACnB,eAAA,CACgB,cAAA,KACG,CAEvB,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;itHC7IA,MAAMC,EACF,2EAEG,SAASC,EACZC,EACkB,CAClB,OAAO,MAAM,KAAKA,EAAK,iBAAiBF,CAAkB,CAAC,CAC/D,CCUqB,MAAAG,UAAqBlC,EAAAA,SAAuB,CAAjE,aAAA,CAAA,MAAA,GAAA,SAAA,EAcI,KAAA,2BAA2DmC,GAAS,CAI1D,MAAAC,EACF,KAAK,4BAA4BD,CAAI,GACrC,KAAK,8BAA8BA,CAAI,GACvCA,EAEAC,IAA0BD,IAE1BA,EAAK,SAAW,IAIpB,WAAW,IAAM,CACbC,EAAsB,MAAM,GAC7B,CAAC,CAAA,CACR,CA/BA,mBAAoB,CACV,MAAAD,EAAoBjC,cAAqB,IAAI,EAE9CiC,GAIL,KAAK,2BAA2BA,CAAI,CACxC,CA4BA,4BAA4BA,EAAuC,CACzD,KAAA,CAAC,eAAAE,CAAc,EAAI,KAAK,MAE9B,OAAKA,EAIEF,EAAK,cAAc,IAAIE,CAAc,EAAE,EAHnC,IAIf,CAKA,8BAA8BF,EAAuC,CAE3D,MAAAG,EAAoBN,EAAmBG,CAAI,EAE7C,OAACG,EAAkB,OAKhBA,EAAkB,CAAC,EAJf,IAKf,CAEA,QAA0B,CACtB,OAAO,KAAK,MAAM,QACtB,CACJ,CChDA,MAAAC,UAAAvC,EAAAA,SAAA,CAAiE,aAAA,CAAjE,MAAA,GAAA,SAAA,EAgDI,KAAA,2BAAA,GAKA,KAAA,kBAAA,IAAA,CACI,KAAA,CAAA,cAAAwC,CAAA,EAAA,KAAA,MAEAA,GACIA,EAAA,iBAAc,UACV,KAAA,sCACK,EACL,EAKR,KAAA,wBAAA,KAAA,0BAEA,KAAA,yBACI,KAAA,wBAAA,iBAA6B,UACzB,KAAA,kCACK,EACL,CAER,EAMJ,KAAA,wBAAA,IAAA,CACI,KAAA,CAAA,cAAAA,CAAA,EAAA,KAAA,MAEA,GAAA,CAAAA,EACI,OAIJ,MAAAF,EAAAN,EAAA,QAAA,EAGAS,EAAAH,EAAA,QAAAE,CAAA,EAEA,GAAAC,GAAA,EAAA,CAEI,MAAAC,EAAAD,EAAAH,EAAA,OAAA,EAAAG,EAAA,EAAA,EAMA,OAAAH,EAAAI,CAAA,CAAyC,CAG7C,EAOJ,KAAA,qBAAAP,GAAA,CACI,GAAA,CAAAA,EAEI,OAGJ,MAAAQ,EAAAzC,cAAAiC,CAAA,EAEA,GAAA,CAAAQ,EACI,MAAA,IAAA,MAAU,qDACN,EAIR,KAAA,SAAAA,EAGA,KAAA,2BAAAX,EAAA,KAAA,QAAA,CAAkE,EAOtE,KAAA,oCAAA,IAAA,CACI,KAAA,MAAA,eACI,KAAA,MAAA,cAAA,OACJ,EAOJ,KAAA,gCAAA,IAAA,CACI,KAAA,yBACI,KAAA,wBAAA,OACJ,EAQJ,KAAA,sCAAA,GAAA,CAEI,EAAA,MAAA,OAAA,CAAA,EAAA,WACI,EAAA,eAAA,EACA,KAAA,2BAAA,CAAA,EAAA,MAAA,EACJ,EAOJ,KAAA,kCAAA,GAAA,CAEI,GAAA,EAAA,MAAA,OAAA,EAAA,SAAA,CACI,EAAA,eAAA,EACA,MAAAY,EAAA,KAAA,2BAAA,OAAA,EACA,KAAA,2BAAAA,CAAA,EAAA,MAAA,CAAwD,CAC5D,CACJ,CAAA,mBAAA,CAlKI,KAAA,kBAAA,CAAuB,CAC3B,oBAAA,CAGI,KAAA,kBAAA,CAAuB,CAC3B,sBAAA,CAMI,KAAA,CAAA,cAAAJ,CAAA,EAAA,KAAA,MAEAA,IAEI,WAAA,IAAAA,EAAA,MAAA,EAAA,CAAA,EAEAA,EAAA,oBAAc,UACV,KAAA,sCACK,EACL,GAIR,KAAA,yBACI,KAAA,wBAAA,oBAA6B,UACzB,KAAA,kCACK,EACL,CAER,CACJ,QAAA,CAsII,KAAA,CAAA,SAAArC,CAAA,EAAA,KAAA,MAEA,OAAAuB,EAAAD,WAAA,CAAA,SAAA,CAMQD,EAAA,MAAC,CAAA,SAAA,EACa,QAAA,KAAA,oCACI,MAAA,CAAA,SAAA,OAAA,CACW,CAAA,EAC7BA,EAAA,MAAA,CAAA,IAAA,KAAA,qBAAA,SAAAA,EAAAU,EAAA,CAAA,eAAA,KAAA,MAAA,eAAA,SAAA/B,CAAA,CAAA,EAAA,EAKAqB,EAEA,MAAC,CAAA,SAAA,EACa,QAAA,KAAA,gCACI,MAAA,CAAA,SAAA,OAAA,CACW,CAAA,CAC7B,CAAA,CAAA,CACJ,CAGZ;;;;;;;;;;;;;;2ICpNqB,MAAAqB,UAA6B7C,EAAAA,SAGhD,CAHF,aAAA,CAAA,MAAA,GAAA,SAAA,EAImB,KAAA,MAAA,CACX,aAAc,EAAA,EAalB,KAAA,aAA4C,GAAM,CAI1C,EAAE,MAAQ,WAOV,EAAE,eAAe,EACjB,EAAE,gBAAgB,EAClB,KAAK,MAAM,UACf,EAGJ,KAAA,aAAyC,GAAM,OAGvC,GAAA,KAAK,MAAM,aAAc,CACzB,KAAK,SAAS,CAAC,aAAc,EAAM,CAAA,EACnC,MACJ,CAEA,MAAMmC,EAAOjC,EAAAA,aAAqB4C,EAAA,KAAK,MAAM,aAAX,YAAAA,EAAuB,OAAO,EAC5DX,GAAQ,CAACA,EAAK,SAAS,EAAE,MAAa,IAGtC,EAAE,eAAe,EACjB,EAAE,gBAAgB,EAClB,KAAK,MAAM,UACf,CACJ,CA3CA,mBAAoB,CACT,OAAA,iBAAiB,QAAS,KAAK,YAAY,EAC3C,OAAA,iBAAiB,QAAS,KAAK,YAAY,CACtD,CAEA,sBAAuB,CACZ,OAAA,oBAAoB,QAAS,KAAK,YAAY,EAC9C,OAAA,oBAAoB,QAAS,KAAK,YAAY,CACzD,CAqCA,QAAoC,CACzB,OAAA,IACX,CACJ,CC4DA,MAAAY,UAAA/C,EAAAA,SAAA,CAAmE,aAAA,CAAnE,MAAA,GAAA,SAAA,EAoBI,KAAA,MAAA,CAAe,OAAA,CAAA,CAAA,KAAA,MAAA,OACU,UAAA,KAAA,MAAA,SACC,EAM1B,KAAA,WAAAgD,EAAAA,YAMA,KAAA,YAAA,IAAA,CACI,KAAA,SAAA,CAAA,OAAA,EAAA,EAAA,IAAA,UACIC,GAAAH,EAAA,KAAA,OAAA,UAAA,MAAAG,EAAA,KAAAH,EAAqB,CAAA,CACxB,EAML,KAAA,WAAA,IAAA,CACI,KAAA,MAAA,gBAAA,KAAA,MAAA,OACI,KAAA,SAAA,CAAA,OAAA,EAAA,CAAA,EAEA,KAAA,SAAA,CAAA,OAAA,EAAA,CAAA,CACJ,EAGJ,KAAA,UAAAI,GAAA,CACIA,GAAA,KAAA,MAAA,gBAAAA,GACI,KAAA,SAAA,CAAc,cAAAA,CACK,CAAA,CAEvB,CACJ,CAAA,OAAA,yBAAAC,EAAAC,EAAA,CA3CI,MAAA,CAAO,OAAA,OAAAD,EAAA,QAAA,UAAAA,EAAA,OAAAC,EAAA,MAE0D,CACjE,CACJ,eAAA,CA0CI,KAAA,CAAA,QAAAC,CAAA,EAAA,KAAA,MAEAC,EAAA,OAAAD,GAAA,WAAAA,EAAA,CAEkB,MAAA,KAAA,WACQ,CAAA,EAAAA,EAK1B,OAAA3C,EAAAA,aAAA4C,EAAA,CAAA,IAAA,KAAA,UAAA,CAAA,CAAiE,CACrE,aAAAC,EAAA,CAGI,KAAA,CAAA,eAAAlB,EAAA,UAAAvB,EAAA,SAAAM,CAAA,EAAA,KAAA,MACA,CAAA,cAAAoB,CAAA,EAAA,KAAA,MAEA,OAAAhB,EACIe,EAAC,CAAA,cAAAC,EACG,eAAAH,EACA,SAAAb,EAEAgC,EAAC,CAAA,cAAAhB,EACG,UAAA1B,EACA,SAAAqC,GAAA3B,EAGIZ,EAAC,CAAA,GAAAuC,EACO,mBAAA,GAAAI,CAAA,UACyB,GAAAA,EACzB,SAAAE,GAAA,KAAA,SAAA,CAAA,UAAAA,EAAA,EAC8C,SAAArC,EAClD,SAAA,KAAA,cAAA,CAEoB,CAAA,CACxB,CAAA,CAER,CAAA,CACJ,CAER,SAAA,CAOI,OAAAsC,EAAA,KAAA,MAAA,aAAA,GAAA,SAAA,IAEa,CAEjB,QAAA,CAGI,KAAA,CAAA,SAAAvD,EAAA,eAAAwD,EAAA,GAAAvD,CAAA,EAAA,KAAA,MACA,CAAA,OAAAwD,EAAA,UAAA9C,GAAA,KAAA,MACA+C,EAAA,KAAA,UAEA,OAAAnC,EACI9B,EAAA,SAAgB,CAAf,MAAA,CACU,MAAA,KAAA,YACS,UAAAkB,CACZ,EACJ,SAAA,CAEAU,EAAAsC,EAAA,CAAA,GAAA1D,EAAA,MAAA,UAAA,SAAAmD,GAAA7B,EAAAD,EAAA,SAAA,CAAA,SAAA,CAGYD,EAAAzB,EAAC,CAAA,UAAA,KAAA,UACmB,GAAA,GAAAwD,CAAA,UACD,gBAAAA,EACA,gBAAAK,EAAA,OAAA,QACkB,QAAA,KAAA,WACnB,SAAAzD,CAEb,CAAA,EACL0D,GAAAD,GAAAG,EAAA,aAGa,KAAA,aAAAR,CAAA,EACqBM,CAC1B,CACJ,CAAA,CAAA,CAAA,CAAA,EAGhBF,GAAAC,GAAApC,EAGIqB,EAAC,CAAA,QAAA,KAAA,YACiB,WAAA,KAAA,UACG,CAAA,CACrB,CAAA,CAAA,CAER,CAGZ,CA5JqBE,EAAA,aAAA,CACmB,UAAA,MACrB,SAAA,EAEf;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;2eCpHJ,MAAAiB,UAAAhE,EAAAA,SAAA,CAAgE,QAAA,CAOxD,KAAA,CAAA,MAAAiE,EAAA,aAAAC,EAAA,MAAA/C,EAAA,OAAAgD,CAAA,EAAA,KAAA,MACA,OAAA3C,EAAA5B,EAAA,SAAA,CAAA,SAAA,CAAA,CAAA,MAAAwE,KAGY5C,EACI6C,EAAC,CAAA,KAAAC,EACe,aAAAJ,EACA,QAAAE,EACH,KAAAH,EAAA,UAAA,WACiB,MAAAA,EAC1B,MAAA9C,EACA,OAAAgD,CACA,CAAA,CACJ,CAAA,CAGZ,CAGZ,CA1BqBH,EAAA,aAAA,CACmB,MAAA,GACzB,aAAA,eAEX;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;uVC0BJ,MAAAO,UAAAvE,EAAAA,SAAA,CAAuE,QAAA,CAQ/D,KAAA,CAAM,SAAAG,EACF,iBAAAqE,EACA,iBAAAC,EACA,mBAAAC,EACA,MAAAnD,EACA,MAAAJ,EACA,OAAAgD,CACA,EAAA,KAAA,MAGJ,OAAAzC,EACIC,EAAC,CAAA,OAAAwC,EACG,MAAA,CACOvC,EAAA,QACIL,IAAA,SAAAK,EAAAL,CAAA,EAC0BJ,CACjC,EACJ,SAAA,CAECuD,GAAAlD,EACGwC,EAAC,CAAA,aAAAS,EACe,MAAAD,GAAAjD,IAAA,QACyB,MAAAK,EAAA,YACvB,OAAA,GAAAuC,GAAA,SAAA,YACgB,CAAA,EAClChE,CAEH,CAAA,CAAA,CACL,CAGZ,CAvCqBoE,EAAA,aAAA,CACmB,MAAA,QACzB,iBAAA,GACW,mBAAA,EAEtB,EAoCJ,MAAA3C,EAAAE,EAAA,WAAA,OAAA,CAAiC,QAAA,CACpB,aAAA6C,EAAA,WACiB,OAAA,aAAAC,EAAA,UAAA,GACgB,gBAAAA,EAAA,MACd,UAAA,KAAAD,EAAA,QAAA,MAAAA,EAAA,QAAA,QAAAC,EAAA,SAAA,GACsD,OAAA,EACtE,SAAAD,EAAA,UAAA,GACsB,QAAAA,EAAA,SACb,SAAA,SACP,eAAA,QACM,EACpB,KAAA,CAIM,gBAAAC,EAAA,KACsB,MAAAA,EAAA,KACV,EAClB,SAAA,CAEU,gBAAAA,EAAA,SACkB,MAAAA,EAAA,KACV,EAClB,YAAA,CAKa,SAAA,WACC,MAAAD,EAAA,SACK,IAAAA,EAAA,SACF,OAAA,CAEL,CAEhB,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;uYC9DA,MAAAE,EAAAC,EAAA,KAAA,EAkBA,MAAAC,UAAA/E,EAAAA,SAAA,CAAmE,aAAA,CAAnE,MAAA,GAAA,SAAA,EAiCI,KAAA,iBAAA,CAAA,CAAyE,UAAAc,CACrE,IAAA,CAEA,KAAA,CAAA,MAAAkE,CAAA,EAAA,KAAA,MAEA,OAAAA,EAIAxD,EACIG,EAAC,CAAA,MAAA,CACUC,EAAA,MACId,IAAA,UAAAc,EAAA,aAC0B,EACrC,SAAAoD,CAEC,CAAA,EAVL,IAWA,EAKR,KAAA,gBAAA,IAAA,CACI,KAAA,CAAA,KAAAC,CAAA,EAAA,KAAA,MAEA,OAAAA,EAIAzD,EAAAG,EAAA,CAAA,MAAAC,EAAA,cAAA,SAAA,OAAAqD,GAAA,SAAAA,EAAAzD,EAAAqD,EAAA,CAAA,IAAAI,EAAA,MAAArD,EAAA,KAAA,CAAA,CAAA,EAHI,IAUA,EAKR,KAAA,mBAAAwC,GAAA,CAGI,KAAA,CAAA,QAAAc,CAAA,EAAA,KAAA,MAEA,OAAAA,EAIA1D,EAAAG,EAAA,CAAA,MAAAC,EAAA,QAAA,SAAA,OAAAsD,GAAA,WAAAA,EAAA,CAGsB,MAAAd,CACJ,CAAA,EAAAc,CAAA,CAAA,EAPd,IAUA,CAER,CAAA,mBAAA,CAtFI,KAAA,CAAA,KAAAD,EAAA,MAAAD,GAAA,KAAA,MAIA,GAAAA,GAAAC,EACI,MAAA,IAAA,MAAU,+HACN,CAER,CACJ,cAAA,CAAA,UAAAnE,GAAA,CAOI,GAAA,KAAA,MAAA,QAAAA,IAAA,QAAAA,IAAA,SAII,MAAA,IAAA,MAAU,4JACN,CAER,CACJ,QAAA,CAiEI,KAAA,CAAM,iBAAA2D,EACF,mBAAAC,EACA,QAAArB,EACA,WAAA8B,EAAA,OACa,KAAAF,EACb,MAAAD,EACA,MAAA7D,EACA,MAAAiE,EACA,OAAAjB,CACA,EAAA,KAAA,MAGJ,OAAA3C,EAAA5B,EAAA,SAAA,CAAA,SAAA,CAAA,CAAA,MAAAwE,EAAA,UAAAtD,MAIY,KAAA,cAAA,CAAA,MAAAsD,EAAA,UAAAtD,CAAA,CAAA,EAEAY,EACI6C,EAAC,CAAA,MAAAY,EAAA,OAAA,QACgC,iBAAAH,GAAAlE,IAAA,MACY,iBAAA2D,EACzC,mBAAAC,EACA,MAAAvD,EACA,OAAAgD,EACA,SAAA,CAEAzC,EAAAC,EAAA,CAAA,MAAA,CAAA,CAAAsD,GAAArD,EAAA,SAAA,SAAA,CACK,KAAA,iBAAA,CAAA,UAAAd,EAAA,EAAiC,KAAA,gBAAA,EAEZY,EAAAC,EAAA,CAAA,MAAAC,EAAA,KAAA,SAAA,CAGlBJ,EAAA6D,EAAA,CAAA,MAAAzD,EAAA,MAAA,SAAAwD,EAAA,EAEA5D,EAAA8D,EAAA,CAAA,SAAAjC,CAAA,CAAA,CACe,EAAA,CACnB,EAAA,EACJ,KAAA,mBAAAe,CAAA,CAEqC,CAAA,CAAA,EACzC,CAAA,CAGZ,CAGZ,CA9IqBW,EAAA,aAAA,CACmB,mBAAA,EAEpC,EA6IJ,MAAAnD,EAAAE,EAAA,WAAA,OAAA,CAAiC,QAAA,CAIpB,UAAA6C,EAAA,SACc,cAAA,MACJ,WAAA,SACH,eAAA,UACI,EACpB,KAAA,CAEM,eAAA,QACc,EACpB,MAAA,CAEO,aAAAA,EAAA,QACmB,EAC1B,cAAA,CAKe,WAAA,SACC,eAAA,SACI,OAAAA,EAAA,YACA,MAAAA,EAAA,YACD,SAAAA,EAAA,YACG,YAAAA,EAAA,UACG,SAAA,QACX,EACd,KAAA,CAEM,MAAA,MACK,EACX,SAAA,CAEU,cAAA,KACS,EACnB,MAAA,CAKO,aAAAA,EAAA,SACmB,WAAA,CAAAA,EAAA,SACD,YAAA,CAAAA,EAAA,SACC,UAAA,CAAAA,EAAA,SACF,MAAA,eAAAA,EAAA,SAAA,CAAA,KACsB,EAC9C,cAAA,CAEe,aAAA,CAAAA,EAAA,SACY,UAAAA,EAAA,SACJ,MAAA,CACZ,CAEf,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}