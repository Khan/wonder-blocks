{"version":3,"file":"multi-select-4619a451.js","sources":["../../packages/wonder-blocks-dropdown/src/util/constants.ts","../../packages/wonder-blocks-dropdown/src/components/action-item.tsx","../../packages/wonder-blocks-dropdown/src/components/check.tsx","../../packages/wonder-blocks-dropdown/src/components/checkbox.tsx","../../packages/wonder-blocks-dropdown/src/components/option-item.tsx","../../packages/wonder-blocks-dropdown/src/components/separator-item.tsx","../../packages/wonder-blocks-dropdown/src/components/dropdown-opener.tsx","../../node_modules/memoize-one/dist/memoize-one.esm.js","../../node_modules/react-window/dist/index.esm.js","../../packages/wonder-blocks-dropdown/src/components/dropdown-core-virtualized-item.ts","../../packages/wonder-blocks-dropdown/src/util/dropdown-menu-styles.ts","../../packages/wonder-blocks-dropdown/src/components/dropdown-core-virtualized.tsx","../../packages/wonder-blocks-dropdown/src/components/dropdown-popper.tsx","../../packages/wonder-blocks-dropdown/src/util/helpers.ts","../../packages/wonder-blocks-dropdown/src/components/dropdown-core.tsx","../../packages/wonder-blocks-dropdown/src/components/action-menu-opener-core.tsx","../../packages/wonder-blocks-dropdown/src/components/action-menu.tsx","../../packages/wonder-blocks-dropdown/src/components/select-opener.tsx","../../packages/wonder-blocks-dropdown/src/components/single-select.tsx","../../packages/wonder-blocks-dropdown/src/components/multi-select.tsx"],"sourcesContent":["import Spacing from \"@khanacademy/wonder-blocks-spacing\";\n\nexport const keyCodes = {\n    tab: 9,\n    enter: 13,\n    escape: 27,\n    space: 32,\n    up: 38,\n    down: 40,\n} as const;\n\nexport const selectDropdownStyle = {\n    marginTop: Spacing.xSmall_8,\n    marginBottom: Spacing.xSmall_8,\n} as const;\n\n// Filterable dropdown has minimum dimensions requested from Design.\n// Note that these can be overridden by the provided style if needed.\nexport const filterableDropdownStyle = {\n    minHeight: 100,\n} as const;\n\n// The default item height\nexport const DROPDOWN_ITEM_HEIGHT = 40;\n\n/**\n * Maximum visible items inside the dropdown list. Based on the defined height\n * that we're using, this is the maximum number of items that can fit into the\n * visible portion of the dropdown's listbox.\n */\nexport const MAX_VISIBLE_ITEMS = 9;\n\nexport const SEPARATOR_ITEM_HEIGHT = 9;\n\n// The default labels that will be used by different components\nexport const defaultLabels = {\n    clearSearch: \"Clear search\",\n    filter: \"Filter\",\n    noResults: \"No results\",\n    selectNoneLabel: \"Select none\",\n    selectAllLabel: (numOptions: number): string =>\n        `Select all (${numOptions})`,\n    noneSelected: \"0 items\",\n    someSelected: (numSelectedValues: number): string =>\n        `${numSelectedValues} items`,\n    allSelected: \"All items\",\n} as const;\n","import * as React from \"react\";\nimport {StyleSheet} from \"aphrodite\";\nimport {Link} from \"react-router-dom\";\nimport {__RouterContext} from \"react-router\";\n\nimport Color, {mix, fade} from \"@khanacademy/wonder-blocks-color\";\nimport Spacing from \"@khanacademy/wonder-blocks-spacing\";\nimport {LabelMedium} from \"@khanacademy/wonder-blocks-typography\";\nimport {\n    getClickableBehavior,\n    isClientSideUrl,\n} from \"@khanacademy/wonder-blocks-clickable\";\nimport {addStyle} from \"@khanacademy/wonder-blocks-core\";\n\nimport type {StyleType} from \"@khanacademy/wonder-blocks-core\";\n\nimport {DROPDOWN_ITEM_HEIGHT} from \"../util/constants\";\n\nconst {blue, white, offBlack, offBlack32} = Color;\n\ntype ActionProps = {\n    /**\n     * Display text of the action item.\n     */\n    label: string;\n    /**\n     * Whether this action item is disabled.\n     */\n    disabled: boolean;\n    /**\n     * URL to navigate to.\n     *\n     * Note: Either href or onClick must be defined\n     */\n    href?: string;\n    /**\n     * Optional attribute to indicate to the Screen Reader which language the\n     * item text is in.\n     */\n    lang?: string;\n    /**\n     * A target destination window for a link to open in.\n     *\n     * TODO(WB-1262): only allow this prop when `href` is also set.t\n     */\n    target?: \"_blank\";\n    /**\n     * Whether to avoid using client-side navigation.\n     *\n     * If the URL passed to href is local to the client-side, e.g.\n     * /math/algebra/eval-exprs, then it tries to use react-router-dom's Link\n     * component which handles the client-side navigation. You can set\n     * `skipClientNav` to true avoid using client-side nav entirely.\n     *\n     * NOTE: All URLs containing a protocol are considered external, e.g.\n     * https://khanacademy.org/math/algebra/eval-exprs will trigger a full\n     * page reload.\n     */\n    skipClientNav?: boolean;\n    /**\n     * Test ID used for e2e testing.\n     */\n    testId?: string;\n    /**\n     * Function to call when button is clicked.\n     *\n     * This callback should be used for things like marking BigBingo\n     * conversions. It should NOT be used to redirect to a different URL or to\n     * prevent navigation via e.preventDefault(). The event passed to this\n     * handler will have its preventDefault() and stopPropagation() methods\n     * stubbed out.\n     *\n     * Note: onClick is optional if href is present, but must be defined if\n     * href is not\n     */\n    onClick?: () => unknown;\n    /**\n     * Whether this item should be indented to have menu items left-align in\n     * text when an ActionItem is used in the same menu as items that have\n     * checks or checkboxes. Auto-populated by menu.\n     * @ignore\n     */\n    indent: boolean;\n    /**\n     * Aria role to use, defaults to \"menuitem\".\n     */\n    role: \"menuitem\" | \"option\";\n    /**\n     * In case we use react-window, this needs to be added in order to inject\n     * styles to calculate the position\n     * @ignore\n     */\n    style?: StyleType;\n};\n\ntype DefaultProps = {\n    disabled: ActionProps[\"disabled\"];\n    indent: ActionProps[\"indent\"];\n    role: ActionProps[\"role\"];\n};\n\nconst StyledAnchor = addStyle(\"a\");\nconst StyledButton = addStyle(\"button\");\nconst StyledLink = addStyle(Link);\n\n/**\n * The action item trigger actions, such as navigating to a different page or\n * opening a modal. Supply the href and/or onClick props. Used as a child of\n * ActionMenu.\n */\nexport default class ActionItem extends React.Component<ActionProps> {\n    static isClassOf(instance: React.ReactElement<any>): boolean {\n        // @ts-expect-error [FEI-5019] - TS2339 - Property '__IS_ACTION_ITEM__' does not exist on type 'string | JSXElementConstructor<any>'.\n        return instance && instance.type && instance.type.__IS_ACTION_ITEM__;\n    }\n    static defaultProps: DefaultProps = {\n        disabled: false,\n        indent: false,\n        role: \"menuitem\",\n    };\n    static __IS_ACTION_ITEM__ = true;\n\n    renderClickableBehavior(router: any): React.ReactNode {\n        const {\n            skipClientNav,\n            disabled,\n            href,\n            target,\n            indent,\n            label,\n            lang,\n            onClick,\n            role,\n            style,\n            testId,\n        } = this.props;\n\n        const ClickableBehavior = getClickableBehavior(\n            href,\n            skipClientNav,\n            router,\n        );\n\n        return (\n            <ClickableBehavior\n                disabled={disabled}\n                onClick={onClick}\n                href={href}\n                role={role}\n                target={target}\n            >\n                {(state, childrenProps) => {\n                    const {pressed, hovered, focused} = state;\n\n                    const defaultStyle = [\n                        styles.shared,\n                        disabled && styles.disabled,\n                        !disabled &&\n                            (pressed\n                                ? styles.active\n                                : (hovered || focused) && styles.focus),\n                        // pass optional styles from react-window (if applies)\n                        style,\n                    ];\n\n                    const props = {\n                        \"data-test-id\": testId,\n                        disabled,\n                        role,\n                        style: [defaultStyle],\n                        ...childrenProps,\n                    } as const;\n\n                    const children = (\n                        <React.Fragment>\n                            <LabelMedium\n                                lang={lang}\n                                style={[indent && styles.indent, styles.label]}\n                            >\n                                {label}\n                            </LabelMedium>\n                        </React.Fragment>\n                    );\n\n                    if (href && !disabled) {\n                        return router &&\n                            !skipClientNav &&\n                            isClientSideUrl(href) ? (\n                            <StyledLink {...props} to={href}>\n                                {children}\n                            </StyledLink>\n                        ) : (\n                            <StyledAnchor\n                                {...props}\n                                href={href}\n                                target={target}\n                            >\n                                {children}\n                            </StyledAnchor>\n                        );\n                    } else {\n                        return (\n                            <StyledButton\n                                type=\"button\"\n                                {...props}\n                                disabled={disabled}\n                            >\n                                {children}\n                            </StyledButton>\n                        );\n                    }\n                }}\n            </ClickableBehavior>\n        );\n    }\n\n    render(): React.ReactNode {\n        return (\n            <__RouterContext.Consumer>\n                {(router) => this.renderClickableBehavior(router)}\n            </__RouterContext.Consumer>\n        );\n    }\n}\n\nconst styles = StyleSheet.create({\n    shared: {\n        background: white,\n        color: offBlack,\n        textDecoration: \"none\",\n        border: \"none\",\n        outline: \"none\",\n        flexDirection: \"row\",\n        alignItems: \"center\",\n        display: \"flex\",\n        height: DROPDOWN_ITEM_HEIGHT,\n        minHeight: DROPDOWN_ITEM_HEIGHT,\n        paddingLeft: Spacing.medium_16,\n        paddingRight: Spacing.medium_16,\n        // This removes the 300ms click delay on mobile browsers by indicating that\n        // \"double-tap to zoom\" shouldn't be used on this element.\n        touchAction: \"manipulation\",\n    },\n\n    label: {\n        whiteSpace: \"nowrap\",\n        userSelect: \"none\",\n    },\n\n    indent: {\n        marginLeft: Spacing.medium_16,\n    },\n\n    // hover and focus states\n    focus: {\n        color: white,\n        background: blue,\n    },\n\n    // active and pressed states\n    active: {\n        color: mix(fade(blue, 0.32), white),\n        background: mix(offBlack32, blue),\n    },\n\n    // disabled state\n    disabled: {\n        color: offBlack32,\n        cursor: \"default\",\n    },\n});\n","import * as React from \"react\";\nimport {StyleSheet} from \"aphrodite\";\n\nimport Color from \"@khanacademy/wonder-blocks-color\";\nimport Icon, {icons} from \"@khanacademy/wonder-blocks-icon\";\n\nconst {offBlack, offBlack32, white} = Color;\n\n/**\n * Props describing the state of the OptionItem, shared by the checkbox\n * component,\n */\ntype CheckProps = {\n    /** Whether option item is disabled. */\n    disabled: boolean;\n    /** Whether option item is selected. */\n    selected: boolean;\n    /** Whether option item is pressed. */\n    pressed: boolean;\n    /** Whether option item is hovered. */\n    hovered: boolean;\n    /** Whether option item is focused. */\n    focused: boolean;\n};\n\n/**\n * The check component used by OptionItem.\n */\nconst Check = function (props: CheckProps): React.ReactElement {\n    const {disabled, selected, pressed, hovered, focused} = props;\n    return (\n        <Icon\n            icon={icons.check}\n            size=\"small\"\n            color={\n                disabled\n                    ? offBlack32\n                    : pressed || hovered || focused\n                    ? white\n                    : offBlack\n            }\n            style={[styles.bounds, !selected && styles.hide]}\n        />\n    );\n};\n\nexport default Check;\n\nconst styles = StyleSheet.create({\n    bounds: {\n        // Semantically, this are the constants for a small-sized icon\n        minHeight: 16,\n        minWidth: 16,\n    },\n\n    hide: {\n        visibility: \"hidden\",\n    },\n});\n","import * as React from \"react\";\nimport {StyleSheet} from \"aphrodite\";\n\nimport Color, {mix} from \"@khanacademy/wonder-blocks-color\";\nimport {View} from \"@khanacademy/wonder-blocks-core\";\nimport Icon from \"@khanacademy/wonder-blocks-icon\";\n\nimport type {IconAsset} from \"@khanacademy/wonder-blocks-icon\";\n\n// NOTE(sophie): This is a smaller check specifically for use in checkboxes.\n// Please don't copy it automatically and check with designers before using.\n// If the intended icon is a check without a checkbox, you should be using\n// icons.check from the Wonder Blocks Icon package.\nconst checkboxCheck: IconAsset = {\n    small: \"M11.263 4.324a1 1 0 1 1 1.474 1.352l-5.5 6a1 1 0 0 1-1.505-.036l-2.5-3a1 1 0 1 1 1.536-1.28L6.536 9.48l4.727-5.157z\",\n};\nconst {blue, white, offBlack16, offBlack32, offBlack50, offWhite} = Color;\n\n/**\n * Props describing the state of the OptionItem, shared by the check\n * component,\n */\ntype CheckProps = {\n    /** Whether option item is disabled. */\n    disabled: boolean;\n    /** Whether option item is selected. */\n    selected: boolean;\n    /** Whether option item is pressed. */\n    pressed: boolean;\n    /** Whether option item is hovered. */\n    hovered: boolean;\n    /** Whether option item is focused. */\n    focused: boolean;\n};\n\n/**\n * The checkbox component used by OptionItem.\n */\nconst Checkbox = function (props: CheckProps): React.ReactElement {\n    const {disabled, selected, pressed, hovered, focused} = props;\n    const activeBlue = mix(offBlack32, blue);\n    const clickInteraction = pressed || hovered || focused;\n\n    const bgColor = disabled\n        ? offWhite\n        : selected && !clickInteraction\n        ? blue\n        : white;\n    const checkColor = disabled\n        ? offBlack32\n        : clickInteraction\n        ? pressed\n            ? activeBlue\n            : blue\n        : white;\n\n    return (\n        <View\n            style={[\n                styles.checkbox,\n                (clickInteraction || (selected && !disabled)) &&\n                    styles.noBorder,\n                disabled && styles.disabledCheckbox,\n                {backgroundColor: bgColor},\n            ]}\n        >\n            {selected && (\n                <Icon\n                    icon={checkboxCheck}\n                    size=\"small\"\n                    color={checkColor}\n                    style={[\n                        disabled && selected && styles.disabledCheckFormatting,\n                    ]}\n                />\n            )}\n        </View>\n    );\n};\n\nexport default Checkbox;\n\nconst styles = StyleSheet.create({\n    checkbox: {\n        // Semantically, this are the constants for a small-sized icon\n        minHeight: 16,\n        minWidth: 16,\n        borderRadius: 3,\n        borderWidth: 1,\n        borderStyle: \"solid\",\n        borderColor: offBlack50,\n    },\n\n    noBorder: {\n        borderWidth: 0,\n    },\n\n    disabledCheckbox: {\n        borderColor: offBlack16,\n        backgroundColor: offWhite,\n    },\n\n    // The border of 1px on the selected, disabled checkbox pushes the check out\n    // of place. Move it back.\n    disabledCheckFormatting: {\n        position: \"absolute\",\n        top: -1,\n        left: -1,\n    },\n});\n","import * as React from \"react\";\nimport {StyleSheet} from \"aphrodite\";\n\nimport Color, {mix, fade} from \"@khanacademy/wonder-blocks-color\";\nimport Spacing from \"@khanacademy/wonder-blocks-spacing\";\nimport {LabelMedium} from \"@khanacademy/wonder-blocks-typography\";\nimport {View} from \"@khanacademy/wonder-blocks-core\";\nimport {getClickableBehavior} from \"@khanacademy/wonder-blocks-clickable\";\n\nimport type {AriaProps, StyleType} from \"@khanacademy/wonder-blocks-core\";\n\nimport {DROPDOWN_ITEM_HEIGHT} from \"../util/constants\";\nimport Check from \"./check\";\nimport Checkbox from \"./checkbox\";\n\ntype OptionProps = AriaProps & {\n    /**\n     * Display text of the option item.\n     */\n    label: string;\n    /**\n     * Value of the item, used as a key of sorts for the parent to manage its\n     * items, because label/display text may be identical for some selects. This\n     * is the value passed back when the item is selected.\n     */\n    value: string;\n    /**\n     * Whether this option item is disabled.\n     */\n    disabled: boolean;\n    /**\n     * Optional user-supplied callback when this item is called.\n     */\n    onClick?: () => unknown;\n    /**\n     * Callback for when this item is pressed to change its selection state.\n     * Passes value of the item. Auto-populated by menu or select.\n     * @ignore\n     */\n    onToggle: (value: string) => unknown;\n    /**\n     * Whether this item is selected. Auto-populated by menu or select.\n     * @ignore\n     */\n    selected: boolean;\n    /**\n     * Aria role to use, defaults to \"option\".\n     */\n    role: \"menuitem\" | \"option\";\n    /**\n     * Test ID used for e2e testing.\n     */\n    testId?: string;\n    /**\n     * Whether the item should show a check or checkbox to indicate selection\n     * state. Auto-populated by menu or select.\n     * @ignore\n     */\n    variant?: \"check\" | \"checkbox\";\n    /**\n     * In case we use react-window, this needs to be added in order to inject\n     * styles to calculate the position\n     * @ignore\n     */\n    style?: StyleType;\n};\n\ntype DefaultProps = {\n    disabled: OptionProps[\"disabled\"];\n    onToggle: OptionProps[\"onToggle\"];\n    role: OptionProps[\"role\"];\n    selected: OptionProps[\"selected\"];\n};\n\n/**\n * For option items that can be selected in a dropdown, selection denoted either\n * with a check ✔️ or a checkbox ☑️. Use as children in SingleSelect or\n * MultiSelect.\n */\nexport default class OptionItem extends React.Component<OptionProps> {\n    static isClassOf(instance: React.ReactElement<any>): boolean {\n        // @ts-expect-error [FEI-5019] - TS2339 - Property '__IS_OPTION_ITEM__' does not exist on type 'string | JSXElementConstructor<any>'.\n        return instance && instance.type && instance.type.__IS_OPTION_ITEM__;\n    }\n    static defaultProps: DefaultProps = {\n        disabled: false,\n        onToggle: () => void 0,\n        role: \"option\",\n        selected: false,\n    };\n    static __IS_OPTION_ITEM__ = true;\n\n    getCheckComponent(): typeof Check | typeof Checkbox {\n        if (this.props.variant === \"check\") {\n            return Check;\n        } else {\n            return Checkbox;\n        }\n    }\n\n    handleClick: () => void = () => {\n        const {onClick, onToggle, value} = this.props;\n        onToggle(value);\n        if (onClick) {\n            onClick();\n        }\n    };\n\n    render(): React.ReactNode {\n        const {\n            disabled,\n            label,\n            role,\n            selected,\n            testId,\n            style,\n            // eslint-disable-next-line @typescript-eslint/no-unused-vars\n            value,\n            /* eslint-disable @typescript-eslint/no-unused-vars */\n            onClick,\n            onToggle,\n            variant,\n            /* eslint-enable @typescript-eslint/no-unused-vars */\n            ...sharedProps\n        } = this.props;\n\n        const ClickableBehavior = getClickableBehavior();\n        const CheckComponent = this.getCheckComponent();\n\n        return (\n            <ClickableBehavior\n                disabled={disabled}\n                onClick={this.handleClick}\n                role={role}\n                tabIndex={0}\n            >\n                {(state, childrenProps) => {\n                    const {pressed, hovered, focused} = state;\n\n                    const defaultStyle = [\n                        styles.itemContainer,\n                        pressed\n                            ? styles.active\n                            : (hovered || focused) && styles.focus,\n                        disabled && styles.disabled,\n                        // pass optional styles from react-window (if applies)\n                        style,\n                    ];\n\n                    return (\n                        <View\n                            {...sharedProps}\n                            testId={testId}\n                            style={defaultStyle}\n                            aria-selected={selected ? \"true\" : \"false\"}\n                            role={role}\n                            {...childrenProps}\n                        >\n                            <CheckComponent\n                                disabled={disabled}\n                                selected={selected}\n                                pressed={pressed}\n                                hovered={hovered}\n                                focused={focused}\n                            />\n                            <LabelMedium style={styles.label}>\n                                {label}\n                            </LabelMedium>\n                        </View>\n                    );\n                }}\n            </ClickableBehavior>\n        );\n    }\n}\n\nconst {blue, white, offBlack, offBlack32} = Color;\n\nconst styles = StyleSheet.create({\n    itemContainer: {\n        flexDirection: \"row\",\n        background: white,\n        color: offBlack,\n        alignItems: \"center\",\n        height: DROPDOWN_ITEM_HEIGHT,\n        minHeight: DROPDOWN_ITEM_HEIGHT,\n        border: 0,\n        outline: 0,\n        paddingLeft: Spacing.xSmall_8,\n        paddingRight: Spacing.medium_16,\n        whiteSpace: \"nowrap\",\n        cursor: \"default\",\n    },\n\n    focus: {\n        color: white,\n        background: blue,\n    },\n\n    active: {\n        color: mix(fade(blue, 0.32), white),\n        background: mix(offBlack32, blue),\n    },\n\n    disabled: {\n        color: offBlack32,\n        background: white,\n    },\n\n    label: {\n        whiteSpace: \"nowrap\",\n        userSelect: \"none\",\n        marginLeft: Spacing.xSmall_8,\n        // added to truncate strings that are longer than expected\n        overflow: \"hidden\",\n        textOverflow: \"ellipsis\",\n    },\n\n    hide: {\n        visibility: \"hidden\",\n    },\n});\n","// Separator item in a dropdown, used to denote a semantic break.\n// Actualized as a horizontal line with surrounding whitespace. -----\n\nimport * as React from \"react\";\nimport {StyleSheet} from \"aphrodite\";\n\nimport Color from \"@khanacademy/wonder-blocks-color\";\nimport Spacing from \"@khanacademy/wonder-blocks-spacing\";\nimport {View} from \"@khanacademy/wonder-blocks-core\";\n\nimport type {StyleType} from \"@khanacademy/wonder-blocks-core\";\n\n/**\n * A separator used in a dropdown menu.\n */\nexport default class SeparatorItem extends React.Component<{\n    /**\n     * In case we use react-window, this needs to be added in order to inject\n     * styles to calculate the position\n     * @ignore\n     */\n    style?: StyleType;\n}> {\n    static isClassOf(instance: React.ReactElement<any>): boolean {\n        // @ts-expect-error [FEI-5019] - TS2339 - Property '__IS_SEPARATOR_ITEM__' does not exist on type 'string | JSXElementConstructor<any>'.\n        return instance && instance.type && instance.type.__IS_SEPARATOR_ITEM__;\n    }\n\n    static __IS_SEPARATOR_ITEM__ = true;\n\n    render(): React.ReactNode {\n        return (\n            // pass optional styles from react-window (if applies)\n            <View\n                style={[styles.separator, this.props.style]}\n                aria-hidden=\"true\"\n            />\n        );\n    }\n}\n\nconst styles = StyleSheet.create({\n    separator: {\n        boxShadow: `0 -1px ${Color.offBlack16}`,\n        height: 1,\n        minHeight: 1,\n        marginTop: Spacing.xxxSmall_4,\n        marginBottom: Spacing.xxxSmall_4,\n    },\n});\n","import * as React from \"react\";\n\nimport {ClickableBehavior} from \"@khanacademy/wonder-blocks-clickable\";\n\nimport type {AriaProps} from \"@khanacademy/wonder-blocks-core\";\nimport type {\n    ChildrenProps,\n    ClickableState,\n} from \"@khanacademy/wonder-blocks-clickable\";\n\nimport type {OpenerProps} from \"../util/types\";\n\ntype Props = Partial<Omit<AriaProps, \"aria-disabled\">> & {\n    /**\n     * The child function that returns the anchor the Dropdown will be activated\n     * by. This function takes two arguments:\n     *\n     * - `eventState`: allows the opener element to access pointer event state.\n     * - `text`: Passes the menu's text/label defined in the parent component.\n     */\n    children: (openerProps: OpenerProps) => React.ReactElement<any>;\n    /**\n     * Whether the opener is disabled. If disabled, disallows interaction.\n     */\n    disabled: boolean;\n    /**\n     * Callback for when the opener is pressed.\n     */\n    onClick: (e: React.SyntheticEvent) => unknown;\n    /**\n     * Test ID used for e2e testing.\n     */\n    testId?: string;\n    /**\n     * Text for the opener that can be passed to the child as an argument.\n     */\n    text: string;\n};\n\ntype DefaultProps = {\n    disabled: Props[\"disabled\"];\n};\n\nclass DropdownOpener extends React.Component<Props> {\n    static defaultProps: DefaultProps = {\n        disabled: false,\n    };\n\n    getTestIdFromProps: (childrenProps?: any) => string = (childrenProps) => {\n        return childrenProps.testId || childrenProps[\"data-test-id\"];\n    };\n\n    renderAnchorChildren(\n        eventState: ClickableState,\n        clickableChildrenProps: ChildrenProps,\n    ): React.ReactElement {\n        const {disabled, testId, text} = this.props;\n        const renderedChildren = this.props.children({...eventState, text});\n        const childrenProps = renderedChildren.props;\n        const childrenTestId = this.getTestIdFromProps(childrenProps);\n\n        return React.cloneElement(renderedChildren, {\n            ...clickableChildrenProps,\n            disabled,\n            onClick: childrenProps.onClick\n                ? (e: React.MouseEvent) => {\n                      // This is done to avoid overriding a\n                      // custom onClick handler inside the\n                      // children node\n                      childrenProps.onClick(e);\n                      clickableChildrenProps.onClick(e);\n                  }\n                : clickableChildrenProps.onClick,\n            // try to get the testId from the child element\n            // If it's not set, try to fallback to the parent's testId\n            \"data-test-id\": childrenTestId || testId,\n        });\n    }\n\n    render(): React.ReactNode {\n        return (\n            <ClickableBehavior\n                onClick={this.props.onClick}\n                disabled={this.props.disabled}\n            >\n                {(eventState, handlers) =>\n                    this.renderAnchorChildren(eventState, handlers)\n                }\n            </ClickableBehavior>\n        );\n    }\n}\n\nexport default DropdownOpener;\n","function areInputsEqual(newInputs, lastInputs) {\n    if (newInputs.length !== lastInputs.length) {\n        return false;\n    }\n    for (var i = 0; i < newInputs.length; i++) {\n        if (newInputs[i] !== lastInputs[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction memoizeOne(resultFn, isEqual) {\n    if (isEqual === void 0) { isEqual = areInputsEqual; }\n    var lastThis;\n    var lastArgs = [];\n    var lastResult;\n    var calledOnce = false;\n    function memoized() {\n        var newArgs = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            newArgs[_i] = arguments[_i];\n        }\n        if (calledOnce && lastThis === this && isEqual(newArgs, lastArgs)) {\n            return lastResult;\n        }\n        lastResult = resultFn.apply(this, newArgs);\n        calledOnce = true;\n        lastThis = this;\n        lastArgs = newArgs;\n        return lastResult;\n    }\n    return memoized;\n}\n\nexport default memoizeOne;\n","import _extends from '@babel/runtime/helpers/esm/extends';\nimport _assertThisInitialized from '@babel/runtime/helpers/esm/assertThisInitialized';\nimport _inheritsLoose from '@babel/runtime/helpers/esm/inheritsLoose';\nimport memoizeOne from 'memoize-one';\nimport { createElement, PureComponent } from 'react';\nimport _objectWithoutPropertiesLoose from '@babel/runtime/helpers/esm/objectWithoutPropertiesLoose';\n\n// Animation frame based implementation of setTimeout.\n// Inspired by Joe Lambert, https://gist.github.com/joelambert/1002116#file-requesttimeout-js\nvar hasNativePerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';\nvar now = hasNativePerformanceNow ? function () {\n  return performance.now();\n} : function () {\n  return Date.now();\n};\nfunction cancelTimeout(timeoutID) {\n  cancelAnimationFrame(timeoutID.id);\n}\nfunction requestTimeout(callback, delay) {\n  var start = now();\n\n  function tick() {\n    if (now() - start >= delay) {\n      callback.call(null);\n    } else {\n      timeoutID.id = requestAnimationFrame(tick);\n    }\n  }\n\n  var timeoutID = {\n    id: requestAnimationFrame(tick)\n  };\n  return timeoutID;\n}\n\nvar size = -1; // This utility copied from \"dom-helpers\" package.\n\nfunction getScrollbarSize(recalculate) {\n  if (recalculate === void 0) {\n    recalculate = false;\n  }\n\n  if (size === -1 || recalculate) {\n    var div = document.createElement('div');\n    var style = div.style;\n    style.width = '50px';\n    style.height = '50px';\n    style.overflow = 'scroll';\n    document.body.appendChild(div);\n    size = div.offsetWidth - div.clientWidth;\n    document.body.removeChild(div);\n  }\n\n  return size;\n}\nvar cachedRTLResult = null; // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n// Chrome does not seem to adhere; its scrollLeft values are positive (measured relative to the left).\n// Safari's elastic bounce makes detecting this even more complicated wrt potential false positives.\n// The safest way to check this is to intentionally set a negative offset,\n// and then verify that the subsequent \"scroll\" event matches the negative offset.\n// If it does not match, then we can assume a non-standard RTL scroll implementation.\n\nfunction getRTLOffsetType(recalculate) {\n  if (recalculate === void 0) {\n    recalculate = false;\n  }\n\n  if (cachedRTLResult === null || recalculate) {\n    var outerDiv = document.createElement('div');\n    var outerStyle = outerDiv.style;\n    outerStyle.width = '50px';\n    outerStyle.height = '50px';\n    outerStyle.overflow = 'scroll';\n    outerStyle.direction = 'rtl';\n    var innerDiv = document.createElement('div');\n    var innerStyle = innerDiv.style;\n    innerStyle.width = '100px';\n    innerStyle.height = '100px';\n    outerDiv.appendChild(innerDiv);\n    document.body.appendChild(outerDiv);\n\n    if (outerDiv.scrollLeft > 0) {\n      cachedRTLResult = 'positive-descending';\n    } else {\n      outerDiv.scrollLeft = 1;\n\n      if (outerDiv.scrollLeft === 0) {\n        cachedRTLResult = 'negative';\n      } else {\n        cachedRTLResult = 'positive-ascending';\n      }\n    }\n\n    document.body.removeChild(outerDiv);\n    return cachedRTLResult;\n  }\n\n  return cachedRTLResult;\n}\n\nvar IS_SCROLLING_DEBOUNCE_INTERVAL = 150;\n\nvar defaultItemKey = function defaultItemKey(_ref) {\n  var columnIndex = _ref.columnIndex,\n      data = _ref.data,\n      rowIndex = _ref.rowIndex;\n  return rowIndex + \":\" + columnIndex;\n}; // In DEV mode, this Set helps us only log a warning once per component instance.\n// This avoids spamming the console every time a render happens.\n\n\nvar devWarningsOverscanCount = null;\nvar devWarningsOverscanRowsColumnsCount = null;\nvar devWarningsTagName = null;\n\nif (process.env.NODE_ENV !== 'production') {\n  if (typeof window !== 'undefined' && typeof window.WeakSet !== 'undefined') {\n    devWarningsOverscanCount = /*#__PURE__*/new WeakSet();\n    devWarningsOverscanRowsColumnsCount = /*#__PURE__*/new WeakSet();\n    devWarningsTagName = /*#__PURE__*/new WeakSet();\n  }\n}\n\nfunction createGridComponent(_ref2) {\n  var _class;\n\n  var getColumnOffset = _ref2.getColumnOffset,\n      getColumnStartIndexForOffset = _ref2.getColumnStartIndexForOffset,\n      getColumnStopIndexForStartIndex = _ref2.getColumnStopIndexForStartIndex,\n      getColumnWidth = _ref2.getColumnWidth,\n      getEstimatedTotalHeight = _ref2.getEstimatedTotalHeight,\n      getEstimatedTotalWidth = _ref2.getEstimatedTotalWidth,\n      getOffsetForColumnAndAlignment = _ref2.getOffsetForColumnAndAlignment,\n      getOffsetForRowAndAlignment = _ref2.getOffsetForRowAndAlignment,\n      getRowHeight = _ref2.getRowHeight,\n      getRowOffset = _ref2.getRowOffset,\n      getRowStartIndexForOffset = _ref2.getRowStartIndexForOffset,\n      getRowStopIndexForStartIndex = _ref2.getRowStopIndexForStartIndex,\n      initInstanceProps = _ref2.initInstanceProps,\n      shouldResetStyleCacheOnItemSizeChange = _ref2.shouldResetStyleCacheOnItemSizeChange,\n      validateProps = _ref2.validateProps;\n  return _class = /*#__PURE__*/function (_PureComponent) {\n    _inheritsLoose(Grid, _PureComponent);\n\n    // Always use explicit constructor for React components.\n    // It produces less code after transpilation. (#26)\n    // eslint-disable-next-line no-useless-constructor\n    function Grid(props) {\n      var _this;\n\n      _this = _PureComponent.call(this, props) || this;\n      _this._instanceProps = initInstanceProps(_this.props, _assertThisInitialized(_this));\n      _this._resetIsScrollingTimeoutId = null;\n      _this._outerRef = void 0;\n      _this.state = {\n        instance: _assertThisInitialized(_this),\n        isScrolling: false,\n        horizontalScrollDirection: 'forward',\n        scrollLeft: typeof _this.props.initialScrollLeft === 'number' ? _this.props.initialScrollLeft : 0,\n        scrollTop: typeof _this.props.initialScrollTop === 'number' ? _this.props.initialScrollTop : 0,\n        scrollUpdateWasRequested: false,\n        verticalScrollDirection: 'forward'\n      };\n      _this._callOnItemsRendered = void 0;\n      _this._callOnItemsRendered = memoizeOne(function (overscanColumnStartIndex, overscanColumnStopIndex, overscanRowStartIndex, overscanRowStopIndex, visibleColumnStartIndex, visibleColumnStopIndex, visibleRowStartIndex, visibleRowStopIndex) {\n        return _this.props.onItemsRendered({\n          overscanColumnStartIndex: overscanColumnStartIndex,\n          overscanColumnStopIndex: overscanColumnStopIndex,\n          overscanRowStartIndex: overscanRowStartIndex,\n          overscanRowStopIndex: overscanRowStopIndex,\n          visibleColumnStartIndex: visibleColumnStartIndex,\n          visibleColumnStopIndex: visibleColumnStopIndex,\n          visibleRowStartIndex: visibleRowStartIndex,\n          visibleRowStopIndex: visibleRowStopIndex\n        });\n      });\n      _this._callOnScroll = void 0;\n      _this._callOnScroll = memoizeOne(function (scrollLeft, scrollTop, horizontalScrollDirection, verticalScrollDirection, scrollUpdateWasRequested) {\n        return _this.props.onScroll({\n          horizontalScrollDirection: horizontalScrollDirection,\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop,\n          verticalScrollDirection: verticalScrollDirection,\n          scrollUpdateWasRequested: scrollUpdateWasRequested\n        });\n      });\n      _this._getItemStyle = void 0;\n\n      _this._getItemStyle = function (rowIndex, columnIndex) {\n        var _this$props = _this.props,\n            columnWidth = _this$props.columnWidth,\n            direction = _this$props.direction,\n            rowHeight = _this$props.rowHeight;\n\n        var itemStyleCache = _this._getItemStyleCache(shouldResetStyleCacheOnItemSizeChange && columnWidth, shouldResetStyleCacheOnItemSizeChange && direction, shouldResetStyleCacheOnItemSizeChange && rowHeight);\n\n        var key = rowIndex + \":\" + columnIndex;\n        var style;\n\n        if (itemStyleCache.hasOwnProperty(key)) {\n          style = itemStyleCache[key];\n        } else {\n          var _offset = getColumnOffset(_this.props, columnIndex, _this._instanceProps);\n\n          var isRtl = direction === 'rtl';\n          itemStyleCache[key] = style = {\n            position: 'absolute',\n            left: isRtl ? undefined : _offset,\n            right: isRtl ? _offset : undefined,\n            top: getRowOffset(_this.props, rowIndex, _this._instanceProps),\n            height: getRowHeight(_this.props, rowIndex, _this._instanceProps),\n            width: getColumnWidth(_this.props, columnIndex, _this._instanceProps)\n          };\n        }\n\n        return style;\n      };\n\n      _this._getItemStyleCache = void 0;\n      _this._getItemStyleCache = memoizeOne(function (_, __, ___) {\n        return {};\n      });\n\n      _this._onScroll = function (event) {\n        var _event$currentTarget = event.currentTarget,\n            clientHeight = _event$currentTarget.clientHeight,\n            clientWidth = _event$currentTarget.clientWidth,\n            scrollLeft = _event$currentTarget.scrollLeft,\n            scrollTop = _event$currentTarget.scrollTop,\n            scrollHeight = _event$currentTarget.scrollHeight,\n            scrollWidth = _event$currentTarget.scrollWidth;\n\n        _this.setState(function (prevState) {\n          if (prevState.scrollLeft === scrollLeft && prevState.scrollTop === scrollTop) {\n            // Scroll position may have been updated by cDM/cDU,\n            // In which case we don't need to trigger another render,\n            // And we don't want to update state.isScrolling.\n            return null;\n          }\n\n          var direction = _this.props.direction; // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n          // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n          // It's also easier for this component if we convert offsets to the same format as they would be in for ltr.\n          // So the simplest solution is to determine which browser behavior we're dealing with, and convert based on it.\n\n          var calculatedScrollLeft = scrollLeft;\n\n          if (direction === 'rtl') {\n            switch (getRTLOffsetType()) {\n              case 'negative':\n                calculatedScrollLeft = -scrollLeft;\n                break;\n\n              case 'positive-descending':\n                calculatedScrollLeft = scrollWidth - clientWidth - scrollLeft;\n                break;\n            }\n          } // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n\n\n          calculatedScrollLeft = Math.max(0, Math.min(calculatedScrollLeft, scrollWidth - clientWidth));\n          var calculatedScrollTop = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));\n          return {\n            isScrolling: true,\n            horizontalScrollDirection: prevState.scrollLeft < scrollLeft ? 'forward' : 'backward',\n            scrollLeft: calculatedScrollLeft,\n            scrollTop: calculatedScrollTop,\n            verticalScrollDirection: prevState.scrollTop < scrollTop ? 'forward' : 'backward',\n            scrollUpdateWasRequested: false\n          };\n        }, _this._resetIsScrollingDebounced);\n      };\n\n      _this._outerRefSetter = function (ref) {\n        var outerRef = _this.props.outerRef;\n        _this._outerRef = ref;\n\n        if (typeof outerRef === 'function') {\n          outerRef(ref);\n        } else if (outerRef != null && typeof outerRef === 'object' && outerRef.hasOwnProperty('current')) {\n          outerRef.current = ref;\n        }\n      };\n\n      _this._resetIsScrollingDebounced = function () {\n        if (_this._resetIsScrollingTimeoutId !== null) {\n          cancelTimeout(_this._resetIsScrollingTimeoutId);\n        }\n\n        _this._resetIsScrollingTimeoutId = requestTimeout(_this._resetIsScrolling, IS_SCROLLING_DEBOUNCE_INTERVAL);\n      };\n\n      _this._resetIsScrolling = function () {\n        _this._resetIsScrollingTimeoutId = null;\n\n        _this.setState({\n          isScrolling: false\n        }, function () {\n          // Clear style cache after state update has been committed.\n          // This way we don't break pure sCU for items that don't use isScrolling param.\n          _this._getItemStyleCache(-1);\n        });\n      };\n\n      return _this;\n    }\n\n    Grid.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {\n      validateSharedProps(nextProps, prevState);\n      validateProps(nextProps);\n      return null;\n    };\n\n    var _proto = Grid.prototype;\n\n    _proto.scrollTo = function scrollTo(_ref3) {\n      var scrollLeft = _ref3.scrollLeft,\n          scrollTop = _ref3.scrollTop;\n\n      if (scrollLeft !== undefined) {\n        scrollLeft = Math.max(0, scrollLeft);\n      }\n\n      if (scrollTop !== undefined) {\n        scrollTop = Math.max(0, scrollTop);\n      }\n\n      this.setState(function (prevState) {\n        if (scrollLeft === undefined) {\n          scrollLeft = prevState.scrollLeft;\n        }\n\n        if (scrollTop === undefined) {\n          scrollTop = prevState.scrollTop;\n        }\n\n        if (prevState.scrollLeft === scrollLeft && prevState.scrollTop === scrollTop) {\n          return null;\n        }\n\n        return {\n          horizontalScrollDirection: prevState.scrollLeft < scrollLeft ? 'forward' : 'backward',\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop,\n          scrollUpdateWasRequested: true,\n          verticalScrollDirection: prevState.scrollTop < scrollTop ? 'forward' : 'backward'\n        };\n      }, this._resetIsScrollingDebounced);\n    };\n\n    _proto.scrollToItem = function scrollToItem(_ref4) {\n      var _ref4$align = _ref4.align,\n          align = _ref4$align === void 0 ? 'auto' : _ref4$align,\n          columnIndex = _ref4.columnIndex,\n          rowIndex = _ref4.rowIndex;\n      var _this$props2 = this.props,\n          columnCount = _this$props2.columnCount,\n          height = _this$props2.height,\n          rowCount = _this$props2.rowCount,\n          width = _this$props2.width;\n      var _this$state = this.state,\n          scrollLeft = _this$state.scrollLeft,\n          scrollTop = _this$state.scrollTop;\n      var scrollbarSize = getScrollbarSize();\n\n      if (columnIndex !== undefined) {\n        columnIndex = Math.max(0, Math.min(columnIndex, columnCount - 1));\n      }\n\n      if (rowIndex !== undefined) {\n        rowIndex = Math.max(0, Math.min(rowIndex, rowCount - 1));\n      }\n\n      var estimatedTotalHeight = getEstimatedTotalHeight(this.props, this._instanceProps);\n      var estimatedTotalWidth = getEstimatedTotalWidth(this.props, this._instanceProps); // The scrollbar size should be considered when scrolling an item into view,\n      // to ensure it's fully visible.\n      // But we only need to account for its size when it's actually visible.\n\n      var horizontalScrollbarSize = estimatedTotalWidth > width ? scrollbarSize : 0;\n      var verticalScrollbarSize = estimatedTotalHeight > height ? scrollbarSize : 0;\n      this.scrollTo({\n        scrollLeft: columnIndex !== undefined ? getOffsetForColumnAndAlignment(this.props, columnIndex, align, scrollLeft, this._instanceProps, verticalScrollbarSize) : scrollLeft,\n        scrollTop: rowIndex !== undefined ? getOffsetForRowAndAlignment(this.props, rowIndex, align, scrollTop, this._instanceProps, horizontalScrollbarSize) : scrollTop\n      });\n    };\n\n    _proto.componentDidMount = function componentDidMount() {\n      var _this$props3 = this.props,\n          initialScrollLeft = _this$props3.initialScrollLeft,\n          initialScrollTop = _this$props3.initialScrollTop;\n\n      if (this._outerRef != null) {\n        var outerRef = this._outerRef;\n\n        if (typeof initialScrollLeft === 'number') {\n          outerRef.scrollLeft = initialScrollLeft;\n        }\n\n        if (typeof initialScrollTop === 'number') {\n          outerRef.scrollTop = initialScrollTop;\n        }\n      }\n\n      this._callPropsCallbacks();\n    };\n\n    _proto.componentDidUpdate = function componentDidUpdate() {\n      var direction = this.props.direction;\n      var _this$state2 = this.state,\n          scrollLeft = _this$state2.scrollLeft,\n          scrollTop = _this$state2.scrollTop,\n          scrollUpdateWasRequested = _this$state2.scrollUpdateWasRequested;\n\n      if (scrollUpdateWasRequested && this._outerRef != null) {\n        // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n        // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n        // So we need to determine which browser behavior we're dealing with, and mimic it.\n        var outerRef = this._outerRef;\n\n        if (direction === 'rtl') {\n          switch (getRTLOffsetType()) {\n            case 'negative':\n              outerRef.scrollLeft = -scrollLeft;\n              break;\n\n            case 'positive-ascending':\n              outerRef.scrollLeft = scrollLeft;\n              break;\n\n            default:\n              var clientWidth = outerRef.clientWidth,\n                  scrollWidth = outerRef.scrollWidth;\n              outerRef.scrollLeft = scrollWidth - clientWidth - scrollLeft;\n              break;\n          }\n        } else {\n          outerRef.scrollLeft = Math.max(0, scrollLeft);\n        }\n\n        outerRef.scrollTop = Math.max(0, scrollTop);\n      }\n\n      this._callPropsCallbacks();\n    };\n\n    _proto.componentWillUnmount = function componentWillUnmount() {\n      if (this._resetIsScrollingTimeoutId !== null) {\n        cancelTimeout(this._resetIsScrollingTimeoutId);\n      }\n    };\n\n    _proto.render = function render() {\n      var _this$props4 = this.props,\n          children = _this$props4.children,\n          className = _this$props4.className,\n          columnCount = _this$props4.columnCount,\n          direction = _this$props4.direction,\n          height = _this$props4.height,\n          innerRef = _this$props4.innerRef,\n          innerElementType = _this$props4.innerElementType,\n          innerTagName = _this$props4.innerTagName,\n          itemData = _this$props4.itemData,\n          _this$props4$itemKey = _this$props4.itemKey,\n          itemKey = _this$props4$itemKey === void 0 ? defaultItemKey : _this$props4$itemKey,\n          outerElementType = _this$props4.outerElementType,\n          outerTagName = _this$props4.outerTagName,\n          rowCount = _this$props4.rowCount,\n          style = _this$props4.style,\n          useIsScrolling = _this$props4.useIsScrolling,\n          width = _this$props4.width;\n      var isScrolling = this.state.isScrolling;\n\n      var _this$_getHorizontalR = this._getHorizontalRangeToRender(),\n          columnStartIndex = _this$_getHorizontalR[0],\n          columnStopIndex = _this$_getHorizontalR[1];\n\n      var _this$_getVerticalRan = this._getVerticalRangeToRender(),\n          rowStartIndex = _this$_getVerticalRan[0],\n          rowStopIndex = _this$_getVerticalRan[1];\n\n      var items = [];\n\n      if (columnCount > 0 && rowCount) {\n        for (var _rowIndex = rowStartIndex; _rowIndex <= rowStopIndex; _rowIndex++) {\n          for (var _columnIndex = columnStartIndex; _columnIndex <= columnStopIndex; _columnIndex++) {\n            items.push(createElement(children, {\n              columnIndex: _columnIndex,\n              data: itemData,\n              isScrolling: useIsScrolling ? isScrolling : undefined,\n              key: itemKey({\n                columnIndex: _columnIndex,\n                data: itemData,\n                rowIndex: _rowIndex\n              }),\n              rowIndex: _rowIndex,\n              style: this._getItemStyle(_rowIndex, _columnIndex)\n            }));\n          }\n        }\n      } // Read this value AFTER items have been created,\n      // So their actual sizes (if variable) are taken into consideration.\n\n\n      var estimatedTotalHeight = getEstimatedTotalHeight(this.props, this._instanceProps);\n      var estimatedTotalWidth = getEstimatedTotalWidth(this.props, this._instanceProps);\n      return createElement(outerElementType || outerTagName || 'div', {\n        className: className,\n        onScroll: this._onScroll,\n        ref: this._outerRefSetter,\n        style: _extends({\n          position: 'relative',\n          height: height,\n          width: width,\n          overflow: 'auto',\n          WebkitOverflowScrolling: 'touch',\n          willChange: 'transform',\n          direction: direction\n        }, style)\n      }, createElement(innerElementType || innerTagName || 'div', {\n        children: items,\n        ref: innerRef,\n        style: {\n          height: estimatedTotalHeight,\n          pointerEvents: isScrolling ? 'none' : undefined,\n          width: estimatedTotalWidth\n        }\n      }));\n    };\n\n    _proto._callPropsCallbacks = function _callPropsCallbacks() {\n      var _this$props5 = this.props,\n          columnCount = _this$props5.columnCount,\n          onItemsRendered = _this$props5.onItemsRendered,\n          onScroll = _this$props5.onScroll,\n          rowCount = _this$props5.rowCount;\n\n      if (typeof onItemsRendered === 'function') {\n        if (columnCount > 0 && rowCount > 0) {\n          var _this$_getHorizontalR2 = this._getHorizontalRangeToRender(),\n              _overscanColumnStartIndex = _this$_getHorizontalR2[0],\n              _overscanColumnStopIndex = _this$_getHorizontalR2[1],\n              _visibleColumnStartIndex = _this$_getHorizontalR2[2],\n              _visibleColumnStopIndex = _this$_getHorizontalR2[3];\n\n          var _this$_getVerticalRan2 = this._getVerticalRangeToRender(),\n              _overscanRowStartIndex = _this$_getVerticalRan2[0],\n              _overscanRowStopIndex = _this$_getVerticalRan2[1],\n              _visibleRowStartIndex = _this$_getVerticalRan2[2],\n              _visibleRowStopIndex = _this$_getVerticalRan2[3];\n\n          this._callOnItemsRendered(_overscanColumnStartIndex, _overscanColumnStopIndex, _overscanRowStartIndex, _overscanRowStopIndex, _visibleColumnStartIndex, _visibleColumnStopIndex, _visibleRowStartIndex, _visibleRowStopIndex);\n        }\n      }\n\n      if (typeof onScroll === 'function') {\n        var _this$state3 = this.state,\n            _horizontalScrollDirection = _this$state3.horizontalScrollDirection,\n            _scrollLeft = _this$state3.scrollLeft,\n            _scrollTop = _this$state3.scrollTop,\n            _scrollUpdateWasRequested = _this$state3.scrollUpdateWasRequested,\n            _verticalScrollDirection = _this$state3.verticalScrollDirection;\n\n        this._callOnScroll(_scrollLeft, _scrollTop, _horizontalScrollDirection, _verticalScrollDirection, _scrollUpdateWasRequested);\n      }\n    } // Lazily create and cache item styles while scrolling,\n    // So that pure component sCU will prevent re-renders.\n    // We maintain this cache, and pass a style prop rather than index,\n    // So that List can clear cached styles and force item re-render if necessary.\n    ;\n\n    _proto._getHorizontalRangeToRender = function _getHorizontalRangeToRender() {\n      var _this$props6 = this.props,\n          columnCount = _this$props6.columnCount,\n          overscanColumnCount = _this$props6.overscanColumnCount,\n          overscanColumnsCount = _this$props6.overscanColumnsCount,\n          overscanCount = _this$props6.overscanCount,\n          rowCount = _this$props6.rowCount;\n      var _this$state4 = this.state,\n          horizontalScrollDirection = _this$state4.horizontalScrollDirection,\n          isScrolling = _this$state4.isScrolling,\n          scrollLeft = _this$state4.scrollLeft;\n      var overscanCountResolved = overscanColumnCount || overscanColumnsCount || overscanCount || 1;\n\n      if (columnCount === 0 || rowCount === 0) {\n        return [0, 0, 0, 0];\n      }\n\n      var startIndex = getColumnStartIndexForOffset(this.props, scrollLeft, this._instanceProps);\n      var stopIndex = getColumnStopIndexForStartIndex(this.props, startIndex, scrollLeft, this._instanceProps); // Overscan by one item in each direction so that tab/focus works.\n      // If there isn't at least one extra item, tab loops back around.\n\n      var overscanBackward = !isScrolling || horizontalScrollDirection === 'backward' ? Math.max(1, overscanCountResolved) : 1;\n      var overscanForward = !isScrolling || horizontalScrollDirection === 'forward' ? Math.max(1, overscanCountResolved) : 1;\n      return [Math.max(0, startIndex - overscanBackward), Math.max(0, Math.min(columnCount - 1, stopIndex + overscanForward)), startIndex, stopIndex];\n    };\n\n    _proto._getVerticalRangeToRender = function _getVerticalRangeToRender() {\n      var _this$props7 = this.props,\n          columnCount = _this$props7.columnCount,\n          overscanCount = _this$props7.overscanCount,\n          overscanRowCount = _this$props7.overscanRowCount,\n          overscanRowsCount = _this$props7.overscanRowsCount,\n          rowCount = _this$props7.rowCount;\n      var _this$state5 = this.state,\n          isScrolling = _this$state5.isScrolling,\n          verticalScrollDirection = _this$state5.verticalScrollDirection,\n          scrollTop = _this$state5.scrollTop;\n      var overscanCountResolved = overscanRowCount || overscanRowsCount || overscanCount || 1;\n\n      if (columnCount === 0 || rowCount === 0) {\n        return [0, 0, 0, 0];\n      }\n\n      var startIndex = getRowStartIndexForOffset(this.props, scrollTop, this._instanceProps);\n      var stopIndex = getRowStopIndexForStartIndex(this.props, startIndex, scrollTop, this._instanceProps); // Overscan by one item in each direction so that tab/focus works.\n      // If there isn't at least one extra item, tab loops back around.\n\n      var overscanBackward = !isScrolling || verticalScrollDirection === 'backward' ? Math.max(1, overscanCountResolved) : 1;\n      var overscanForward = !isScrolling || verticalScrollDirection === 'forward' ? Math.max(1, overscanCountResolved) : 1;\n      return [Math.max(0, startIndex - overscanBackward), Math.max(0, Math.min(rowCount - 1, stopIndex + overscanForward)), startIndex, stopIndex];\n    };\n\n    return Grid;\n  }(PureComponent), _class.defaultProps = {\n    direction: 'ltr',\n    itemData: undefined,\n    useIsScrolling: false\n  }, _class;\n}\n\nvar validateSharedProps = function validateSharedProps(_ref5, _ref6) {\n  var children = _ref5.children,\n      direction = _ref5.direction,\n      height = _ref5.height,\n      innerTagName = _ref5.innerTagName,\n      outerTagName = _ref5.outerTagName,\n      overscanColumnsCount = _ref5.overscanColumnsCount,\n      overscanCount = _ref5.overscanCount,\n      overscanRowsCount = _ref5.overscanRowsCount,\n      width = _ref5.width;\n  var instance = _ref6.instance;\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (typeof overscanCount === 'number') {\n      if (devWarningsOverscanCount && !devWarningsOverscanCount.has(instance)) {\n        devWarningsOverscanCount.add(instance);\n        console.warn('The overscanCount prop has been deprecated. ' + 'Please use the overscanColumnCount and overscanRowCount props instead.');\n      }\n    }\n\n    if (typeof overscanColumnsCount === 'number' || typeof overscanRowsCount === 'number') {\n      if (devWarningsOverscanRowsColumnsCount && !devWarningsOverscanRowsColumnsCount.has(instance)) {\n        devWarningsOverscanRowsColumnsCount.add(instance);\n        console.warn('The overscanColumnsCount and overscanRowsCount props have been deprecated. ' + 'Please use the overscanColumnCount and overscanRowCount props instead.');\n      }\n    }\n\n    if (innerTagName != null || outerTagName != null) {\n      if (devWarningsTagName && !devWarningsTagName.has(instance)) {\n        devWarningsTagName.add(instance);\n        console.warn('The innerTagName and outerTagName props have been deprecated. ' + 'Please use the innerElementType and outerElementType props instead.');\n      }\n    }\n\n    if (children == null) {\n      throw Error('An invalid \"children\" prop has been specified. ' + 'Value should be a React component. ' + (\"\\\"\" + (children === null ? 'null' : typeof children) + \"\\\" was specified.\"));\n    }\n\n    switch (direction) {\n      case 'ltr':\n      case 'rtl':\n        // Valid values\n        break;\n\n      default:\n        throw Error('An invalid \"direction\" prop has been specified. ' + 'Value should be either \"ltr\" or \"rtl\". ' + (\"\\\"\" + direction + \"\\\" was specified.\"));\n    }\n\n    if (typeof width !== 'number') {\n      throw Error('An invalid \"width\" prop has been specified. ' + 'Grids must specify a number for width. ' + (\"\\\"\" + (width === null ? 'null' : typeof width) + \"\\\" was specified.\"));\n    }\n\n    if (typeof height !== 'number') {\n      throw Error('An invalid \"height\" prop has been specified. ' + 'Grids must specify a number for height. ' + (\"\\\"\" + (height === null ? 'null' : typeof height) + \"\\\" was specified.\"));\n    }\n  }\n};\n\nvar DEFAULT_ESTIMATED_ITEM_SIZE = 50;\n\nvar getEstimatedTotalHeight = function getEstimatedTotalHeight(_ref, _ref2) {\n  var rowCount = _ref.rowCount;\n  var rowMetadataMap = _ref2.rowMetadataMap,\n      estimatedRowHeight = _ref2.estimatedRowHeight,\n      lastMeasuredRowIndex = _ref2.lastMeasuredRowIndex;\n  var totalSizeOfMeasuredRows = 0; // Edge case check for when the number of items decreases while a scroll is in progress.\n  // https://github.com/bvaughn/react-window/pull/138\n\n  if (lastMeasuredRowIndex >= rowCount) {\n    lastMeasuredRowIndex = rowCount - 1;\n  }\n\n  if (lastMeasuredRowIndex >= 0) {\n    var itemMetadata = rowMetadataMap[lastMeasuredRowIndex];\n    totalSizeOfMeasuredRows = itemMetadata.offset + itemMetadata.size;\n  }\n\n  var numUnmeasuredItems = rowCount - lastMeasuredRowIndex - 1;\n  var totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedRowHeight;\n  return totalSizeOfMeasuredRows + totalSizeOfUnmeasuredItems;\n};\n\nvar getEstimatedTotalWidth = function getEstimatedTotalWidth(_ref3, _ref4) {\n  var columnCount = _ref3.columnCount;\n  var columnMetadataMap = _ref4.columnMetadataMap,\n      estimatedColumnWidth = _ref4.estimatedColumnWidth,\n      lastMeasuredColumnIndex = _ref4.lastMeasuredColumnIndex;\n  var totalSizeOfMeasuredRows = 0; // Edge case check for when the number of items decreases while a scroll is in progress.\n  // https://github.com/bvaughn/react-window/pull/138\n\n  if (lastMeasuredColumnIndex >= columnCount) {\n    lastMeasuredColumnIndex = columnCount - 1;\n  }\n\n  if (lastMeasuredColumnIndex >= 0) {\n    var itemMetadata = columnMetadataMap[lastMeasuredColumnIndex];\n    totalSizeOfMeasuredRows = itemMetadata.offset + itemMetadata.size;\n  }\n\n  var numUnmeasuredItems = columnCount - lastMeasuredColumnIndex - 1;\n  var totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedColumnWidth;\n  return totalSizeOfMeasuredRows + totalSizeOfUnmeasuredItems;\n};\n\nvar getItemMetadata = function getItemMetadata(itemType, props, index, instanceProps) {\n  var itemMetadataMap, itemSize, lastMeasuredIndex;\n\n  if (itemType === 'column') {\n    itemMetadataMap = instanceProps.columnMetadataMap;\n    itemSize = props.columnWidth;\n    lastMeasuredIndex = instanceProps.lastMeasuredColumnIndex;\n  } else {\n    itemMetadataMap = instanceProps.rowMetadataMap;\n    itemSize = props.rowHeight;\n    lastMeasuredIndex = instanceProps.lastMeasuredRowIndex;\n  }\n\n  if (index > lastMeasuredIndex) {\n    var offset = 0;\n\n    if (lastMeasuredIndex >= 0) {\n      var itemMetadata = itemMetadataMap[lastMeasuredIndex];\n      offset = itemMetadata.offset + itemMetadata.size;\n    }\n\n    for (var i = lastMeasuredIndex + 1; i <= index; i++) {\n      var size = itemSize(i);\n      itemMetadataMap[i] = {\n        offset: offset,\n        size: size\n      };\n      offset += size;\n    }\n\n    if (itemType === 'column') {\n      instanceProps.lastMeasuredColumnIndex = index;\n    } else {\n      instanceProps.lastMeasuredRowIndex = index;\n    }\n  }\n\n  return itemMetadataMap[index];\n};\n\nvar findNearestItem = function findNearestItem(itemType, props, instanceProps, offset) {\n  var itemMetadataMap, lastMeasuredIndex;\n\n  if (itemType === 'column') {\n    itemMetadataMap = instanceProps.columnMetadataMap;\n    lastMeasuredIndex = instanceProps.lastMeasuredColumnIndex;\n  } else {\n    itemMetadataMap = instanceProps.rowMetadataMap;\n    lastMeasuredIndex = instanceProps.lastMeasuredRowIndex;\n  }\n\n  var lastMeasuredItemOffset = lastMeasuredIndex > 0 ? itemMetadataMap[lastMeasuredIndex].offset : 0;\n\n  if (lastMeasuredItemOffset >= offset) {\n    // If we've already measured items within this range just use a binary search as it's faster.\n    return findNearestItemBinarySearch(itemType, props, instanceProps, lastMeasuredIndex, 0, offset);\n  } else {\n    // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\n    // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\n    // The overall complexity for this approach is O(log n).\n    return findNearestItemExponentialSearch(itemType, props, instanceProps, Math.max(0, lastMeasuredIndex), offset);\n  }\n};\n\nvar findNearestItemBinarySearch = function findNearestItemBinarySearch(itemType, props, instanceProps, high, low, offset) {\n  while (low <= high) {\n    var middle = low + Math.floor((high - low) / 2);\n    var currentOffset = getItemMetadata(itemType, props, middle, instanceProps).offset;\n\n    if (currentOffset === offset) {\n      return middle;\n    } else if (currentOffset < offset) {\n      low = middle + 1;\n    } else if (currentOffset > offset) {\n      high = middle - 1;\n    }\n  }\n\n  if (low > 0) {\n    return low - 1;\n  } else {\n    return 0;\n  }\n};\n\nvar findNearestItemExponentialSearch = function findNearestItemExponentialSearch(itemType, props, instanceProps, index, offset) {\n  var itemCount = itemType === 'column' ? props.columnCount : props.rowCount;\n  var interval = 1;\n\n  while (index < itemCount && getItemMetadata(itemType, props, index, instanceProps).offset < offset) {\n    index += interval;\n    interval *= 2;\n  }\n\n  return findNearestItemBinarySearch(itemType, props, instanceProps, Math.min(index, itemCount - 1), Math.floor(index / 2), offset);\n};\n\nvar getOffsetForIndexAndAlignment = function getOffsetForIndexAndAlignment(itemType, props, index, align, scrollOffset, instanceProps, scrollbarSize) {\n  var size = itemType === 'column' ? props.width : props.height;\n  var itemMetadata = getItemMetadata(itemType, props, index, instanceProps); // Get estimated total size after ItemMetadata is computed,\n  // To ensure it reflects actual measurements instead of just estimates.\n\n  var estimatedTotalSize = itemType === 'column' ? getEstimatedTotalWidth(props, instanceProps) : getEstimatedTotalHeight(props, instanceProps);\n  var maxOffset = Math.max(0, Math.min(estimatedTotalSize - size, itemMetadata.offset));\n  var minOffset = Math.max(0, itemMetadata.offset - size + scrollbarSize + itemMetadata.size);\n\n  if (align === 'smart') {\n    if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n      align = 'auto';\n    } else {\n      align = 'center';\n    }\n  }\n\n  switch (align) {\n    case 'start':\n      return maxOffset;\n\n    case 'end':\n      return minOffset;\n\n    case 'center':\n      return Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n    case 'auto':\n    default:\n      if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n        return scrollOffset;\n      } else if (minOffset > maxOffset) {\n        // Because we only take into account the scrollbar size when calculating minOffset\n        // this value can be larger than maxOffset when at the end of the list\n        return minOffset;\n      } else if (scrollOffset < minOffset) {\n        return minOffset;\n      } else {\n        return maxOffset;\n      }\n\n  }\n};\n\nvar VariableSizeGrid = /*#__PURE__*/createGridComponent({\n  getColumnOffset: function getColumnOffset(props, index, instanceProps) {\n    return getItemMetadata('column', props, index, instanceProps).offset;\n  },\n  getColumnStartIndexForOffset: function getColumnStartIndexForOffset(props, scrollLeft, instanceProps) {\n    return findNearestItem('column', props, instanceProps, scrollLeft);\n  },\n  getColumnStopIndexForStartIndex: function getColumnStopIndexForStartIndex(props, startIndex, scrollLeft, instanceProps) {\n    var columnCount = props.columnCount,\n        width = props.width;\n    var itemMetadata = getItemMetadata('column', props, startIndex, instanceProps);\n    var maxOffset = scrollLeft + width;\n    var offset = itemMetadata.offset + itemMetadata.size;\n    var stopIndex = startIndex;\n\n    while (stopIndex < columnCount - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemMetadata('column', props, stopIndex, instanceProps).size;\n    }\n\n    return stopIndex;\n  },\n  getColumnWidth: function getColumnWidth(props, index, instanceProps) {\n    return instanceProps.columnMetadataMap[index].size;\n  },\n  getEstimatedTotalHeight: getEstimatedTotalHeight,\n  getEstimatedTotalWidth: getEstimatedTotalWidth,\n  getOffsetForColumnAndAlignment: function getOffsetForColumnAndAlignment(props, index, align, scrollOffset, instanceProps, scrollbarSize) {\n    return getOffsetForIndexAndAlignment('column', props, index, align, scrollOffset, instanceProps, scrollbarSize);\n  },\n  getOffsetForRowAndAlignment: function getOffsetForRowAndAlignment(props, index, align, scrollOffset, instanceProps, scrollbarSize) {\n    return getOffsetForIndexAndAlignment('row', props, index, align, scrollOffset, instanceProps, scrollbarSize);\n  },\n  getRowOffset: function getRowOffset(props, index, instanceProps) {\n    return getItemMetadata('row', props, index, instanceProps).offset;\n  },\n  getRowHeight: function getRowHeight(props, index, instanceProps) {\n    return instanceProps.rowMetadataMap[index].size;\n  },\n  getRowStartIndexForOffset: function getRowStartIndexForOffset(props, scrollTop, instanceProps) {\n    return findNearestItem('row', props, instanceProps, scrollTop);\n  },\n  getRowStopIndexForStartIndex: function getRowStopIndexForStartIndex(props, startIndex, scrollTop, instanceProps) {\n    var rowCount = props.rowCount,\n        height = props.height;\n    var itemMetadata = getItemMetadata('row', props, startIndex, instanceProps);\n    var maxOffset = scrollTop + height;\n    var offset = itemMetadata.offset + itemMetadata.size;\n    var stopIndex = startIndex;\n\n    while (stopIndex < rowCount - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemMetadata('row', props, stopIndex, instanceProps).size;\n    }\n\n    return stopIndex;\n  },\n  initInstanceProps: function initInstanceProps(props, instance) {\n    var _ref5 = props,\n        estimatedColumnWidth = _ref5.estimatedColumnWidth,\n        estimatedRowHeight = _ref5.estimatedRowHeight;\n    var instanceProps = {\n      columnMetadataMap: {},\n      estimatedColumnWidth: estimatedColumnWidth || DEFAULT_ESTIMATED_ITEM_SIZE,\n      estimatedRowHeight: estimatedRowHeight || DEFAULT_ESTIMATED_ITEM_SIZE,\n      lastMeasuredColumnIndex: -1,\n      lastMeasuredRowIndex: -1,\n      rowMetadataMap: {}\n    };\n\n    instance.resetAfterColumnIndex = function (columnIndex, shouldForceUpdate) {\n      if (shouldForceUpdate === void 0) {\n        shouldForceUpdate = true;\n      }\n\n      instance.resetAfterIndices({\n        columnIndex: columnIndex,\n        shouldForceUpdate: shouldForceUpdate\n      });\n    };\n\n    instance.resetAfterRowIndex = function (rowIndex, shouldForceUpdate) {\n      if (shouldForceUpdate === void 0) {\n        shouldForceUpdate = true;\n      }\n\n      instance.resetAfterIndices({\n        rowIndex: rowIndex,\n        shouldForceUpdate: shouldForceUpdate\n      });\n    };\n\n    instance.resetAfterIndices = function (_ref6) {\n      var columnIndex = _ref6.columnIndex,\n          rowIndex = _ref6.rowIndex,\n          _ref6$shouldForceUpda = _ref6.shouldForceUpdate,\n          shouldForceUpdate = _ref6$shouldForceUpda === void 0 ? true : _ref6$shouldForceUpda;\n\n      if (typeof columnIndex === 'number') {\n        instanceProps.lastMeasuredColumnIndex = Math.min(instanceProps.lastMeasuredColumnIndex, columnIndex - 1);\n      }\n\n      if (typeof rowIndex === 'number') {\n        instanceProps.lastMeasuredRowIndex = Math.min(instanceProps.lastMeasuredRowIndex, rowIndex - 1);\n      } // We could potentially optimize further by only evicting styles after this index,\n      // But since styles are only cached while scrolling is in progress-\n      // It seems an unnecessary optimization.\n      // It's unlikely that resetAfterIndex() will be called while a user is scrolling.\n\n\n      instance._getItemStyleCache(-1);\n\n      if (shouldForceUpdate) {\n        instance.forceUpdate();\n      }\n    };\n\n    return instanceProps;\n  },\n  shouldResetStyleCacheOnItemSizeChange: false,\n  validateProps: function validateProps(_ref7) {\n    var columnWidth = _ref7.columnWidth,\n        rowHeight = _ref7.rowHeight;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof columnWidth !== 'function') {\n        throw Error('An invalid \"columnWidth\" prop has been specified. ' + 'Value should be a function. ' + (\"\\\"\" + (columnWidth === null ? 'null' : typeof columnWidth) + \"\\\" was specified.\"));\n      } else if (typeof rowHeight !== 'function') {\n        throw Error('An invalid \"rowHeight\" prop has been specified. ' + 'Value should be a function. ' + (\"\\\"\" + (rowHeight === null ? 'null' : typeof rowHeight) + \"\\\" was specified.\"));\n      }\n    }\n  }\n});\n\nvar IS_SCROLLING_DEBOUNCE_INTERVAL$1 = 150;\n\nvar defaultItemKey$1 = function defaultItemKey(index, data) {\n  return index;\n}; // In DEV mode, this Set helps us only log a warning once per component instance.\n// This avoids spamming the console every time a render happens.\n\n\nvar devWarningsDirection = null;\nvar devWarningsTagName$1 = null;\n\nif (process.env.NODE_ENV !== 'production') {\n  if (typeof window !== 'undefined' && typeof window.WeakSet !== 'undefined') {\n    devWarningsDirection = /*#__PURE__*/new WeakSet();\n    devWarningsTagName$1 = /*#__PURE__*/new WeakSet();\n  }\n}\n\nfunction createListComponent(_ref) {\n  var _class;\n\n  var getItemOffset = _ref.getItemOffset,\n      getEstimatedTotalSize = _ref.getEstimatedTotalSize,\n      getItemSize = _ref.getItemSize,\n      getOffsetForIndexAndAlignment = _ref.getOffsetForIndexAndAlignment,\n      getStartIndexForOffset = _ref.getStartIndexForOffset,\n      getStopIndexForStartIndex = _ref.getStopIndexForStartIndex,\n      initInstanceProps = _ref.initInstanceProps,\n      shouldResetStyleCacheOnItemSizeChange = _ref.shouldResetStyleCacheOnItemSizeChange,\n      validateProps = _ref.validateProps;\n  return _class = /*#__PURE__*/function (_PureComponent) {\n    _inheritsLoose(List, _PureComponent);\n\n    // Always use explicit constructor for React components.\n    // It produces less code after transpilation. (#26)\n    // eslint-disable-next-line no-useless-constructor\n    function List(props) {\n      var _this;\n\n      _this = _PureComponent.call(this, props) || this;\n      _this._instanceProps = initInstanceProps(_this.props, _assertThisInitialized(_this));\n      _this._outerRef = void 0;\n      _this._resetIsScrollingTimeoutId = null;\n      _this.state = {\n        instance: _assertThisInitialized(_this),\n        isScrolling: false,\n        scrollDirection: 'forward',\n        scrollOffset: typeof _this.props.initialScrollOffset === 'number' ? _this.props.initialScrollOffset : 0,\n        scrollUpdateWasRequested: false\n      };\n      _this._callOnItemsRendered = void 0;\n      _this._callOnItemsRendered = memoizeOne(function (overscanStartIndex, overscanStopIndex, visibleStartIndex, visibleStopIndex) {\n        return _this.props.onItemsRendered({\n          overscanStartIndex: overscanStartIndex,\n          overscanStopIndex: overscanStopIndex,\n          visibleStartIndex: visibleStartIndex,\n          visibleStopIndex: visibleStopIndex\n        });\n      });\n      _this._callOnScroll = void 0;\n      _this._callOnScroll = memoizeOne(function (scrollDirection, scrollOffset, scrollUpdateWasRequested) {\n        return _this.props.onScroll({\n          scrollDirection: scrollDirection,\n          scrollOffset: scrollOffset,\n          scrollUpdateWasRequested: scrollUpdateWasRequested\n        });\n      });\n      _this._getItemStyle = void 0;\n\n      _this._getItemStyle = function (index) {\n        var _this$props = _this.props,\n            direction = _this$props.direction,\n            itemSize = _this$props.itemSize,\n            layout = _this$props.layout;\n\n        var itemStyleCache = _this._getItemStyleCache(shouldResetStyleCacheOnItemSizeChange && itemSize, shouldResetStyleCacheOnItemSizeChange && layout, shouldResetStyleCacheOnItemSizeChange && direction);\n\n        var style;\n\n        if (itemStyleCache.hasOwnProperty(index)) {\n          style = itemStyleCache[index];\n        } else {\n          var _offset = getItemOffset(_this.props, index, _this._instanceProps);\n\n          var size = getItemSize(_this.props, index, _this._instanceProps); // TODO Deprecate direction \"horizontal\"\n\n          var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n          var isRtl = direction === 'rtl';\n          var offsetHorizontal = isHorizontal ? _offset : 0;\n          itemStyleCache[index] = style = {\n            position: 'absolute',\n            left: isRtl ? undefined : offsetHorizontal,\n            right: isRtl ? offsetHorizontal : undefined,\n            top: !isHorizontal ? _offset : 0,\n            height: !isHorizontal ? size : '100%',\n            width: isHorizontal ? size : '100%'\n          };\n        }\n\n        return style;\n      };\n\n      _this._getItemStyleCache = void 0;\n      _this._getItemStyleCache = memoizeOne(function (_, __, ___) {\n        return {};\n      });\n\n      _this._onScrollHorizontal = function (event) {\n        var _event$currentTarget = event.currentTarget,\n            clientWidth = _event$currentTarget.clientWidth,\n            scrollLeft = _event$currentTarget.scrollLeft,\n            scrollWidth = _event$currentTarget.scrollWidth;\n\n        _this.setState(function (prevState) {\n          if (prevState.scrollOffset === scrollLeft) {\n            // Scroll position may have been updated by cDM/cDU,\n            // In which case we don't need to trigger another render,\n            // And we don't want to update state.isScrolling.\n            return null;\n          }\n\n          var direction = _this.props.direction;\n          var scrollOffset = scrollLeft;\n\n          if (direction === 'rtl') {\n            // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n            // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n            // It's also easier for this component if we convert offsets to the same format as they would be in for ltr.\n            // So the simplest solution is to determine which browser behavior we're dealing with, and convert based on it.\n            switch (getRTLOffsetType()) {\n              case 'negative':\n                scrollOffset = -scrollLeft;\n                break;\n\n              case 'positive-descending':\n                scrollOffset = scrollWidth - clientWidth - scrollLeft;\n                break;\n            }\n          } // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n\n\n          scrollOffset = Math.max(0, Math.min(scrollOffset, scrollWidth - clientWidth));\n          return {\n            isScrolling: true,\n            scrollDirection: prevState.scrollOffset < scrollLeft ? 'forward' : 'backward',\n            scrollOffset: scrollOffset,\n            scrollUpdateWasRequested: false\n          };\n        }, _this._resetIsScrollingDebounced);\n      };\n\n      _this._onScrollVertical = function (event) {\n        var _event$currentTarget2 = event.currentTarget,\n            clientHeight = _event$currentTarget2.clientHeight,\n            scrollHeight = _event$currentTarget2.scrollHeight,\n            scrollTop = _event$currentTarget2.scrollTop;\n\n        _this.setState(function (prevState) {\n          if (prevState.scrollOffset === scrollTop) {\n            // Scroll position may have been updated by cDM/cDU,\n            // In which case we don't need to trigger another render,\n            // And we don't want to update state.isScrolling.\n            return null;\n          } // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n\n\n          var scrollOffset = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));\n          return {\n            isScrolling: true,\n            scrollDirection: prevState.scrollOffset < scrollOffset ? 'forward' : 'backward',\n            scrollOffset: scrollOffset,\n            scrollUpdateWasRequested: false\n          };\n        }, _this._resetIsScrollingDebounced);\n      };\n\n      _this._outerRefSetter = function (ref) {\n        var outerRef = _this.props.outerRef;\n        _this._outerRef = ref;\n\n        if (typeof outerRef === 'function') {\n          outerRef(ref);\n        } else if (outerRef != null && typeof outerRef === 'object' && outerRef.hasOwnProperty('current')) {\n          outerRef.current = ref;\n        }\n      };\n\n      _this._resetIsScrollingDebounced = function () {\n        if (_this._resetIsScrollingTimeoutId !== null) {\n          cancelTimeout(_this._resetIsScrollingTimeoutId);\n        }\n\n        _this._resetIsScrollingTimeoutId = requestTimeout(_this._resetIsScrolling, IS_SCROLLING_DEBOUNCE_INTERVAL$1);\n      };\n\n      _this._resetIsScrolling = function () {\n        _this._resetIsScrollingTimeoutId = null;\n\n        _this.setState({\n          isScrolling: false\n        }, function () {\n          // Clear style cache after state update has been committed.\n          // This way we don't break pure sCU for items that don't use isScrolling param.\n          _this._getItemStyleCache(-1, null);\n        });\n      };\n\n      return _this;\n    }\n\n    List.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {\n      validateSharedProps$1(nextProps, prevState);\n      validateProps(nextProps);\n      return null;\n    };\n\n    var _proto = List.prototype;\n\n    _proto.scrollTo = function scrollTo(scrollOffset) {\n      scrollOffset = Math.max(0, scrollOffset);\n      this.setState(function (prevState) {\n        if (prevState.scrollOffset === scrollOffset) {\n          return null;\n        }\n\n        return {\n          scrollDirection: prevState.scrollOffset < scrollOffset ? 'forward' : 'backward',\n          scrollOffset: scrollOffset,\n          scrollUpdateWasRequested: true\n        };\n      }, this._resetIsScrollingDebounced);\n    };\n\n    _proto.scrollToItem = function scrollToItem(index, align) {\n      if (align === void 0) {\n        align = 'auto';\n      }\n\n      var itemCount = this.props.itemCount;\n      var scrollOffset = this.state.scrollOffset;\n      index = Math.max(0, Math.min(index, itemCount - 1));\n      this.scrollTo(getOffsetForIndexAndAlignment(this.props, index, align, scrollOffset, this._instanceProps));\n    };\n\n    _proto.componentDidMount = function componentDidMount() {\n      var _this$props2 = this.props,\n          direction = _this$props2.direction,\n          initialScrollOffset = _this$props2.initialScrollOffset,\n          layout = _this$props2.layout;\n\n      if (typeof initialScrollOffset === 'number' && this._outerRef != null) {\n        var outerRef = this._outerRef; // TODO Deprecate direction \"horizontal\"\n\n        if (direction === 'horizontal' || layout === 'horizontal') {\n          outerRef.scrollLeft = initialScrollOffset;\n        } else {\n          outerRef.scrollTop = initialScrollOffset;\n        }\n      }\n\n      this._callPropsCallbacks();\n    };\n\n    _proto.componentDidUpdate = function componentDidUpdate() {\n      var _this$props3 = this.props,\n          direction = _this$props3.direction,\n          layout = _this$props3.layout;\n      var _this$state = this.state,\n          scrollOffset = _this$state.scrollOffset,\n          scrollUpdateWasRequested = _this$state.scrollUpdateWasRequested;\n\n      if (scrollUpdateWasRequested && this._outerRef != null) {\n        var outerRef = this._outerRef; // TODO Deprecate direction \"horizontal\"\n\n        if (direction === 'horizontal' || layout === 'horizontal') {\n          if (direction === 'rtl') {\n            // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n            // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n            // So we need to determine which browser behavior we're dealing with, and mimic it.\n            switch (getRTLOffsetType()) {\n              case 'negative':\n                outerRef.scrollLeft = -scrollOffset;\n                break;\n\n              case 'positive-ascending':\n                outerRef.scrollLeft = scrollOffset;\n                break;\n\n              default:\n                var clientWidth = outerRef.clientWidth,\n                    scrollWidth = outerRef.scrollWidth;\n                outerRef.scrollLeft = scrollWidth - clientWidth - scrollOffset;\n                break;\n            }\n          } else {\n            outerRef.scrollLeft = scrollOffset;\n          }\n        } else {\n          outerRef.scrollTop = scrollOffset;\n        }\n      }\n\n      this._callPropsCallbacks();\n    };\n\n    _proto.componentWillUnmount = function componentWillUnmount() {\n      if (this._resetIsScrollingTimeoutId !== null) {\n        cancelTimeout(this._resetIsScrollingTimeoutId);\n      }\n    };\n\n    _proto.render = function render() {\n      var _this$props4 = this.props,\n          children = _this$props4.children,\n          className = _this$props4.className,\n          direction = _this$props4.direction,\n          height = _this$props4.height,\n          innerRef = _this$props4.innerRef,\n          innerElementType = _this$props4.innerElementType,\n          innerTagName = _this$props4.innerTagName,\n          itemCount = _this$props4.itemCount,\n          itemData = _this$props4.itemData,\n          _this$props4$itemKey = _this$props4.itemKey,\n          itemKey = _this$props4$itemKey === void 0 ? defaultItemKey$1 : _this$props4$itemKey,\n          layout = _this$props4.layout,\n          outerElementType = _this$props4.outerElementType,\n          outerTagName = _this$props4.outerTagName,\n          style = _this$props4.style,\n          useIsScrolling = _this$props4.useIsScrolling,\n          width = _this$props4.width;\n      var isScrolling = this.state.isScrolling; // TODO Deprecate direction \"horizontal\"\n\n      var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n      var onScroll = isHorizontal ? this._onScrollHorizontal : this._onScrollVertical;\n\n      var _this$_getRangeToRend = this._getRangeToRender(),\n          startIndex = _this$_getRangeToRend[0],\n          stopIndex = _this$_getRangeToRend[1];\n\n      var items = [];\n\n      if (itemCount > 0) {\n        for (var _index = startIndex; _index <= stopIndex; _index++) {\n          items.push(createElement(children, {\n            data: itemData,\n            key: itemKey(_index, itemData),\n            index: _index,\n            isScrolling: useIsScrolling ? isScrolling : undefined,\n            style: this._getItemStyle(_index)\n          }));\n        }\n      } // Read this value AFTER items have been created,\n      // So their actual sizes (if variable) are taken into consideration.\n\n\n      var estimatedTotalSize = getEstimatedTotalSize(this.props, this._instanceProps);\n      return createElement(outerElementType || outerTagName || 'div', {\n        className: className,\n        onScroll: onScroll,\n        ref: this._outerRefSetter,\n        style: _extends({\n          position: 'relative',\n          height: height,\n          width: width,\n          overflow: 'auto',\n          WebkitOverflowScrolling: 'touch',\n          willChange: 'transform',\n          direction: direction\n        }, style)\n      }, createElement(innerElementType || innerTagName || 'div', {\n        children: items,\n        ref: innerRef,\n        style: {\n          height: isHorizontal ? '100%' : estimatedTotalSize,\n          pointerEvents: isScrolling ? 'none' : undefined,\n          width: isHorizontal ? estimatedTotalSize : '100%'\n        }\n      }));\n    };\n\n    _proto._callPropsCallbacks = function _callPropsCallbacks() {\n      if (typeof this.props.onItemsRendered === 'function') {\n        var itemCount = this.props.itemCount;\n\n        if (itemCount > 0) {\n          var _this$_getRangeToRend2 = this._getRangeToRender(),\n              _overscanStartIndex = _this$_getRangeToRend2[0],\n              _overscanStopIndex = _this$_getRangeToRend2[1],\n              _visibleStartIndex = _this$_getRangeToRend2[2],\n              _visibleStopIndex = _this$_getRangeToRend2[3];\n\n          this._callOnItemsRendered(_overscanStartIndex, _overscanStopIndex, _visibleStartIndex, _visibleStopIndex);\n        }\n      }\n\n      if (typeof this.props.onScroll === 'function') {\n        var _this$state2 = this.state,\n            _scrollDirection = _this$state2.scrollDirection,\n            _scrollOffset = _this$state2.scrollOffset,\n            _scrollUpdateWasRequested = _this$state2.scrollUpdateWasRequested;\n\n        this._callOnScroll(_scrollDirection, _scrollOffset, _scrollUpdateWasRequested);\n      }\n    } // Lazily create and cache item styles while scrolling,\n    // So that pure component sCU will prevent re-renders.\n    // We maintain this cache, and pass a style prop rather than index,\n    // So that List can clear cached styles and force item re-render if necessary.\n    ;\n\n    _proto._getRangeToRender = function _getRangeToRender() {\n      var _this$props5 = this.props,\n          itemCount = _this$props5.itemCount,\n          overscanCount = _this$props5.overscanCount;\n      var _this$state3 = this.state,\n          isScrolling = _this$state3.isScrolling,\n          scrollDirection = _this$state3.scrollDirection,\n          scrollOffset = _this$state3.scrollOffset;\n\n      if (itemCount === 0) {\n        return [0, 0, 0, 0];\n      }\n\n      var startIndex = getStartIndexForOffset(this.props, scrollOffset, this._instanceProps);\n      var stopIndex = getStopIndexForStartIndex(this.props, startIndex, scrollOffset, this._instanceProps); // Overscan by one item in each direction so that tab/focus works.\n      // If there isn't at least one extra item, tab loops back around.\n\n      var overscanBackward = !isScrolling || scrollDirection === 'backward' ? Math.max(1, overscanCount) : 1;\n      var overscanForward = !isScrolling || scrollDirection === 'forward' ? Math.max(1, overscanCount) : 1;\n      return [Math.max(0, startIndex - overscanBackward), Math.max(0, Math.min(itemCount - 1, stopIndex + overscanForward)), startIndex, stopIndex];\n    };\n\n    return List;\n  }(PureComponent), _class.defaultProps = {\n    direction: 'ltr',\n    itemData: undefined,\n    layout: 'vertical',\n    overscanCount: 2,\n    useIsScrolling: false\n  }, _class;\n} // NOTE: I considered further wrapping individual items with a pure ListItem component.\n// This would avoid ever calling the render function for the same index more than once,\n// But it would also add the overhead of a lot of components/fibers.\n// I assume people already do this (render function returning a class component),\n// So my doing it would just unnecessarily double the wrappers.\n\nvar validateSharedProps$1 = function validateSharedProps(_ref2, _ref3) {\n  var children = _ref2.children,\n      direction = _ref2.direction,\n      height = _ref2.height,\n      layout = _ref2.layout,\n      innerTagName = _ref2.innerTagName,\n      outerTagName = _ref2.outerTagName,\n      width = _ref2.width;\n  var instance = _ref3.instance;\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (innerTagName != null || outerTagName != null) {\n      if (devWarningsTagName$1 && !devWarningsTagName$1.has(instance)) {\n        devWarningsTagName$1.add(instance);\n        console.warn('The innerTagName and outerTagName props have been deprecated. ' + 'Please use the innerElementType and outerElementType props instead.');\n      }\n    } // TODO Deprecate direction \"horizontal\"\n\n\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n\n    switch (direction) {\n      case 'horizontal':\n      case 'vertical':\n        if (devWarningsDirection && !devWarningsDirection.has(instance)) {\n          devWarningsDirection.add(instance);\n          console.warn('The direction prop should be either \"ltr\" (default) or \"rtl\". ' + 'Please use the layout prop to specify \"vertical\" (default) or \"horizontal\" orientation.');\n        }\n\n        break;\n\n      case 'ltr':\n      case 'rtl':\n        // Valid values\n        break;\n\n      default:\n        throw Error('An invalid \"direction\" prop has been specified. ' + 'Value should be either \"ltr\" or \"rtl\". ' + (\"\\\"\" + direction + \"\\\" was specified.\"));\n    }\n\n    switch (layout) {\n      case 'horizontal':\n      case 'vertical':\n        // Valid values\n        break;\n\n      default:\n        throw Error('An invalid \"layout\" prop has been specified. ' + 'Value should be either \"horizontal\" or \"vertical\". ' + (\"\\\"\" + layout + \"\\\" was specified.\"));\n    }\n\n    if (children == null) {\n      throw Error('An invalid \"children\" prop has been specified. ' + 'Value should be a React component. ' + (\"\\\"\" + (children === null ? 'null' : typeof children) + \"\\\" was specified.\"));\n    }\n\n    if (isHorizontal && typeof width !== 'number') {\n      throw Error('An invalid \"width\" prop has been specified. ' + 'Horizontal lists must specify a number for width. ' + (\"\\\"\" + (width === null ? 'null' : typeof width) + \"\\\" was specified.\"));\n    } else if (!isHorizontal && typeof height !== 'number') {\n      throw Error('An invalid \"height\" prop has been specified. ' + 'Vertical lists must specify a number for height. ' + (\"\\\"\" + (height === null ? 'null' : typeof height) + \"\\\" was specified.\"));\n    }\n  }\n};\n\nvar DEFAULT_ESTIMATED_ITEM_SIZE$1 = 50;\n\nvar getItemMetadata$1 = function getItemMetadata(props, index, instanceProps) {\n  var _ref = props,\n      itemSize = _ref.itemSize;\n  var itemMetadataMap = instanceProps.itemMetadataMap,\n      lastMeasuredIndex = instanceProps.lastMeasuredIndex;\n\n  if (index > lastMeasuredIndex) {\n    var offset = 0;\n\n    if (lastMeasuredIndex >= 0) {\n      var itemMetadata = itemMetadataMap[lastMeasuredIndex];\n      offset = itemMetadata.offset + itemMetadata.size;\n    }\n\n    for (var i = lastMeasuredIndex + 1; i <= index; i++) {\n      var size = itemSize(i);\n      itemMetadataMap[i] = {\n        offset: offset,\n        size: size\n      };\n      offset += size;\n    }\n\n    instanceProps.lastMeasuredIndex = index;\n  }\n\n  return itemMetadataMap[index];\n};\n\nvar findNearestItem$1 = function findNearestItem(props, instanceProps, offset) {\n  var itemMetadataMap = instanceProps.itemMetadataMap,\n      lastMeasuredIndex = instanceProps.lastMeasuredIndex;\n  var lastMeasuredItemOffset = lastMeasuredIndex > 0 ? itemMetadataMap[lastMeasuredIndex].offset : 0;\n\n  if (lastMeasuredItemOffset >= offset) {\n    // If we've already measured items within this range just use a binary search as it's faster.\n    return findNearestItemBinarySearch$1(props, instanceProps, lastMeasuredIndex, 0, offset);\n  } else {\n    // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\n    // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\n    // The overall complexity for this approach is O(log n).\n    return findNearestItemExponentialSearch$1(props, instanceProps, Math.max(0, lastMeasuredIndex), offset);\n  }\n};\n\nvar findNearestItemBinarySearch$1 = function findNearestItemBinarySearch(props, instanceProps, high, low, offset) {\n  while (low <= high) {\n    var middle = low + Math.floor((high - low) / 2);\n    var currentOffset = getItemMetadata$1(props, middle, instanceProps).offset;\n\n    if (currentOffset === offset) {\n      return middle;\n    } else if (currentOffset < offset) {\n      low = middle + 1;\n    } else if (currentOffset > offset) {\n      high = middle - 1;\n    }\n  }\n\n  if (low > 0) {\n    return low - 1;\n  } else {\n    return 0;\n  }\n};\n\nvar findNearestItemExponentialSearch$1 = function findNearestItemExponentialSearch(props, instanceProps, index, offset) {\n  var itemCount = props.itemCount;\n  var interval = 1;\n\n  while (index < itemCount && getItemMetadata$1(props, index, instanceProps).offset < offset) {\n    index += interval;\n    interval *= 2;\n  }\n\n  return findNearestItemBinarySearch$1(props, instanceProps, Math.min(index, itemCount - 1), Math.floor(index / 2), offset);\n};\n\nvar getEstimatedTotalSize = function getEstimatedTotalSize(_ref2, _ref3) {\n  var itemCount = _ref2.itemCount;\n  var itemMetadataMap = _ref3.itemMetadataMap,\n      estimatedItemSize = _ref3.estimatedItemSize,\n      lastMeasuredIndex = _ref3.lastMeasuredIndex;\n  var totalSizeOfMeasuredItems = 0; // Edge case check for when the number of items decreases while a scroll is in progress.\n  // https://github.com/bvaughn/react-window/pull/138\n\n  if (lastMeasuredIndex >= itemCount) {\n    lastMeasuredIndex = itemCount - 1;\n  }\n\n  if (lastMeasuredIndex >= 0) {\n    var itemMetadata = itemMetadataMap[lastMeasuredIndex];\n    totalSizeOfMeasuredItems = itemMetadata.offset + itemMetadata.size;\n  }\n\n  var numUnmeasuredItems = itemCount - lastMeasuredIndex - 1;\n  var totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedItemSize;\n  return totalSizeOfMeasuredItems + totalSizeOfUnmeasuredItems;\n};\n\nvar VariableSizeList = /*#__PURE__*/createListComponent({\n  getItemOffset: function getItemOffset(props, index, instanceProps) {\n    return getItemMetadata$1(props, index, instanceProps).offset;\n  },\n  getItemSize: function getItemSize(props, index, instanceProps) {\n    return instanceProps.itemMetadataMap[index].size;\n  },\n  getEstimatedTotalSize: getEstimatedTotalSize,\n  getOffsetForIndexAndAlignment: function getOffsetForIndexAndAlignment(props, index, align, scrollOffset, instanceProps) {\n    var direction = props.direction,\n        height = props.height,\n        layout = props.layout,\n        width = props.width; // TODO Deprecate direction \"horizontal\"\n\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    var size = isHorizontal ? width : height;\n    var itemMetadata = getItemMetadata$1(props, index, instanceProps); // Get estimated total size after ItemMetadata is computed,\n    // To ensure it reflects actual measurements instead of just estimates.\n\n    var estimatedTotalSize = getEstimatedTotalSize(props, instanceProps);\n    var maxOffset = Math.max(0, Math.min(estimatedTotalSize - size, itemMetadata.offset));\n    var minOffset = Math.max(0, itemMetadata.offset - size + itemMetadata.size);\n\n    if (align === 'smart') {\n      if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n\n      case 'end':\n        return minOffset;\n\n      case 'center':\n        return Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n      case 'auto':\n      default:\n        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n          return scrollOffset;\n        } else if (scrollOffset < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getStartIndexForOffset: function getStartIndexForOffset(props, offset, instanceProps) {\n    return findNearestItem$1(props, instanceProps, offset);\n  },\n  getStopIndexForStartIndex: function getStopIndexForStartIndex(props, startIndex, scrollOffset, instanceProps) {\n    var direction = props.direction,\n        height = props.height,\n        itemCount = props.itemCount,\n        layout = props.layout,\n        width = props.width; // TODO Deprecate direction \"horizontal\"\n\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    var size = isHorizontal ? width : height;\n    var itemMetadata = getItemMetadata$1(props, startIndex, instanceProps);\n    var maxOffset = scrollOffset + size;\n    var offset = itemMetadata.offset + itemMetadata.size;\n    var stopIndex = startIndex;\n\n    while (stopIndex < itemCount - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemMetadata$1(props, stopIndex, instanceProps).size;\n    }\n\n    return stopIndex;\n  },\n  initInstanceProps: function initInstanceProps(props, instance) {\n    var _ref4 = props,\n        estimatedItemSize = _ref4.estimatedItemSize;\n    var instanceProps = {\n      itemMetadataMap: {},\n      estimatedItemSize: estimatedItemSize || DEFAULT_ESTIMATED_ITEM_SIZE$1,\n      lastMeasuredIndex: -1\n    };\n\n    instance.resetAfterIndex = function (index, shouldForceUpdate) {\n      if (shouldForceUpdate === void 0) {\n        shouldForceUpdate = true;\n      }\n\n      instanceProps.lastMeasuredIndex = Math.min(instanceProps.lastMeasuredIndex, index - 1); // We could potentially optimize further by only evicting styles after this index,\n      // But since styles are only cached while scrolling is in progress-\n      // It seems an unnecessary optimization.\n      // It's unlikely that resetAfterIndex() will be called while a user is scrolling.\n\n      instance._getItemStyleCache(-1);\n\n      if (shouldForceUpdate) {\n        instance.forceUpdate();\n      }\n    };\n\n    return instanceProps;\n  },\n  shouldResetStyleCacheOnItemSizeChange: false,\n  validateProps: function validateProps(_ref5) {\n    var itemSize = _ref5.itemSize;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof itemSize !== 'function') {\n        throw Error('An invalid \"itemSize\" prop has been specified. ' + 'Value should be a function. ' + (\"\\\"\" + (itemSize === null ? 'null' : typeof itemSize) + \"\\\" was specified.\"));\n      }\n    }\n  }\n});\n\nvar FixedSizeGrid = /*#__PURE__*/createGridComponent({\n  getColumnOffset: function getColumnOffset(_ref, index) {\n    var columnWidth = _ref.columnWidth;\n    return index * columnWidth;\n  },\n  getColumnWidth: function getColumnWidth(_ref2, index) {\n    var columnWidth = _ref2.columnWidth;\n    return columnWidth;\n  },\n  getRowOffset: function getRowOffset(_ref3, index) {\n    var rowHeight = _ref3.rowHeight;\n    return index * rowHeight;\n  },\n  getRowHeight: function getRowHeight(_ref4, index) {\n    var rowHeight = _ref4.rowHeight;\n    return rowHeight;\n  },\n  getEstimatedTotalHeight: function getEstimatedTotalHeight(_ref5) {\n    var rowCount = _ref5.rowCount,\n        rowHeight = _ref5.rowHeight;\n    return rowHeight * rowCount;\n  },\n  getEstimatedTotalWidth: function getEstimatedTotalWidth(_ref6) {\n    var columnCount = _ref6.columnCount,\n        columnWidth = _ref6.columnWidth;\n    return columnWidth * columnCount;\n  },\n  getOffsetForColumnAndAlignment: function getOffsetForColumnAndAlignment(_ref7, columnIndex, align, scrollLeft, instanceProps, scrollbarSize) {\n    var columnCount = _ref7.columnCount,\n        columnWidth = _ref7.columnWidth,\n        width = _ref7.width;\n    var lastColumnOffset = Math.max(0, columnCount * columnWidth - width);\n    var maxOffset = Math.min(lastColumnOffset, columnIndex * columnWidth);\n    var minOffset = Math.max(0, columnIndex * columnWidth - width + scrollbarSize + columnWidth);\n\n    if (align === 'smart') {\n      if (scrollLeft >= minOffset - width && scrollLeft <= maxOffset + width) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n\n      case 'end':\n        return minOffset;\n\n      case 'center':\n        // \"Centered\" offset is usually the average of the min and max.\n        // But near the edges of the list, this doesn't hold true.\n        var middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n        if (middleOffset < Math.ceil(width / 2)) {\n          return 0; // near the beginning\n        } else if (middleOffset > lastColumnOffset + Math.floor(width / 2)) {\n          return lastColumnOffset; // near the end\n        } else {\n          return middleOffset;\n        }\n\n      case 'auto':\n      default:\n        if (scrollLeft >= minOffset && scrollLeft <= maxOffset) {\n          return scrollLeft;\n        } else if (minOffset > maxOffset) {\n          // Because we only take into account the scrollbar size when calculating minOffset\n          // this value can be larger than maxOffset when at the end of the list\n          return minOffset;\n        } else if (scrollLeft < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getOffsetForRowAndAlignment: function getOffsetForRowAndAlignment(_ref8, rowIndex, align, scrollTop, instanceProps, scrollbarSize) {\n    var rowHeight = _ref8.rowHeight,\n        height = _ref8.height,\n        rowCount = _ref8.rowCount;\n    var lastRowOffset = Math.max(0, rowCount * rowHeight - height);\n    var maxOffset = Math.min(lastRowOffset, rowIndex * rowHeight);\n    var minOffset = Math.max(0, rowIndex * rowHeight - height + scrollbarSize + rowHeight);\n\n    if (align === 'smart') {\n      if (scrollTop >= minOffset - height && scrollTop <= maxOffset + height) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n\n      case 'end':\n        return minOffset;\n\n      case 'center':\n        // \"Centered\" offset is usually the average of the min and max.\n        // But near the edges of the list, this doesn't hold true.\n        var middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n        if (middleOffset < Math.ceil(height / 2)) {\n          return 0; // near the beginning\n        } else if (middleOffset > lastRowOffset + Math.floor(height / 2)) {\n          return lastRowOffset; // near the end\n        } else {\n          return middleOffset;\n        }\n\n      case 'auto':\n      default:\n        if (scrollTop >= minOffset && scrollTop <= maxOffset) {\n          return scrollTop;\n        } else if (minOffset > maxOffset) {\n          // Because we only take into account the scrollbar size when calculating minOffset\n          // this value can be larger than maxOffset when at the end of the list\n          return minOffset;\n        } else if (scrollTop < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getColumnStartIndexForOffset: function getColumnStartIndexForOffset(_ref9, scrollLeft) {\n    var columnWidth = _ref9.columnWidth,\n        columnCount = _ref9.columnCount;\n    return Math.max(0, Math.min(columnCount - 1, Math.floor(scrollLeft / columnWidth)));\n  },\n  getColumnStopIndexForStartIndex: function getColumnStopIndexForStartIndex(_ref10, startIndex, scrollLeft) {\n    var columnWidth = _ref10.columnWidth,\n        columnCount = _ref10.columnCount,\n        width = _ref10.width;\n    var left = startIndex * columnWidth;\n    var numVisibleColumns = Math.ceil((width + scrollLeft - left) / columnWidth);\n    return Math.max(0, Math.min(columnCount - 1, startIndex + numVisibleColumns - 1 // -1 is because stop index is inclusive\n    ));\n  },\n  getRowStartIndexForOffset: function getRowStartIndexForOffset(_ref11, scrollTop) {\n    var rowHeight = _ref11.rowHeight,\n        rowCount = _ref11.rowCount;\n    return Math.max(0, Math.min(rowCount - 1, Math.floor(scrollTop / rowHeight)));\n  },\n  getRowStopIndexForStartIndex: function getRowStopIndexForStartIndex(_ref12, startIndex, scrollTop) {\n    var rowHeight = _ref12.rowHeight,\n        rowCount = _ref12.rowCount,\n        height = _ref12.height;\n    var top = startIndex * rowHeight;\n    var numVisibleRows = Math.ceil((height + scrollTop - top) / rowHeight);\n    return Math.max(0, Math.min(rowCount - 1, startIndex + numVisibleRows - 1 // -1 is because stop index is inclusive\n    ));\n  },\n  initInstanceProps: function initInstanceProps(props) {// Noop\n  },\n  shouldResetStyleCacheOnItemSizeChange: true,\n  validateProps: function validateProps(_ref13) {\n    var columnWidth = _ref13.columnWidth,\n        rowHeight = _ref13.rowHeight;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof columnWidth !== 'number') {\n        throw Error('An invalid \"columnWidth\" prop has been specified. ' + 'Value should be a number. ' + (\"\\\"\" + (columnWidth === null ? 'null' : typeof columnWidth) + \"\\\" was specified.\"));\n      }\n\n      if (typeof rowHeight !== 'number') {\n        throw Error('An invalid \"rowHeight\" prop has been specified. ' + 'Value should be a number. ' + (\"\\\"\" + (rowHeight === null ? 'null' : typeof rowHeight) + \"\\\" was specified.\"));\n      }\n    }\n  }\n});\n\nvar FixedSizeList = /*#__PURE__*/createListComponent({\n  getItemOffset: function getItemOffset(_ref, index) {\n    var itemSize = _ref.itemSize;\n    return index * itemSize;\n  },\n  getItemSize: function getItemSize(_ref2, index) {\n    var itemSize = _ref2.itemSize;\n    return itemSize;\n  },\n  getEstimatedTotalSize: function getEstimatedTotalSize(_ref3) {\n    var itemCount = _ref3.itemCount,\n        itemSize = _ref3.itemSize;\n    return itemSize * itemCount;\n  },\n  getOffsetForIndexAndAlignment: function getOffsetForIndexAndAlignment(_ref4, index, align, scrollOffset) {\n    var direction = _ref4.direction,\n        height = _ref4.height,\n        itemCount = _ref4.itemCount,\n        itemSize = _ref4.itemSize,\n        layout = _ref4.layout,\n        width = _ref4.width;\n    // TODO Deprecate direction \"horizontal\"\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    var size = isHorizontal ? width : height;\n    var lastItemOffset = Math.max(0, itemCount * itemSize - size);\n    var maxOffset = Math.min(lastItemOffset, index * itemSize);\n    var minOffset = Math.max(0, index * itemSize - size + itemSize);\n\n    if (align === 'smart') {\n      if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n\n      case 'end':\n        return minOffset;\n\n      case 'center':\n        {\n          // \"Centered\" offset is usually the average of the min and max.\n          // But near the edges of the list, this doesn't hold true.\n          var middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n          if (middleOffset < Math.ceil(size / 2)) {\n            return 0; // near the beginning\n          } else if (middleOffset > lastItemOffset + Math.floor(size / 2)) {\n            return lastItemOffset; // near the end\n          } else {\n            return middleOffset;\n          }\n        }\n\n      case 'auto':\n      default:\n        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n          return scrollOffset;\n        } else if (scrollOffset < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getStartIndexForOffset: function getStartIndexForOffset(_ref5, offset) {\n    var itemCount = _ref5.itemCount,\n        itemSize = _ref5.itemSize;\n    return Math.max(0, Math.min(itemCount - 1, Math.floor(offset / itemSize)));\n  },\n  getStopIndexForStartIndex: function getStopIndexForStartIndex(_ref6, startIndex, scrollOffset) {\n    var direction = _ref6.direction,\n        height = _ref6.height,\n        itemCount = _ref6.itemCount,\n        itemSize = _ref6.itemSize,\n        layout = _ref6.layout,\n        width = _ref6.width;\n    // TODO Deprecate direction \"horizontal\"\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    var offset = startIndex * itemSize;\n    var size = isHorizontal ? width : height;\n    var numVisibleItems = Math.ceil((size + scrollOffset - offset) / itemSize);\n    return Math.max(0, Math.min(itemCount - 1, startIndex + numVisibleItems - 1 // -1 is because stop index is inclusive\n    ));\n  },\n  initInstanceProps: function initInstanceProps(props) {// Noop\n  },\n  shouldResetStyleCacheOnItemSizeChange: true,\n  validateProps: function validateProps(_ref7) {\n    var itemSize = _ref7.itemSize;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof itemSize !== 'number') {\n        throw Error('An invalid \"itemSize\" prop has been specified. ' + 'Value should be a number. ' + (\"\\\"\" + (itemSize === null ? 'null' : typeof itemSize) + \"\\\" was specified.\"));\n      }\n    }\n  }\n});\n\n// Pulled from react-compat\n// https://github.com/developit/preact-compat/blob/7c5de00e7c85e2ffd011bf3af02899b63f699d3a/src/index.js#L349\nfunction shallowDiffers(prev, next) {\n  for (var attribute in prev) {\n    if (!(attribute in next)) {\n      return true;\n    }\n  }\n\n  for (var _attribute in next) {\n    if (prev[_attribute] !== next[_attribute]) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nvar _excluded = [\"style\"],\n    _excluded2 = [\"style\"];\n// It knows to compare individual style props and ignore the wrapper object.\n// See https://reactjs.org/docs/react-api.html#reactmemo\n\nfunction areEqual(prevProps, nextProps) {\n  var prevStyle = prevProps.style,\n      prevRest = _objectWithoutPropertiesLoose(prevProps, _excluded);\n\n  var nextStyle = nextProps.style,\n      nextRest = _objectWithoutPropertiesLoose(nextProps, _excluded2);\n\n  return !shallowDiffers(prevStyle, nextStyle) && !shallowDiffers(prevRest, nextRest);\n}\n\n// It knows to compare individual style props and ignore the wrapper object.\n// See https://reactjs.org/docs/react-component.html#shouldcomponentupdate\n\nfunction shouldComponentUpdate(nextProps, nextState) {\n  return !areEqual(this.props, nextProps) || shallowDiffers(this.state, nextState);\n}\n\nexport { FixedSizeGrid, FixedSizeList, VariableSizeGrid, VariableSizeList, areEqual, shouldComponentUpdate };\n//# sourceMappingURL=index.esm.js.map\n","import * as React from \"react\";\n\nimport type {StyleType} from \"@khanacademy/wonder-blocks-core\";\n\nimport SeparatorItem from \"./separator-item\";\n\nimport type {DropdownItem} from \"../util/types\";\n\n// copied from https://github.com/bvaughn/react-window/blob/master/src/createListComponent.js#L17\ntype Props = {\n    /**\n     * The complete list of items that will be virtualized.\n     */\n    data: Array<DropdownItem>;\n    /**\n     * The current item index.\n     */\n    index: number;\n    /**\n     * Whether the item is scrolling or not.\n     */\n    isScrolling?: boolean;\n    /**\n     * Custom styles passed from react-window\n     */\n    style: StyleType;\n};\n\n/**\n * A virtualized list item - It's created by decorating the DropdownItem\n * (ActionItem, OptionItem, SeparatorItem) with custom styles to let\n * react-window make its own calculations.\n */\nclass DropdownVirtualizedItem extends React.Component<Props> {\n    render(): React.ReactNode {\n        const {data, index, style} = this.props;\n        const item = data[index];\n\n        if (SeparatorItem.isClassOf(item.component)) {\n            // add react-window style to the separator to preserve the correct\n            // position\n            return React.cloneElement(item.component, {style});\n        } else {\n            const {component, populatedProps, onClick, role, ref} = item;\n\n            return React.cloneElement(component, {\n                style,\n                ...populatedProps,\n                key: index,\n                onClick,\n                ref: item.focusable && ref,\n                role,\n            });\n        }\n    }\n}\n\nexport default DropdownVirtualizedItem;\n","import {StyleSheet} from \"aphrodite\";\n\nimport type {StyleType} from \"@khanacademy/wonder-blocks-core\";\n\nimport {\n    DROPDOWN_ITEM_HEIGHT,\n    MAX_VISIBLE_ITEMS,\n    SEPARATOR_ITEM_HEIGHT,\n} from \"./constants\";\n\nimport SeparatorItem from \"../components/separator-item\";\n\nimport type {DropdownItem} from \"./types\";\n\n/**\n * The list height that is automatically calculated depending on the\n * component's type of each item (e.g. Separator, Option, Search, etc)\n *\n * @param {Array<DropdownItem>} items - The list of items to calculate the height\n * @param {number} initialHeight - The initial height of the list\n *\n * @returns {number} The list height\n */\nexport function getDropdownMenuHeight(\n    items: Array<DropdownItem>,\n    initialHeight = 0,\n): number {\n    // calculate using the first 10 items on the array as we want to display\n    // this number of elements in the visible area\n    return items.slice(0, MAX_VISIBLE_ITEMS).reduce((sum, item) => {\n        if (SeparatorItem.isClassOf(item.component)) {\n            return sum + SEPARATOR_ITEM_HEIGHT;\n        } else {\n            return sum + DROPDOWN_ITEM_HEIGHT;\n        }\n    }, initialHeight);\n}\n\n/**\n * Wraps the dynamic styles in an Aphrodite style sheet so we can properly apply\n * the styles to a merged stylesheet (instead of inlining the styles).\n *\n * @param {StyleType} customStyles - The custom styles to apply to the dropdown\n * menu.\n * @returns The Aphrodite stylesheet for the dropdown menu.\n */\nexport function generateDropdownMenuStyles(\n    minWidth: number,\n    maxHeight: number,\n): StyleType {\n    const styles = StyleSheet.create({\n        dropdownMenu: {\n            minWidth,\n            maxHeight,\n        },\n    });\n\n    return styles.dropdownMenu;\n}\n","import * as React from \"react\";\nimport * as ReactDOM from \"react-dom\";\nimport {VariableSizeList as List} from \"react-window\";\nimport {withActionScheduler} from \"@khanacademy/wonder-blocks-timing\";\n\nimport type {WithActionSchedulerProps} from \"@khanacademy/wonder-blocks-timing\";\nimport DropdownVirtualizedItem from \"./dropdown-core-virtualized-item\";\nimport SeparatorItem from \"./separator-item\";\n\nimport type {DropdownItem} from \"../util/types\";\n\nimport {\n    DROPDOWN_ITEM_HEIGHT,\n    MAX_VISIBLE_ITEMS,\n    SEPARATOR_ITEM_HEIGHT,\n} from \"../util/constants\";\nimport {getDropdownMenuHeight} from \"../util/dropdown-menu-styles\";\n\ntype Props = {\n    /**\n     * The complete list of items that will be virtualized.\n     */\n    data: Array<DropdownItem>;\n    /**\n     * The VariableSizeList ref that needs to be passed to access to\n     * react-window's instance methods\n     */\n    listRef?: React.RefObject<List>;\n    /**\n     * An optional fixed width that will be passed to the react-window instance\n     */\n    width?: number | null | undefined;\n} & WithActionSchedulerProps;\n\ntype State = {\n    /**\n     * The list width that needs to be passed in order to let react-window\n     * calculate each item position\n     */\n    width: number | null | undefined;\n    /**\n     * The list height that needs to be passed in order to let react-window\n     * calculate the container size\n     */\n    height: number;\n};\n\n/**\n * A react-window's List wrapper that instantiates the virtualized list and\n * dynamically calculates the item height depending on the type\n */\nclass DropdownCoreVirtualized extends React.Component<Props, State> {\n    constructor(props: Props) {\n        super(props);\n\n        this.state = {\n            height: getDropdownMenuHeight(props.data),\n            width: props.width,\n        };\n    }\n\n    componentDidMount() {\n        const {schedule} = this.props;\n\n        // Wait for styles to be applied. This way, we can get a more precise\n        // value of the container dimensions.\n        schedule.animationFrame(() => {\n            this.setWidth();\n        });\n    }\n\n    componentDidUpdate(prevProps: Props) {\n        const {data, listRef} = this.props;\n\n        // if the items size has changed, then recalculate each item position\n        if (prevProps.data.length !== data.length) {\n            this.setHeight();\n\n            if (listRef && listRef.current) {\n                // the ref can't associate this instance method\n                listRef.current.resetAfterIndex(1);\n            }\n        }\n    }\n\n    /**\n     * Update container width\n     */\n    setWidth() {\n        const rootNode = ReactDOM.findDOMNode(this) as\n            | HTMLElement\n            | null\n            | undefined;\n        const parentNode = rootNode?.parentElement;\n\n        // after the non-virtualized items are rendered, we get the container\n        //  width to pass it to react-window's List\n        if (parentNode) {\n            const width = parentNode.getBoundingClientRect().width;\n\n            this.setState({\n                width,\n            });\n        }\n    }\n\n    /**\n     * Update container height\n     */\n    setHeight() {\n        // calculate dropdown's height depending on the type of items\n        const height = getDropdownMenuHeight(this.props.data);\n        this.setState({height});\n    }\n\n    /**\n     * Calculates item height\n     */\n    getItemSize: (index: number) => number = (index: number) => {\n        // get the current item in the list\n        const item = this.props.data[index];\n\n        if (SeparatorItem.isClassOf(item.component)) {\n            // this is the separator's height (1px) + vertical margin (8px)\n            return SEPARATOR_ITEM_HEIGHT;\n        } else {\n            // default dropdown item height\n            return DROPDOWN_ITEM_HEIGHT;\n        }\n    };\n\n    /**\n     * render non virtualized items to calculate the container max-width that\n     * will be used by DropdownCoreVirtualized\n     */\n    renderInitialItems(): Array<React.ReactNode> {\n        const {data} = this.props;\n\n        const allComponents = data.map((e) => e.component);\n\n        // 1. get the children opaque data structure to sort each item by its\n        //    label length\n        const longestItems = React.Children.toArray(allComponents)\n            .filter(Boolean)\n            .sort((a, b) => {\n                // 2. only sort elements that contain a `label` prop\n                // @ts-expect-error [FEI-5019] - TS2339 - Property 'props' does not exist on type 'ReactChild | ReactFragment | ReactPortal'. | TS2339 - Property 'props' does not exist on type 'ReactChild | ReactFragment | ReactPortal'.\n                if (b.props.label && a.props.label) {\n                    // @ts-expect-error [FEI-5019] - TS2339 - Property 'props' does not exist on type 'ReactChild | ReactFragment | ReactPortal'. | TS2339 - Property 'props' does not exist on type 'ReactChild | ReactFragment | ReactPortal'.\n                    return b.props.label.length - a.props.label.length;\n                }\n\n                return -1;\n            })\n            // 3. only render the possible visible items to minimize layout\n            //    jumps\n            .slice(0, MAX_VISIBLE_ITEMS);\n\n        // Append longest items to calculate the container width.\n        // We need to hide these sorted elements to avoid any FOUC.\n        return longestItems.map((item) =>\n            // @ts-expect-error [FEI-5019] - TS2769 - No overload matches this call.\n            React.cloneElement(item, {\n                style: {visibility: \"hidden\"},\n            }),\n        );\n    }\n\n    renderVirtualizedList(width: number, height: number): React.ReactElement {\n        const {data, listRef} = this.props;\n\n        return (\n            <List\n                height={height}\n                itemCount={data.length}\n                itemSize={this.getItemSize}\n                itemData={data}\n                style={{overflowX: \"hidden\"}}\n                width={width}\n                overscanCount={5}\n                ref={listRef}\n            >\n                {/* @ts-expect-error: No overload matches this call. */}\n                {DropdownVirtualizedItem}\n            </List>\n        );\n    }\n\n    render(): React.ReactNode {\n        const {width, height} = this.state;\n\n        if (width == null) {\n            // if we don't pass a fixed value, then we need to render\n            // non-virtualized items to calculate width\n            return this.renderInitialItems();\n        } else {\n            // width has been provided, then render the virtualized list\n            return this.renderVirtualizedList(width, height);\n        }\n    }\n}\n\nexport default withActionScheduler(DropdownCoreVirtualized);\n","import * as React from \"react\";\nimport * as ReactDOM from \"react-dom\";\nimport {Popper} from \"react-popper\";\n\nimport {maybeGetPortalMountedModalHostElement} from \"@khanacademy/wonder-blocks-modal\";\n\nimport type {StyleType} from \"@khanacademy/wonder-blocks-core\";\n\nconst modifiers = [\n    {\n        name: \"preventOverflow\",\n        options: {\n            rootBoundary: \"viewport\",\n            // Allows to overlap the popper in case there's no more vertical\n            // room in the viewport.\n            altAxis: true,\n            // Also needed to make sure the Popper will be displayed correctly\n            // in different contexts (e.g inside a Modal)\n            tether: false,\n        },\n    },\n];\n\ntype Props = {\n    /**\n     * The children that will be wrapped by PopperJS.\n     */\n    children: (isReferenceHidden: boolean) => React.ReactNode;\n    /**\n     * The reference element used to position the popper.\n     */\n    referenceElement?: HTMLElement;\n    /**\n     * Whether this menu should be left-aligned or right-aligned with the\n     * reference component. Defaults to left-aligned.\n     */\n    alignment?: \"left\" | \"right\";\n    /**\n     * The popper's reference.\n     * @see https://popper.js.org/react-popper/v2/render-props/#innerref\n     */\n    onPopperElement?: (\n        popperElement?: HTMLElement | null | undefined,\n    ) => unknown;\n    /**\n     * Styles that will be applied to the children.\n     */\n    style?: StyleType;\n};\n\n/**\n * A wrapper for PopperJS that renders the children inside a portal.\n */\nconst DropdownPopper = function ({\n    children,\n    alignment = \"left\",\n    onPopperElement,\n    referenceElement,\n}: Props): React.ReactElement {\n    // If we are in a modal, we find where we should be portalling the menu by\n    // using the helper function from the modal package on the opener element.\n    // If we are not in a modal, we use body as the location to portal to.\n    const modalHost =\n        maybeGetPortalMountedModalHostElement(referenceElement) ||\n        document.querySelector(\"body\");\n\n    if (!modalHost) {\n        // @ts-expect-error [FEI-5019] - TS2322 - Type 'null' is not assignable to type 'ReactElement<any, string | JSXElementConstructor<any>>'.\n        return null;\n    }\n\n    return ReactDOM.createPortal(\n        <Popper\n            innerRef={(node?: HTMLElement | null) => {\n                if (node && onPopperElement) {\n                    onPopperElement(node);\n                }\n            }}\n            referenceElement={referenceElement}\n            strategy=\"fixed\"\n            placement={alignment === \"left\" ? \"bottom-start\" : \"bottom-end\"}\n            modifiers={modifiers}\n        >\n            {({placement, ref, style, hasPopperEscaped, isReferenceHidden}) => {\n                const shouldHidePopper = !!(\n                    hasPopperEscaped || isReferenceHidden\n                );\n\n                return (\n                    <div\n                        ref={ref}\n                        style={style}\n                        data-test-id=\"dropdown-popper\"\n                        data-placement={placement}\n                    >\n                        {children(shouldHidePopper)}\n                    </div>\n                );\n            }}\n        </Popper>,\n        modalHost,\n    );\n};\nexport default DropdownPopper;\n","/**\n * Checks if a given key is a valid ASCII value.\n *\n * @param {string} key The key that is being typed in.\n * @returns A valid string representation of the given key.\n */\nexport function getStringForKey(key: string): string {\n    // If the key is of length 1, it is an ASCII value.\n    // Otherwise, if there are no ASCII characters in the key name,\n    // it is a Unicode character.\n    // See https://www.w3.org/TR/uievents-key/\n    if (key.length === 1 || !/^[A-Z]/i.test(key)) {\n        return key;\n    }\n\n    return \"\";\n}\n\n/**\n *\n * @param {fn} callback The function that will be executed after the debounce is resolved.\n * @param {number} wait The period of time that will be executed the debounced\n * function.\n * @returns The function that will be executed after the wait period is\n * fulfilled.\n */\nexport function debounce(\n    callback: (...args: any) => void,\n    wait: number,\n): (...args: any) => void {\n    // @ts-expect-error [FEI-5019] - TS7034 - Variable 'timeout' implicitly has type 'any' in some locations where its type cannot be determined.\n    let timeout;\n\n    return function executedFunction(...args) {\n        const later = () => {\n            // @ts-expect-error [FEI-5019] - TS7005 - Variable 'timeout' implicitly has an 'any' type.\n            clearTimeout(timeout);\n            callback(...args);\n        };\n\n        // @ts-expect-error [FEI-5019] - TS7005 - Variable 'timeout' implicitly has an 'any' type.\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n    };\n}\n","/* eslint-disable max-lines */\n// A menu that consists of action items\n\nimport * as React from \"react\";\nimport * as ReactDOM from \"react-dom\";\n\nimport {StyleSheet} from \"aphrodite\";\nimport {VariableSizeList as List} from \"react-window\";\n\nimport Color, {fade} from \"@khanacademy/wonder-blocks-color\";\n\nimport Spacing from \"@khanacademy/wonder-blocks-spacing\";\nimport {addStyle, View} from \"@khanacademy/wonder-blocks-core\";\nimport SearchField from \"@khanacademy/wonder-blocks-search-field\";\nimport {LabelMedium} from \"@khanacademy/wonder-blocks-typography\";\nimport {withActionScheduler} from \"@khanacademy/wonder-blocks-timing\";\n\nimport type {StyleType} from \"@khanacademy/wonder-blocks-core\";\nimport type {WithActionSchedulerProps} from \"@khanacademy/wonder-blocks-timing\";\nimport DropdownCoreVirtualized from \"./dropdown-core-virtualized\";\nimport SeparatorItem from \"./separator-item\";\nimport {defaultLabels, keyCodes} from \"../util/constants\";\nimport type {DropdownItem} from \"../util/types\";\nimport DropdownPopper from \"./dropdown-popper\";\nimport {debounce, getStringForKey} from \"../util/helpers\";\nimport {\n    generateDropdownMenuStyles,\n    getDropdownMenuHeight,\n} from \"../util/dropdown-menu-styles\";\n\n/**\n * The number of options to apply the virtualized list to.\n *\n * NOTE: The threshold is defined taking into account performance\n * implications (e.g. process input events for users should not be longer\n * than 100ms).\n * @see https://web.dev/rail/?utm_source=devtools#goals-and-guidelines\n *\n * TODO(juan, WB-1263): Improve performance by refactoring this component.\n */\nconst VIRTUALIZE_THRESHOLD = 125;\n\nconst StyledSpan = addStyle(\"span\");\n\ntype Labels = {\n    /**\n     * Label for describing the dismiss icon on the search filter.\n     */\n    clearSearch: string;\n    /**\n     * Label for the search placeholder.\n     */\n    filter: string;\n    /**\n     * Label for when the filter returns no results.\n     */\n    noResults: string;\n    /**\n     * The total number of available options in the dropdown.\n     * These can be all items or only the ones that match the filter.\n     */\n    someResults: (numOptions: number) => string;\n};\n\n// we need to define a DefaultProps type to allow the HOC expose the default\n// values to the parent components that are instantiating this component\n// @see https://flow.org/en/docs/react/hoc/#toc-exporting-wrapped-components\ntype DefaultProps = Readonly<{\n    /**\n     * Whether this menu should be left-aligned or right-aligned with the\n     * opener component. Defaults to left-aligned.\n     */\n    alignment: \"left\" | \"right\";\n    /**\n     * Whether to auto focus an option. Defaults to true.\n     */\n    autoFocus: boolean;\n    /**\n     * Whether to enable the type-ahead suggestions feature. Defaults to true.\n     *\n     * This feature allows to navigate the listbox using the keyboard.\n     * - Type a character: focus moves to the next item with a name that starts\n     *   with the typed character.\n     * - Type multiple characters in rapid succession: focus moves to the next\n     *   item with a name that starts with the string of characters typed.\n     *\n     * **NOTE:** Type-ahead is recommended for all listboxes, but there might be\n     * some cases where it's not desirable (for example when using a `TextField`\n     * as the opener element).\n     */\n    enableTypeAhead: boolean;\n    /**\n     * An index that represents the index of the focused element when the menu\n     * is opened.\n     */\n    initialFocusedIndex?: number;\n    /**\n     * The object containing the custom labels used inside this component.\n     */\n    labels: Labels;\n    /**\n     * Whether to display the \"light\" version of this component instead, for\n     * use when the item is used on a dark background.\n     */\n    light: boolean;\n    /**\n     * Used to determine if we can automatically select an item using the keyboard.\n     */\n    selectionType: \"single\" | \"multi\";\n}>;\n\ntype DropdownAriaRole = \"listbox\" | \"menu\";\ntype ItemAriaRole = \"option\" | \"menuitem\";\n\ntype ExportProps = Readonly<{\n    // Required props\n\n    /**\n     * Items for the menu.\n     */\n    items: Array<DropdownItem>;\n    /**\n     * Callback for when the menu is opened or closed. Parameter is whether\n     * the dropdown menu should be open.\n     */\n    onOpenChanged: (open: boolean) => unknown;\n    /**\n     * Whether the menu is open or not.\n     */\n    open: boolean;\n    /**\n     * The component that opens the menu.\n     */\n    opener: React.ReactElement<any>;\n    /**\n     * Ref to the opener element.\n     */\n    openerElement?: HTMLElement;\n    /**\n     * The aria \"role\" applied to the dropdown container.\n     */\n    role: DropdownAriaRole;\n    // Optional props\n\n    /**\n     * An optional handler to set the searchText of the parent. When this and\n     * the searchText exist, SearchField will be displayed at the top of the\n     * dropdown body.\n     */\n    onSearchTextChanged?: (searchText: string) => unknown | null | undefined;\n    /**\n     * An optional string that the user entered to search the items. When this\n     * and the onSearchTextChanged exist, SearchField will be displayed at the\n     * top of the dropdown body.\n     */\n    searchText?: string | null | undefined;\n    /**\n     * Styling specific to the dropdown component that isn't part of the opener,\n     * passed by the specific implementation of the dropdown menu,\n     */\n    dropdownStyle?: StyleType;\n    /**\n     * Optional styling for the entire dropdown component.\n     */\n    style?: StyleType;\n    /**\n     * Optional CSS classes for the entire dropdown component.\n     */\n    className?: string;\n    /**\n     * When this is true, the dropdown body shows a search text input at the\n     * top. The items will be filtered by the input.\n     */\n    isFilterable?: boolean;\n\n    // Optional props with defaults\n    /**\n     * Whether this menu should be left-aligned or right-aligned with the\n     * opener component. Defaults to left-aligned.\n     */\n    alignment?: \"left\" | \"right\";\n    /**\n     * Whether to auto focus an option. Defaults to true.\n     */\n    autoFocus?: boolean;\n    /**\n     * Whether to enable the type-ahead suggestions feature. Defaults to true.\n     *\n     * This feature allows to navigate the listbox using the keyboard.\n     * - Type a character: focus moves to the next item with a name that starts\n     *   with the typed character.\n     * - Type multiple characters in rapid succession: focus moves to the next\n     *   item with a name that starts with the string of characters typed.\n     *\n     * **NOTE:** Type-ahead is recommended for all listboxes, but there might be\n     * some cases where it's not desirable (for example when using a `TextField`\n     * as the opener element).\n     */\n    enableTypeAhead?: boolean;\n    /**\n     * An index that represents the index of the focused element when the menu\n     * is opened.\n     */\n    initialFocusedIndex?: number;\n    /**\n     * The object containing the custom labels used inside this component.\n     */\n    labels?: Labels;\n    /**\n     * Whether to display the \"light\" version of this component instead, for\n     * use when the item is used on a dark background.\n     */\n    light?: boolean;\n    /**\n     * Used to determine if we can automatically select an item using the keyboard.\n     */\n    selectionType?: \"single\" | \"multi\";\n}>;\n\ntype Props = DefaultProps & ExportProps & WithActionSchedulerProps;\n\ntype State = Readonly<{\n    /**\n     * Refs to use for keyboard focus, contains only those for focusable items.\n     * Also keeps track of the original index of the item.\n     */\n    itemRefs: Array<{\n        ref: {\n            current: any;\n        };\n        originalIndex: number;\n    }>;\n    /**\n     * The object containing the custom labels used inside this component.\n     */\n    labels: Labels;\n    /**\n     * Because getDerivedStateFromProps doesn't store previous props (in the\n     * spirit of performance), we store the previous items just to be able to\n     * compare them to see if we need to update itemRefs. Inspired by\n     * https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#what-about-memoization\n     */\n    prevItems: Array<DropdownItem>;\n    /**\n     * Whether the set of items that are focusable are the same, used for\n     * resetting focusedIndex and focusedOriginalIndex when an update happens.\n     */\n    sameItemsFocusable: boolean;\n}>;\n\n/**\n * A core dropdown component that takes an opener and children to display as\n * part of the dropdown menu. Renders the dropdown as a portal to avoid clipping\n * in overflow: auto containers.\n */\nclass DropdownCore extends React.Component<Props, State> {\n    // Keeps track of the index of the focused item, out of a list of focusable items\n    // @ts-expect-error [FEI-5019] - TS2564 - Property 'focusedIndex' has no initializer and is not definitely assigned in the constructor.\n    focusedIndex: number;\n    // Keeps track of the index of the focused item in the context of all the\n    // items contained by this menu, whether focusable or not, used for figuring\n    // out focus correctly when the items have changed in terms of whether\n    // they're focusable or not\n    // @ts-expect-error [FEI-5019] - TS2564 - Property 'focusedOriginalIndex' has no initializer and is not definitely assigned in the constructor.\n    focusedOriginalIndex: number;\n    // Whether any items have been selected since the menu was opened\n    // @ts-expect-error [FEI-5019] - TS2564 - Property 'itemsClicked' has no initializer and is not definitely assigned in the constructor.\n    itemsClicked: boolean;\n    popperElement: HTMLElement | null | undefined;\n    // Keeps a reference of the virtualized list instance\n    virtualizedListRef: {\n        current: null | React.ElementRef<typeof List>;\n    };\n\n    handleKeyDownDebounced: (key: string) => void;\n\n    textSuggestion: string;\n\n    // Figure out if the same items are focusable. If an item has been added or\n    // removed, this method will return false.\n    static sameItemsFocusable(\n        prevItems: Array<DropdownItem>,\n        currentItems: Array<DropdownItem>,\n    ): boolean {\n        if (prevItems.length !== currentItems.length) {\n            return false;\n        }\n        for (let i = 0; i < prevItems.length; i++) {\n            if (prevItems[i].focusable !== currentItems[i].focusable) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    static defaultProps: DefaultProps = {\n        alignment: \"left\",\n        autoFocus: true,\n        enableTypeAhead: true,\n        labels: {\n            clearSearch: defaultLabels.clearSearch,\n            filter: defaultLabels.filter,\n            noResults: defaultLabels.noResults,\n            someResults: defaultLabels.someSelected,\n        },\n        light: false,\n        selectionType: \"single\",\n    };\n\n    // This is here to avoid calling React.createRef on each rerender. Instead,\n    // we create the itemRefs only if it's the first time or if the set of items\n    // that are focusable has changed.\n    static getDerivedStateFromProps(\n        props: Props,\n        state: State,\n    ): Partial<State> {\n        if (\n            (state.itemRefs.length === 0 && props.open) ||\n            !DropdownCore.sameItemsFocusable(state.prevItems, props.items)\n        ) {\n            const itemRefs: Array<{\n                originalIndex: number;\n                ref: {\n                    current: null | HTMLDivElement;\n                };\n            }> = [];\n            for (let i = 0; i < props.items.length; i++) {\n                if (props.items[i].focusable) {\n                    const ref = React.createRef<null | HTMLDivElement>();\n                    itemRefs.push({ref, originalIndex: i});\n                }\n            }\n            return {\n                itemRefs,\n                prevItems: props.items,\n                sameItemsFocusable: false,\n            };\n        } else {\n            return {\n                prevItems: props.items,\n                sameItemsFocusable: true,\n            };\n        }\n    }\n\n    constructor(props: Props) {\n        super(props);\n\n        // Apply our initial focus index\n        this.resetFocusedIndex();\n\n        this.state = {\n            prevItems: this.props.items,\n            itemRefs: [],\n            sameItemsFocusable: false,\n            labels: {\n                // @ts-expect-error [FEI-5019] - TS2783 - 'noResults' is specified more than once, so this usage will be overwritten.\n                noResults: defaultLabels.noResults,\n                // In case we are not overriding this from the caller.\n                // @ts-expect-error [FEI-5019] - TS2783 - 'someResults' is specified more than once, so this usage will be overwritten.\n                someResults: defaultLabels.someSelected,\n                ...props.labels,\n            },\n        };\n\n        this.virtualizedListRef = React.createRef();\n\n        // We debounce the keydown handler to get the ASCII chars because it's\n        // called on every keydown\n        this.handleKeyDownDebounced = debounce(\n            this.handleKeyDownDebounceResult,\n            // Leaving enough time for the user to type a valid query (e.g. jul)\n            500,\n        );\n        this.textSuggestion = \"\";\n    }\n\n    componentDidMount() {\n        this.updateEventListeners();\n        this.maybeFocusInitialItem();\n    }\n\n    componentDidUpdate(prevProps: Props) {\n        const {open} = this.props;\n\n        if (prevProps.open !== open) {\n            this.updateEventListeners();\n            this.maybeFocusInitialItem();\n        }\n        // If the menu changed, but from open to open, figure out if we need\n        // to recalculate the focus somehow.\n        else if (open) {\n            const {itemRefs, sameItemsFocusable} = this.state;\n            // Check if the same items are focused by comparing the items at\n            // each index and seeing if the {focusable} property is the same.\n            // Very rarely do the set of focusable items change if the menu\n            // hasn't been re-opened. This is for cases like a {Select all}\n            // option that becomes disabled iff all the options are selected.\n            if (sameItemsFocusable) {\n                return;\n            } else {\n                // If the set of items that was focusabled changed, it's very\n                // likely that the previously focused item no longer has the\n                // same index relative to the list of focusable items. Instead,\n                // use the focusedOriginalIndex to find the new index of the\n                // last item that was focused before this change\n                const newFocusableIndex = itemRefs.findIndex(\n                    (ref) => ref.originalIndex === this.focusedOriginalIndex,\n                );\n                if (newFocusableIndex === -1) {\n                    // Can't find the originally focused item, return focus to\n                    // the first item that IS focusable\n                    this.focusedIndex = 0;\n                    // Reset the knowlege that things had been clicked\n                    this.itemsClicked = false;\n                    this.scheduleToFocusCurrentItem();\n                } else {\n                    this.focusedIndex = newFocusableIndex;\n                }\n            }\n\n            if (this.props.labels !== prevProps.labels) {\n                // eslint-disable-next-line react/no-did-update-set-state\n                this.setState({\n                    labels: {...this.state.labels, ...this.props.labels},\n                });\n            }\n        }\n    }\n\n    componentWillUnmount() {\n        this.removeEventListeners();\n    }\n\n    searchFieldRef: {\n        current: null | HTMLInputElement;\n    } = React.createRef();\n\n    // Resets our initial focus index to what was passed in via the props\n    resetFocusedIndex(): void {\n        const {initialFocusedIndex} = this.props;\n\n        // If we are given an initial focus index, select it. Otherwise default\n        // to the first item\n        if (typeof initialFocusedIndex !== \"undefined\") {\n            this.focusedIndex = initialFocusedIndex;\n        } else {\n            if (this.hasSearchField() && !this.isSearchFieldFocused()) {\n                return this.focusSearchField();\n            }\n\n            this.focusedIndex = 0;\n        }\n    }\n\n    // Figure out focus states for the dropdown after it has changed from open\n    // to closed or vice versa\n    maybeFocusInitialItem() {\n        const {autoFocus, open} = this.props;\n\n        if (!autoFocus) {\n            return;\n        }\n\n        if (open) {\n            this.resetFocusedIndex();\n            this.scheduleToFocusCurrentItem();\n        } else if (!open) {\n            this.itemsClicked = false;\n        }\n    }\n\n    updateEventListeners() {\n        if (this.props.open) {\n            this.addEventListeners();\n        } else {\n            this.removeEventListeners();\n        }\n    }\n\n    addEventListeners() {\n        document.addEventListener(\"mouseup\", this.handleInteract);\n        document.addEventListener(\"touchend\", this.handleInteract);\n    }\n\n    removeEventListeners() {\n        document.removeEventListener(\"mouseup\", this.handleInteract);\n        document.removeEventListener(\"touchend\", this.handleInteract);\n    }\n\n    handleInteract: (event: Event) => void = (event) => {\n        const {open, onOpenChanged} = this.props;\n        const target: Node = event.target as any;\n        const thisElement = ReactDOM.findDOMNode(this);\n        if (\n            open &&\n            thisElement &&\n            !thisElement.contains(target) &&\n            this.popperElement &&\n            !this.popperElement.contains(target)\n        ) {\n            onOpenChanged(false);\n        }\n    };\n\n    scheduleToFocusCurrentItem(\n        onFocus?: (node: undefined | HTMLElement) => void,\n    ) {\n        if (this.shouldVirtualizeList()) {\n            // wait for windowed items to be recalculated\n            this.props.schedule.animationFrame(() => {\n                this.focusCurrentItem(onFocus);\n            });\n        } else {\n            // immediately focus the current item if we're not virtualizing\n            this.focusCurrentItem(onFocus);\n        }\n    }\n\n    /**\n     * Focus on the current item.\n     * @param [onFocus] - Callback to be called when the item is focused.\n     */\n    focusCurrentItem(onFocus?: (node: HTMLElement) => void) {\n        const focusedItemRef = this.state.itemRefs[this.focusedIndex];\n\n        if (focusedItemRef) {\n            // force react-window to scroll to ensure the focused item is visible\n            if (this.virtualizedListRef.current) {\n                // Our focused index does not include disabled items, but the\n                // react-window index system does include the disabled items\n                // in the count.  So we need to use \"originalIndex\", which\n                // does account for disabled items.\n                this.virtualizedListRef.current.scrollToItem(\n                    focusedItemRef.originalIndex,\n                );\n            }\n\n            const node = ReactDOM.findDOMNode(\n                focusedItemRef.ref.current,\n            ) as HTMLElement;\n            if (node) {\n                node.focus();\n                // Keep track of the original index of the newly focused item.\n                // To be used if the set of focusable items in the menu changes\n                this.focusedOriginalIndex = focusedItemRef.originalIndex;\n\n                if (onFocus) {\n                    // Call the callback with the node that was focused.\n                    onFocus(node);\n                }\n            }\n        }\n    }\n\n    focusSearchField() {\n        if (this.searchFieldRef.current) {\n            this.searchFieldRef.current.focus();\n        }\n    }\n\n    hasSearchField(): boolean {\n        return !!this.props.isFilterable;\n    }\n\n    isSearchFieldFocused(): boolean {\n        return (\n            this.hasSearchField() &&\n            document.activeElement === this.searchFieldRef.current\n        );\n    }\n\n    focusPreviousItem(): void {\n        if (this.focusedIndex === 0) {\n            // Move the focus to the search field if it is the first item.\n            if (this.hasSearchField() && !this.isSearchFieldFocused()) {\n                return this.focusSearchField();\n            }\n            this.focusedIndex = this.state.itemRefs.length - 1;\n        } else {\n            this.focusedIndex -= 1;\n        }\n\n        this.scheduleToFocusCurrentItem();\n    }\n\n    focusNextItem(): void {\n        if (this.focusedIndex === this.state.itemRefs.length - 1) {\n            // Move the focus to the search field if it is the last item.\n            if (this.hasSearchField() && !this.isSearchFieldFocused()) {\n                return this.focusSearchField();\n            }\n            this.focusedIndex = 0;\n        } else {\n            this.focusedIndex += 1;\n        }\n\n        this.scheduleToFocusCurrentItem();\n    }\n\n    restoreTabOrder() {\n        // NOTE: Because the dropdown is portalled out of its natural\n        // position in the DOM, we need to manually return focus to the\n        // opener element before we let the natural propagation of tab\n        // shift the focus to the next element in the tab order.\n        if (this.props.openerElement) {\n            this.props.openerElement.focus();\n        }\n    }\n\n    handleKeyDown: (event: React.KeyboardEvent) => void = (event) => {\n        const {enableTypeAhead, onOpenChanged, open, searchText} = this.props;\n        const keyCode = event.which || event.keyCode;\n\n        // Listen for the keydown events if we are using ASCII characters.\n        if (enableTypeAhead && getStringForKey(event.key)) {\n            event.stopPropagation();\n            this.textSuggestion += event.key;\n            // Trigger the filter logic only after the debounce is resolved.\n            this.handleKeyDownDebounced(this.textSuggestion);\n        }\n\n        // If menu isn't open and user presses down, open the menu\n        if (!open) {\n            if (keyCode === keyCodes.down) {\n                event.preventDefault();\n                onOpenChanged(true);\n                return;\n            }\n            return;\n        }\n\n        // Handle all other key behavior\n        switch (keyCode) {\n            case keyCodes.tab:\n                // When we show SearchField and that is focused and the\n                // searchText is entered at least one character, dismiss button\n                // is displayed. When user presses tab, we should move focus to\n                // the dismiss button.\n                if (this.isSearchFieldFocused() && searchText) {\n                    return;\n                }\n                this.restoreTabOrder();\n                onOpenChanged(false);\n                return;\n            case keyCodes.space:\n                // When we display SearchField and the focus is on it, we should\n                // let the user type space.\n                if (this.isSearchFieldFocused()) {\n                    return;\n                }\n                // Prevent space from scrolling down the page\n                event.preventDefault();\n                return;\n            case keyCodes.up:\n                event.preventDefault();\n                this.focusPreviousItem();\n                return;\n            case keyCodes.down:\n                event.preventDefault();\n                this.focusNextItem();\n                return;\n        }\n    };\n\n    // Some keys should be handled during the keyup event instead.\n    handleKeyUp: (event: React.KeyboardEvent) => void = (event) => {\n        const {onOpenChanged, open} = this.props;\n        const keyCode = event.which || event.keyCode;\n        switch (keyCode) {\n            case keyCodes.space:\n                // When we display SearchField and the focus is on it, we should\n                // let the user type space.\n                if (this.isSearchFieldFocused()) {\n                    return;\n                }\n                // Prevent space from scrolling down the page\n                event.preventDefault();\n                return;\n            case keyCodes.escape:\n                // Close only the dropdown, not other elements that are\n                // listening for an escape press\n                if (open) {\n                    event.stopPropagation();\n                    this.restoreTabOrder();\n                    onOpenChanged(false);\n                }\n                return;\n        }\n    };\n\n    handleKeyDownDebounceResult: (key: string) => void = (key) => {\n        const foundIndex = this.props.items\n            .filter((item) => item.focusable)\n            .findIndex(({component}) => {\n                if (SeparatorItem.isClassOf(component)) {\n                    return false;\n                }\n\n                // TypeScript doesn't know that the component is an OptionItem\n                // @ts-expect-error [FEI-5019] - TS2339 - Property 'label' does not exist on type '{}'.\n                const label = component.props?.label.toLowerCase();\n\n                return label.startsWith(key.toLowerCase());\n            });\n\n        if (foundIndex >= 0) {\n            const isClosed = !this.props.open;\n            if (isClosed) {\n                // Open the menu to be able to focus on the item that matches\n                // the text suggested.\n                this.props.onOpenChanged(true);\n            }\n            // Update the focus reference.\n            this.focusedIndex = foundIndex;\n\n            this.scheduleToFocusCurrentItem((node) => {\n                // Force click only if the dropdown is closed and we are using\n                // the SingleSelect component.\n                if (this.props.selectionType === \"single\" && isClosed && node) {\n                    node.click();\n                    this.props.onOpenChanged(false);\n                }\n            });\n        }\n\n        // Otherwise, reset current text\n        this.textSuggestion = \"\";\n    };\n\n    handleClickFocus: (index: number) => void = (index) => {\n        // Turn itemsClicked on so pressing up or down would focus the\n        // appropriate item in handleKeyDown\n        this.itemsClicked = true;\n        this.focusedIndex = index;\n        this.focusedOriginalIndex =\n            this.state.itemRefs[this.focusedIndex].originalIndex;\n    };\n\n    handleDropdownMouseUp: (event: React.MouseEvent) => void = (event) => {\n        if (event.nativeEvent.stopImmediatePropagation) {\n            event.nativeEvent.stopImmediatePropagation();\n        } else {\n            // Workaround for jsdom\n            event.stopPropagation();\n        }\n    };\n\n    getItemRole(): ItemAriaRole {\n        const {role} = this.props;\n\n        switch (role) {\n            case \"listbox\":\n                return \"option\";\n            case \"menu\":\n                return \"menuitem\";\n            default:\n                throw new Error(\n                    `Expected \"listbox\" or \"menu\" for role, but receieved \"${role}\" instead.`,\n                );\n        }\n    }\n\n    maybeRenderNoResults(): React.ReactNode {\n        const {\n            items,\n            labels: {noResults},\n        } = this.props;\n\n        // Verify if there are items to be rendered or not\n        const numResults = items.length;\n\n        if (numResults === 0) {\n            return (\n                <LabelMedium\n                    style={styles.noResult}\n                    testId=\"dropdown-core-no-results\"\n                >\n                    {noResults}\n                </LabelMedium>\n            );\n        }\n        return null;\n    }\n\n    /**\n     * Handles click events for each item in the dropdown.\n     */\n    handleItemClick: (focusIndex: number, item: DropdownItem) => void = (\n        focusIndex: number,\n        item: DropdownItem,\n    ) => {\n        this.handleClickFocus(focusIndex);\n        // @ts-expect-error [FEI-5019] - TS2339 - Property 'onClick' does not exist on type '{}'.\n        if (item.component.props.onClick) {\n            // @ts-expect-error [FEI-5019] - TS2339 - Property 'onClick' does not exist on type '{}'.\n            item.component.props.onClick();\n        }\n        if (item.populatedProps.onClick) {\n            item.populatedProps.onClick();\n        }\n    };\n\n    /**\n     * Determines which rendering strategy we are going to apply to the options\n     * list.\n     */\n    shouldVirtualizeList(): boolean {\n        // Verify if the list is long enough to be virtualized (passes the\n        // threshold).\n        return this.props.items.length > VIRTUALIZE_THRESHOLD;\n    }\n\n    /**\n     * Renders the non-virtualized list of items.\n     */\n    renderList(): React.ReactNode {\n        let focusCounter = 0;\n        const itemRole = this.getItemRole();\n\n        // if we don't need to virtualize, we can render the list directly\n        return this.props.items.map((item, index) => {\n            if (SeparatorItem.isClassOf(item.component)) {\n                return item.component;\n            }\n\n            const {component, focusable, populatedProps} = item;\n\n            if (focusable) {\n                focusCounter += 1;\n            }\n\n            const focusIndex = focusCounter - 1;\n            // The reference to the item is used to restore focus.\n            const currentRef = this.state.itemRefs[focusIndex]\n                ? this.state.itemRefs[focusIndex].ref\n                : null;\n\n            // Render OptionItem and/or ActionItem elements.\n            return React.cloneElement(component, {\n                ...populatedProps,\n                key: index,\n                onClick: () => {\n                    this.handleItemClick(focusIndex, item);\n                },\n                // Only pass the ref if the item is focusable.\n                ref: focusable ? currentRef : null,\n                role: itemRole,\n            });\n        });\n    }\n\n    /**\n     * Process the items and wrap them into an array that react-window can\n     * interpret.\n     *\n     * NOTE: The main difference with the collection in renderList() is that we\n     * massage the items to be able to clone them later in\n     * DropdownVirtualizedItem, where as renderList() clones the items directly.\n     */\n    parseVirtualizedItems(): Array<DropdownItem> {\n        let focusCounter = 0;\n        const itemRole = this.getItemRole();\n\n        return this.props.items.map((item, index) => {\n            if (!SeparatorItem.isClassOf(item.component) && item.focusable) {\n                focusCounter += 1;\n            }\n\n            const focusIndex = focusCounter - 1;\n\n            return {\n                ...item,\n                role: itemRole,\n                ref: item.focusable\n                    ? this.state.itemRefs[focusIndex]\n                        ? this.state.itemRefs[focusIndex].ref\n                        : null\n                    : null,\n                onClick: () => {\n                    this.handleItemClick(focusIndex, item);\n                },\n            };\n        });\n    }\n\n    /**\n     * Render the items using a virtualized list\n     */\n    renderVirtualizedList(): React.ReactNode {\n        // preprocess items data to pass it to the renderer\n        const virtualizedItems = this.parseVirtualizedItems();\n        return (\n            <DropdownCoreVirtualized\n                data={virtualizedItems}\n                listRef={this.virtualizedListRef}\n            />\n        );\n    }\n\n    handleSearchTextChanged: (searchText: string) => void = (\n        searchText: string,\n    ) => {\n        const {onSearchTextChanged} = this.props;\n\n        if (onSearchTextChanged) {\n            onSearchTextChanged(searchText);\n        }\n    };\n\n    renderSearchField(): React.ReactNode {\n        const {searchText} = this.props;\n        const {labels} = this.state;\n\n        return (\n            <SearchField\n                clearAriaLabel={labels.clearSearch}\n                onChange={this.handleSearchTextChanged}\n                placeholder={labels.filter}\n                ref={this.searchFieldRef}\n                style={styles.searchInputStyle}\n                value={searchText || \"\"}\n            />\n        );\n    }\n\n    renderDropdownMenu(\n        listRenderer: React.ReactNode,\n        isReferenceHidden?: boolean | null,\n    ): React.ReactNode {\n        const {dropdownStyle, light, openerElement} = this.props;\n\n        // The dropdown width is at least the width of the opener.\n        // It's only used if the element exists in the DOM\n        const openerStyle =\n            openerElement && window.getComputedStyle(openerElement);\n        const minDropdownWidth = openerStyle\n            ? openerStyle.getPropertyValue(\"width\")\n            : 0;\n\n        const maxDropdownHeight = getDropdownMenuHeight(this.props.items);\n\n        return (\n            <View\n                // Stop propagation to prevent the mouseup listener on the\n                // document from closing the menu.\n                onMouseUp={this.handleDropdownMouseUp}\n                style={[\n                    styles.dropdown,\n                    light && styles.light,\n                    isReferenceHidden && styles.hidden,\n                    dropdownStyle,\n                ]}\n                testId=\"dropdown-core-container\"\n            >\n                {this.props.isFilterable && this.renderSearchField()}\n                <View\n                    role={this.props.role}\n                    style={[\n                        styles.listboxOrMenu,\n                        generateDropdownMenuStyles(\n                            // @ts-expect-error [FEI-5019] - TS2345 - Argument of type 'string | 0' is not assignable to parameter of type 'number'.\n                            minDropdownWidth,\n                            maxDropdownHeight,\n                        ),\n                    ]}\n                >\n                    {listRenderer}\n                </View>\n                {this.maybeRenderNoResults()}\n            </View>\n        );\n    }\n\n    renderDropdown(): React.ReactNode {\n        const {alignment, openerElement} = this.props;\n\n        // Preprocess the items that are used inside the Popper instance. By\n        // doing this, we optimize the list to be processed only one time\n        // instead of every time popper changes.\n        // NOTE: This improves the performance impact of the dropdown by\n        // reducing the execution time up to 2.5X.\n        const listRenderer = this.shouldVirtualizeList()\n            ? this.renderVirtualizedList()\n            : this.renderList();\n\n        return (\n            <DropdownPopper\n                alignment={alignment}\n                onPopperElement={(popperElement) => {\n                    this.popperElement = popperElement;\n                }}\n                referenceElement={openerElement}\n            >\n                {(isReferenceHidden) =>\n                    this.renderDropdownMenu(listRenderer, isReferenceHidden)\n                }\n            </DropdownPopper>\n        );\n    }\n\n    renderLiveRegion(): React.ReactNode {\n        const {items, open} = this.props;\n        const {labels} = this.state;\n        const totalItems = items.length;\n\n        return (\n            <StyledSpan\n                aria-live=\"polite\"\n                aria-atomic=\"true\"\n                aria-relevant=\"additions text\"\n                style={styles.srOnly}\n                data-test-id=\"dropdown-live-region\"\n            >\n                {open && labels.someResults(totalItems)}\n            </StyledSpan>\n        );\n    }\n\n    render(): React.ReactNode {\n        const {open, opener, style, className} = this.props;\n\n        return (\n            <View\n                onKeyDown={this.handleKeyDown}\n                onKeyUp={this.handleKeyUp}\n                style={[styles.menuWrapper, style]}\n                className={className}\n            >\n                {this.renderLiveRegion()}\n                {opener}\n                {open && this.renderDropdown()}\n            </View>\n        );\n    }\n}\n\nconst styles = StyleSheet.create({\n    menuWrapper: {\n        width: \"fit-content\",\n    },\n\n    dropdown: {\n        backgroundColor: Color.white,\n        borderRadius: 4,\n        paddingTop: Spacing.xxxSmall_4,\n        paddingBottom: Spacing.xxxSmall_4,\n        border: `solid 1px ${Color.offBlack16}`,\n        boxShadow: `0px 8px 8px 0px ${fade(Color.offBlack, 0.1)}`,\n    },\n\n    light: {\n        // Pretty much just remove the border\n        border: \"none\",\n    },\n\n    listboxOrMenu: {\n        overflowY: \"auto\",\n    },\n\n    hidden: {\n        pointerEvents: \"none\",\n        visibility: \"hidden\",\n    },\n\n    noResult: {\n        color: Color.offBlack64,\n        alignSelf: \"center\",\n        marginTop: Spacing.xxSmall_6,\n    },\n\n    searchInputStyle: {\n        margin: Spacing.xSmall_8,\n        marginTop: Spacing.xxxSmall_4,\n        // Set `minHeight` to \"auto\" to stop the search field from having\n        // a height of 0 and being cut off.\n        minHeight: \"auto\",\n    },\n\n    srOnly: {\n        border: 0,\n        clip: \"rect(0,0,0,0)\",\n        height: 1,\n        margin: -1,\n        overflow: \"hidden\",\n        padding: 0,\n        position: \"absolute\",\n        width: 1,\n    },\n});\n\nexport default withActionScheduler(\n    DropdownCore,\n    // NOTE(kevinb): We convert to unknown first before converting to the property type.\n    // This is because TypeScript doesn't like how we're changing props that have default\n    // props.\n) as unknown as React.ComponentType<ExportProps>;\n","import * as React from \"react\";\nimport {StyleSheet} from \"aphrodite\";\n\nimport {LabelLarge} from \"@khanacademy/wonder-blocks-typography\";\nimport Color, {SemanticColor, mix} from \"@khanacademy/wonder-blocks-color\";\nimport {addStyle, View} from \"@khanacademy/wonder-blocks-core\";\nimport Icon, {icons} from \"@khanacademy/wonder-blocks-icon\";\nimport Spacing from \"@khanacademy/wonder-blocks-spacing\";\nimport {Strut} from \"@khanacademy/wonder-blocks-layout\";\nimport type {AriaProps} from \"@khanacademy/wonder-blocks-core\";\nimport type {ClickableState} from \"@khanacademy/wonder-blocks-clickable\";\n\nimport {DROPDOWN_ITEM_HEIGHT} from \"../util/constants\";\n\ntype Props = Partial<Omit<AriaProps, \"aria-disabled\">> &\n    ClickableState & {\n        /**\n         * Display text for the opener.\n         */\n        children: string;\n        /**\n         * Whether the opener is disabled. If disabled, disallows interaction.\n         */\n        disabled?: boolean;\n        /**\n         * Test ID used for e2e testing.\n         */\n        testId?: string;\n        /**\n         * Whether the dropdown is open.\n         */\n        opened: boolean;\n    };\n\nconst StyledButton = addStyle(\"button\");\n\n/**\n * Although this component shares a lot with ButtonCore there are a couple\n * of differences:\n * - the down caret icon appears on the right instead of the left\n * - the down caret icon is smaller that the one that would be used by ButtonCore\n */\nexport default class ActionMenuOpenerCore extends React.Component<Props> {\n    render(): React.ReactNode {\n        const {\n            children,\n            disabled: disabledProp,\n            focused,\n            hovered,\n            pressed,\n            waiting: _,\n            testId,\n            opened,\n            \"aria-label\": ariaLabel,\n            ...restProps\n        } = this.props;\n\n        const buttonColor = SemanticColor.controlDefault;\n        const buttonStyles = _generateStyles(buttonColor);\n        const disabled = disabledProp;\n\n        const defaultStyle = [\n            sharedStyles.shared,\n            disabled && sharedStyles.disabled,\n            buttonStyles.default,\n            disabled && buttonStyles.disabled,\n            !disabled && pressed && buttonStyles.active,\n        ];\n\n        const label = (\n            <LabelLarge style={sharedStyles.text}>{children}</LabelLarge>\n        );\n\n        return (\n            <StyledButton\n                aria-expanded={opened ? \"true\" : \"false\"}\n                aria-haspopup=\"menu\"\n                aria-label={ariaLabel}\n                disabled={disabled}\n                style={defaultStyle}\n                type=\"button\"\n                {...restProps}\n                data-test-id={testId}\n            >\n                <View\n                    style={\n                        !disabled && (hovered || focused) && buttonStyles.focus\n                    }\n                >\n                    {label}\n                </View>\n                <Strut size={Spacing.xxxSmall_4} />\n                <Icon\n                    size=\"small\"\n                    color=\"currentColor\"\n                    icon={icons.caretDown}\n                />\n            </StyledButton>\n        );\n    }\n}\n\nconst sharedStyles = StyleSheet.create({\n    shared: {\n        position: \"relative\",\n        display: \"inline-flex\",\n        alignItems: \"center\",\n        justifyContent: \"center\",\n        height: DROPDOWN_ITEM_HEIGHT,\n        border: \"none\",\n        borderRadius: Spacing.xxxSmall_4,\n        cursor: \"pointer\",\n        outline: \"none\",\n        textDecoration: \"none\",\n        boxSizing: \"border-box\",\n        // This removes the 300ms click delay on mobile browsers by indicating that\n        // \"double-tap to zoom\" shouldn't be used on this element.\n        touchAction: \"manipulation\",\n        \":focus\": {\n            // Mobile: Removes a blue highlight style shown when the user clicks a button\n            WebkitTapHighlightColor: \"rgba(0,0,0,0)\",\n        },\n    },\n    disabled: {\n        cursor: \"auto\",\n    },\n    small: {\n        height: Spacing.xLarge_32,\n    },\n    text: {\n        textAlign: \"left\",\n        display: \"inline-block\",\n        alignItems: \"center\",\n        fontWeight: \"bold\",\n        userSelect: \"none\",\n        whiteSpace: \"nowrap\",\n        overflow: \"hidden\",\n        textOverflow: \"ellipsis\",\n        pointerEvents: \"none\", // fix Safari bug where the browser was eating mouse events\n    },\n    hiddenText: {\n        visibility: \"hidden\",\n    },\n    spinner: {\n        position: \"absolute\",\n    },\n});\n\nconst styles: Record<string, any> = {};\n\nconst _generateStyles = (color: string) => {\n    const buttonType = color;\n    if (styles[buttonType]) {\n        return styles[buttonType];\n    }\n\n    const {offBlack32} = Color;\n    const activeColor = mix(offBlack32, color);\n\n    let newStyles: Record<string, any> = {};\n\n    newStyles = {\n        default: {\n            background: \"none\",\n            color: color,\n        },\n        focus: {\n            \":after\": {\n                content: \"''\",\n                position: \"absolute\",\n                height: 2,\n                left: 0,\n                right: 0,\n                bottom: -1,\n                background: \"currentColor\",\n                borderRadius: 2,\n            },\n        },\n        active: {\n            color: activeColor,\n        },\n        disabled: {\n            color: offBlack32,\n            cursor: \"default\",\n        },\n    };\n\n    styles[buttonType] = StyleSheet.create(newStyles);\n    return styles[buttonType];\n};\n","import * as React from \"react\";\nimport * as ReactDOM from \"react-dom\";\nimport {StyleSheet} from \"aphrodite\";\nimport type {AriaProps, StyleType} from \"@khanacademy/wonder-blocks-core\";\nimport DropdownOpener from \"./dropdown-opener\";\nimport ActionItem from \"./action-item\";\nimport OptionItem from \"./option-item\";\nimport DropdownCore from \"./dropdown-core\";\n\nimport ActionMenuOpenerCore from \"./action-menu-opener-core\";\nimport type {Item, DropdownItem, OpenerProps} from \"../util/types\";\n\ntype Props = AriaProps &\n    Readonly<{\n        /**\n         * The items in this dropdown.\n         */\n        children?: Array<Item> | Item;\n        /**\n         * Text for the opener of this menu.\n         */\n        menuText: string;\n        /**\n         * Can be used to override the state of the ActionMenu by parent elements\n         */\n        opened?: boolean;\n        /**\n         * In controlled mode, use this prop in case the parent needs to be notified\n         * when the menu opens/closes.\n         */\n        onToggle?: (opened: boolean) => unknown;\n        /**\n         * A callback that returns items that are newly selected. Use only if this\n         * menu contains select items (and make sure selectedValues is defined).\n         */\n        onChange?: (selectedItems: Array<string>) => unknown;\n        /**\n         * The values of the items that are currently selected. Use only if this\n         * menu contains select items (and make sure onChange is defined).\n         */\n        selectedValues?: Array<string>;\n        /**\n         * Whether this menu should be left-aligned or right-aligned with the\n         * opener component. Defaults to left-aligned.\n         */\n        alignment: \"left\" | \"right\";\n        /**\n         * Whether this component is disabled. A disabled dropdown may not be opened\n         * and does not support interaction. Defaults to false.\n         */\n        disabled: boolean;\n        /**\n         * Test ID used for e2e testing.\n         */\n        testId?: string;\n        /**\n         * Styling specific to the dropdown component that isn't part of the opener,\n         * passed by the specific implementation of the dropdown menu,\n         */\n        dropdownStyle?: StyleType;\n        /**\n         * Optional styling for the entire dropdown component.\n         */\n        style?: StyleType;\n        /**\n         * Optional CSS classes for the entire dropdown component.\n         */\n        className?: string;\n        /**\n         * The child function that returns the anchor the ActionMenu will be\n         * activated by. This function takes eventState, which allows the opener\n         * element to access pointer event state.\n         */\n        opener?: (openerProps: OpenerProps) => React.ReactElement<any>;\n    }>;\n\ntype State = Readonly<{\n    /**\n     * Whether or not the dropdown is open.\n     */\n    opened: boolean;\n}>;\n\ntype DefaultProps = Readonly<{\n    alignment: Props[\"alignment\"];\n    disabled: Props[\"disabled\"];\n}>;\n\n/**\n * A menu that consists of various types of items.\n *\n * ## Usage\n *\n * ```jsx\n * import {ActionMenu, ActionItem} from \"@khanacademy/wonder-blocks-dropdown\";\n *\n * <ActionMenu menuText=\"Menu\">\n *  <ActionItem href=\"/profile\" label=\"Profile\" />\n *  <ActionItem label=\"Settings\" onClick={() => {}} />\n * </ActionMenu>\n * ```\n */\nexport default class ActionMenu extends React.Component<Props, State> {\n    openerElement?: HTMLElement;\n\n    static defaultProps: DefaultProps = {\n        alignment: \"left\",\n        disabled: false,\n    };\n\n    state: State = {\n        opened: false,\n    };\n\n    /**\n     * Used to sync the `opened` state when this component acts as a controlled\n     * component\n     */\n    static getDerivedStateFromProps(\n        props: Props,\n        state: State,\n    ): Partial<State> | null {\n        return {\n            opened:\n                typeof props.opened === \"boolean\" ? props.opened : state.opened,\n        };\n    }\n\n    handleItemSelected: () => void = () => {\n        // close menu\n        this.handleOpenChanged(false);\n\n        // Bring focus back to the opener element.\n        if (this.openerElement) {\n            this.openerElement.focus();\n        }\n    };\n\n    handleOpenChanged: (opened: boolean) => void = (opened) => {\n        this.setState({\n            opened,\n        });\n\n        if (this.props.onToggle) {\n            this.props.onToggle(opened);\n        }\n    };\n\n    handleOptionSelected: (selectedValue: string) => void = (selectedValue) => {\n        const {onChange, selectedValues} = this.props;\n\n        // If either of these are not defined, return.\n        if (!onChange || !selectedValues) {\n            return;\n        }\n\n        if (selectedValues.includes(selectedValue)) {\n            const index = selectedValues.indexOf(selectedValue);\n            const updatedSelection = [\n                ...selectedValues.slice(0, index),\n                ...selectedValues.slice(index + 1),\n            ];\n            onChange(updatedSelection);\n        } else {\n            // Item was newly selected\n            onChange([...selectedValues, selectedValue]);\n        }\n        this.handleItemSelected();\n    };\n\n    getMenuItems(): Array<DropdownItem> {\n        const {children, selectedValues} = this.props;\n        const allChildren = React.Children.toArray(children).filter(Boolean);\n\n        // verify if there's at least one OptionItem element to indent the\n        // possible Action items\n        const isOptionItemIncluded = allChildren.some((item) =>\n            // @ts-expect-error [FEI-5019] - TS2345 - Argument of type 'ReactChild | ReactFragment | ReactPortal' is not assignable to parameter of type 'ReactElement<any, string | JSXElementConstructor<any>>'.\n            OptionItem.isClassOf(item),\n        );\n\n        // @ts-expect-error [FEI-5019] - TS2322 - Type '({ readonly component: ReactChild | ReactFragment | ReactPortal; readonly focusable: boolean; readonly populatedProps: {}; } | { populatedProps: { ...; }; component: ReactChild | ... 1 more ... | ReactPortal; focusable: boolean; } | { ...; })[]' is not assignable to type 'DropdownItem[]'.\n        return allChildren.map((item) => {\n            // @ts-expect-error [FEI-5019] - TS2339 - Property 'props' does not exist on type 'ReactChild | ReactFragment | ReactPortal'.\n            const {value, disabled} = item.props;\n            const itemObject = {\n                component: item,\n                focusable:\n                    // @ts-expect-error [FEI-5019] - TS2345 - Argument of type 'ReactChild | ReactFragment | ReactPortal' is not assignable to parameter of type 'ReactElement<any, string | JSXElementConstructor<any>>'. | TS2345 - Argument of type 'ReactChild | ReactFragment | ReactPortal' is not assignable to parameter of type 'ReactElement<any, string | JSXElementConstructor<any>>'.\n                    ActionItem.isClassOf(item) || OptionItem.isClassOf(item)\n                        ? !disabled\n                        : false,\n                populatedProps: {},\n            } as const;\n            // @ts-expect-error [FEI-5019] - TS2345 - Argument of type 'ReactChild | ReactFragment | ReactPortal' is not assignable to parameter of type 'ReactElement<any, string | JSXElementConstructor<any>>'.\n            if (ActionItem.isClassOf(item)) {\n                return {\n                    ...itemObject,\n                    populatedProps: {\n                        indent: isOptionItemIncluded,\n                        onClick: this.handleItemSelected,\n                    },\n                };\n                // @ts-expect-error [FEI-5019] - TS2345 - Argument of type 'ReactChild | ReactFragment | ReactPortal' is not assignable to parameter of type 'ReactElement<any, string | JSXElementConstructor<any>>'.\n            } else if (OptionItem.isClassOf(item)) {\n                return {\n                    ...itemObject,\n                    populatedProps: {\n                        onToggle: this.handleOptionSelected,\n                        selected: selectedValues\n                            ? selectedValues.includes(value)\n                            : false,\n                        variant: \"check\",\n                    },\n                };\n            } else {\n                return itemObject;\n            }\n        });\n    }\n\n    handleOpenerRef: (node?: any) => void = (node) => {\n        this.openerElement = ReactDOM.findDOMNode(node) as HTMLElement;\n    };\n\n    handleClick: (e: React.SyntheticEvent) => void = (e) => {\n        this.handleOpenChanged(!this.state.opened);\n    };\n\n    renderOpener(\n        numItems: number,\n    ): React.ReactElement<React.ComponentProps<typeof DropdownOpener>> {\n        const {disabled, menuText, opener, testId} = this.props;\n        const {opened} = this.state;\n\n        return (\n            <DropdownOpener\n                onClick={this.handleClick}\n                disabled={numItems === 0 || disabled}\n                text={menuText}\n                ref={this.handleOpenerRef}\n                testId={opener ? undefined : testId}\n            >\n                {opener\n                    ? opener\n                    : (openerProps) => {\n                          const {\n                              // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                              text,\n                              ...eventState\n                          } = openerProps;\n                          return (\n                              <ActionMenuOpenerCore\n                                  {...eventState}\n                                  disabled={disabled}\n                                  opened={!!opened}\n                                  testId={testId}\n                              >\n                                  {menuText}\n                              </ActionMenuOpenerCore>\n                          );\n                      }}\n            </DropdownOpener>\n        );\n    }\n\n    render(): React.ReactNode {\n        const {alignment, dropdownStyle, style, className} = this.props;\n\n        const items = this.getMenuItems();\n        const dropdownOpener = this.renderOpener(items.length);\n\n        return (\n            <DropdownCore\n                role=\"menu\"\n                style={style}\n                className={className}\n                opener={dropdownOpener}\n                alignment={alignment}\n                open={this.state.opened}\n                items={items}\n                openerElement={this.openerElement}\n                onOpenChanged={this.handleOpenChanged}\n                dropdownStyle={[styles.menuTopSpace, dropdownStyle]}\n            />\n        );\n    }\n}\n\nconst styles = StyleSheet.create({\n    caret: {\n        marginLeft: 4,\n    },\n    // The design calls for additional offset around the opener.\n    opener: {\n        whiteSpace: \"nowrap\",\n        userSelect: \"none\",\n        overflow: \"hidden\",\n        textOverflow: \"ellipsis\",\n    },\n    // This is to adjust the space between the menu and the opener.\n    menuTopSpace: {\n        top: -4,\n    },\n});\n","import * as React from \"react\";\nimport {StyleSheet} from \"aphrodite\";\nimport {__RouterContext} from \"react-router\";\n\nimport type {AriaProps} from \"@khanacademy/wonder-blocks-core\";\n\nimport Color, {mix, fade} from \"@khanacademy/wonder-blocks-color\";\nimport {addStyle} from \"@khanacademy/wonder-blocks-core\";\nimport {getClickableBehavior} from \"@khanacademy/wonder-blocks-clickable\";\nimport Icon, {icons} from \"@khanacademy/wonder-blocks-icon\";\nimport Spacing from \"@khanacademy/wonder-blocks-spacing\";\nimport {LabelMedium} from \"@khanacademy/wonder-blocks-typography\";\nimport {DROPDOWN_ITEM_HEIGHT} from \"../util/constants\";\n\nconst StyledButton = addStyle(\"button\");\n\nconst {blue, white, white50, offBlack, offBlack16, offBlack32, offBlack64} =\n    Color;\n\ntype SelectOpenerProps = AriaProps & {\n    /**\n     * Display text in the SelectOpener.\n     */\n    children: string;\n    /**\n     * Whether the SelectOpener is disabled. If disabled, disallows interaction.\n     * Default false.\n     */\n    disabled: boolean;\n    /**\n     * Auto-populated by parent. Used for accessibility purposes, where the label\n     * id should match the field id.\n     */\n    id?: string;\n    //TODO: error state\n    // error: boolean,\n\n    /**\n     * Whether the displayed text is a placeholder, determined by the creator\n     * of this component. A placeholder has more faded text colors and styles.\n     */\n    isPlaceholder: boolean;\n    /**\n     * Whether to display the \"light\" version of this component instead, for\n     * use when the item is used on a dark background.\n     */\n    light: boolean;\n    /**\n     * Test ID used for e2e testing.\n     */\n    testId?: string;\n    /**\n     * Callback for when the SelectOpener is pressed.\n     */\n    onOpenChanged: (open: boolean) => unknown;\n    /**\n     * Whether the dropdown is open.\n     */\n    open: boolean;\n};\n\ntype DefaultProps = {\n    disabled: SelectOpenerProps[\"disabled\"];\n    light: SelectOpenerProps[\"light\"];\n    isPlaceholder: SelectOpenerProps[\"isPlaceholder\"];\n};\n\n/**\n * An opener that opens select boxes.\n */\nexport default class SelectOpener extends React.Component<SelectOpenerProps> {\n    static defaultProps: DefaultProps = {\n        disabled: false,\n        light: false,\n        isPlaceholder: false,\n    };\n\n    handleClick: (e: React.SyntheticEvent) => void = (e) => {\n        const {open} = this.props;\n        this.props.onOpenChanged(!open);\n    };\n\n    renderClickableBehavior(router: any): React.ReactNode {\n        const {\n            children,\n            disabled,\n            id,\n            isPlaceholder,\n            light,\n            open,\n            testId,\n            // eslint-disable-next-line @typescript-eslint/no-unused-vars\n            onOpenChanged,\n            ...sharedProps\n        } = this.props;\n\n        const ClickableBehavior = getClickableBehavior(router);\n\n        return (\n            <ClickableBehavior disabled={disabled} onClick={this.handleClick}>\n                {(state, childrenProps) => {\n                    const stateStyles = _generateStyles(light, isPlaceholder);\n                    const {hovered, focused, pressed} = state;\n\n                    // The icon colors are kind of fickle. This is just logic\n                    // based on the zeplin design.\n                    const iconColor = light\n                        ? disabled || pressed\n                            ? \"currentColor\"\n                            : white\n                        : disabled\n                        ? offBlack32\n                        : offBlack64;\n\n                    const style = [\n                        styles.shared,\n                        stateStyles.default,\n                        disabled && stateStyles.disabled,\n                        !disabled &&\n                            (pressed\n                                ? stateStyles.active\n                                : (hovered || focused) && stateStyles.focus),\n                    ];\n\n                    return (\n                        <StyledButton\n                            {...sharedProps}\n                            aria-expanded={open ? \"true\" : \"false\"}\n                            aria-haspopup=\"listbox\"\n                            data-test-id={testId}\n                            disabled={disabled}\n                            id={id}\n                            style={style}\n                            type=\"button\"\n                            {...childrenProps}\n                        >\n                            <LabelMedium style={styles.text}>\n                                {/* Note(tamarab): Prevents unwanted vertical\n                                shift for empty selection */}\n                                {children || \"\\u00A0\"}\n                            </LabelMedium>\n                            <Icon\n                                icon={icons.caretDown}\n                                color={iconColor}\n                                size=\"small\"\n                                style={styles.caret}\n                                aria-hidden=\"true\"\n                            />\n                        </StyledButton>\n                    );\n                }}\n            </ClickableBehavior>\n        );\n    }\n\n    render(): React.ReactNode {\n        return (\n            <__RouterContext.Consumer>\n                {(router) => this.renderClickableBehavior(router)}\n            </__RouterContext.Consumer>\n        );\n    }\n}\n\nconst buttonRadius = 4;\n\nconst styles = StyleSheet.create({\n    // TODO: Dedupe with Button styles\n    shared: {\n        position: \"relative\",\n        display: \"inline-flex\",\n        alignItems: \"center\",\n        justifyContent: \"space-between\",\n        color: offBlack,\n        height: DROPDOWN_ITEM_HEIGHT,\n        // This asymmetry arises from the Icon on the right side, which has\n        // extra padding built in. To have the component look more balanced,\n        // we need to take off some paddingRight here.\n        paddingLeft: 16,\n        paddingRight: 12,\n        borderWidth: 0,\n        borderRadius: buttonRadius,\n        borderStyle: \"solid\",\n        outline: \"none\",\n        textDecoration: \"none\",\n        boxSizing: \"border-box\",\n        whiteSpace: \"nowrap\",\n        // This removes the 300ms click delay on mobile browsers by indicating that\n        // \"double-tap to zoom\" shouldn't be used on this element.\n        touchAction: \"manipulation\",\n    },\n\n    text: {\n        marginRight: Spacing.xSmall_8,\n        whiteSpace: \"nowrap\",\n        userSelect: \"none\",\n        overflow: \"hidden\",\n        textOverflow: \"ellipsis\",\n    },\n\n    caret: {\n        minWidth: 16,\n    },\n});\n\n// These values are default padding (16 and 12) minus 1, because\n// changing the borderWidth to 2 messes up the button width\n// and causes it to move a couple pixels. This fixes that.\nconst adjustedPaddingLeft = 16 - 1;\nconst adjustedPaddingRight = 12 - 1;\n\nconst stateStyles: Record<string, any> = {};\n\nconst _generateStyles = (light: boolean, placeholder: boolean) => {\n    // \"hash\" the parameters\n    const styleKey = `${String(light)}-${String(placeholder)}`;\n    if (stateStyles[styleKey]) {\n        return stateStyles[styleKey];\n    }\n\n    let newStyles: Record<string, any> = {};\n    if (light) {\n        newStyles = {\n            default: {\n                background: \"transparent\",\n                color: placeholder ? white50 : white,\n                borderColor: white50,\n                borderWidth: 1,\n            },\n            focus: {\n                borderColor: white,\n                borderWidth: 2,\n                paddingLeft: adjustedPaddingLeft,\n                paddingRight: adjustedPaddingRight,\n            },\n            active: {\n                paddingLeft: adjustedPaddingLeft,\n                paddingRight: adjustedPaddingRight,\n                borderColor: mix(fade(blue, 0.32), white),\n                borderWidth: 2,\n                color: placeholder\n                    ? mix(fade(white, 0.32), blue)\n                    : mix(fade(blue, 0.32), white),\n                backgroundColor: mix(offBlack32, blue),\n            },\n            disabled: {\n                borderColor: mix(fade(white, 0.32), blue),\n                color: mix(fade(white, 0.32), blue),\n                cursor: \"auto\",\n            },\n        };\n    } else {\n        newStyles = {\n            default: {\n                background: white,\n                borderColor: offBlack16,\n                borderWidth: 1,\n                color: placeholder ? offBlack64 : offBlack,\n            },\n            focus: {\n                borderColor: blue,\n                borderWidth: 2,\n                paddingLeft: adjustedPaddingLeft,\n                paddingRight: adjustedPaddingRight,\n            },\n            active: {\n                background: mix(fade(blue, 0.32), white),\n                borderColor: mix(offBlack32, blue),\n                borderWidth: 2,\n                paddingLeft: adjustedPaddingLeft,\n                paddingRight: adjustedPaddingRight,\n            },\n            disabled: {\n                background: Color.offWhite,\n                borderColor: offBlack16,\n                color: offBlack64,\n                cursor: \"auto\",\n            },\n        };\n    }\n\n    stateStyles[styleKey] = StyleSheet.create(newStyles);\n    return stateStyles[styleKey];\n};\n","import * as React from \"react\";\nimport * as ReactDOM from \"react-dom\";\n\nimport type {AriaProps, StyleType} from \"@khanacademy/wonder-blocks-core\";\n\nimport DropdownCore from \"./dropdown-core\";\nimport DropdownOpener from \"./dropdown-opener\";\nimport SelectOpener from \"./select-opener\";\nimport {\n    defaultLabels,\n    selectDropdownStyle,\n    filterableDropdownStyle,\n} from \"../util/constants\";\n\nimport OptionItem from \"./option-item\";\nimport type {DropdownItem, OpenerProps} from \"../util/types\";\n\nexport type SingleSelectLabels = {\n    /**\n     * Label for describing the dismiss icon on the search filter.\n     */\n    clearSearch: string;\n    /**\n     * Label for the search placeholder.\n     */\n    filter: string;\n    /**\n     * Label for when the filter returns no results.\n     */\n    noResults: string;\n    /**\n     * Label for the opening component when there are some items selected.\n     */\n    someResults: (numOptions: number) => string;\n};\n\ntype DefaultProps = Readonly<{\n    /**\n     * Whether this dropdown should be left-aligned or right-aligned with the\n     * opener component. Defaults to left-aligned.\n     */\n    alignment: \"left\" | \"right\";\n    /**\n     * Whether to auto focus an option. Defaults to true.\n     */\n    autoFocus: boolean;\n    /**\n     * Whether to enable the type-ahead suggestions feature. Defaults to true.\n     *\n     * This feature allows to navigate the listbox using the keyboard.\n     * - Type a character: focus moves to the next item with a name that starts\n     *   with the typed character.\n     * - Type multiple characters in rapid succession: focus moves to the next\n     *   item with a name that starts with the string of characters typed.\n     *\n     * **NOTE:** Type-ahead is recommended for all listboxes, but there might be\n     * some cases where it's not desirable (for example when using a `TextField`\n     * as the opener element).\n     */\n    enableTypeAhead: boolean;\n    /**\n     * Whether this component is disabled. A disabled dropdown may not be opened\n     * and does not support interaction. Defaults to false.\n     */\n    disabled: boolean;\n    /**\n     * Whether to display the \"light\" version of this component instead, for\n     * use when the component is used on a dark background.\n     */\n    light: boolean;\n    /**\n     * The object containing the custom labels used inside this component.\n     */\n    labels: SingleSelectLabels;\n}>;\n\ntype Props = AriaProps &\n    DefaultProps &\n    Readonly<{\n        /**\n         * The items in this select.\n         */\n        children?: Array<\n            | React.ReactElement<React.ComponentProps<typeof OptionItem>>\n            | false\n            | null\n            | undefined\n        >;\n        /**\n         * Callback for when the selection. Parameter is the value of the newly\n         * selected item.\n         */\n        onChange: (selectedValue: string) => unknown;\n        /**\n         * Can be used to override the state of the ActionMenu by parent elements\n         */\n        opened?: boolean;\n        /**\n         * In controlled mode, use this prop in case the parent needs to be notified\n         * when the menu opens/closes.\n         */\n        onToggle?: (opened: boolean) => unknown;\n        /**\n         * Unique identifier attached to the field control. If used, we need to\n         * guarantee that the ID is unique within everything rendered on a page.\n         * Used to match `<label>` with `<button>` elements for screenreaders.\n         */\n        id?: string;\n        /**\n         * Placeholder for the opening component when there are no items selected.\n         */\n        placeholder: string;\n        /**\n         * Value of the currently selected item.\n         */\n        selectedValue?: string | null | undefined;\n        /**\n         * Optional styling to add to the opener component wrapper.\n         */\n        style?: StyleType;\n        /**\n         * Adds CSS classes to the opener component wrapper.\n         */\n        className?: string;\n        /**\n         * Test ID used for e2e testing.\n         */\n        testId?: string;\n        /**\n         * Optional styling to add to the dropdown wrapper.\n         */\n        dropdownStyle?: StyleType;\n        /**\n         * The child function that returns the anchor the ActionMenu will be\n         * activated by. This function takes eventState, which allows the opener\n         * element to access pointer event state.\n         */\n        opener?: (openerProps: OpenerProps) => React.ReactElement<any>;\n        /**\n         * When this is true, the dropdown body shows a search text input at the\n         * top. The items will be filtered by the input.\n         */\n        isFilterable?: boolean;\n    }>;\n\ntype State = Readonly<{\n    /**\n     * Whether or not the dropdown is open.\n     */\n    open: boolean;\n    /**\n     * The text input to filter the items by their label. Defaults to an empty\n     * string.\n     */\n    searchText: string;\n    /**\n     * The DOM reference to the opener element. This is mainly used to set focus\n     * to this element, and also to pass the reference to Popper.js.\n     */\n    openerElement?: HTMLElement;\n}>;\n\n/**\n * The single select allows the selection of one item. Clients are responsible\n * for keeping track of the selected item in the select.\n *\n * The single select dropdown closes after the selection of an item. If the same\n * item is selected, there is no callback.\n *\n * **NOTE:** If there are more than 125 items, the component automatically uses\n * [react-window](https://github.com/bvaughn/react-window) to improve\n * performance when rendering these elements and is capable of handling many\n * hundreds of items without performance problems.\n *\n * ## Usage\n * General usage\n *\n * ```jsx\n * import {OptionItem, SingleSelect} from \"@khanacademy/wonder-blocks-dropdown\";\n *\n * const [selectedValue, setSelectedValue] = React.useState(\"\");\n *\n * <SingleSelect placeholder=\"Choose a fruit\" onChange={setSelectedValue} selectedValue={selectedValue}>\n *     <OptionItem label=\"Pear\" value=\"pear\" />\n *     <OptionItem label=\"Mango\" value=\"mango\" />\n * </SingleSelect>\n * ```\n *\n * Mapping a list\n *\n * ```jsx\n * import {OptionItem, SingleSelect} from \"@khanacademy/wonder-blocks-dropdown\";\n *\n * const [selectedValue, setSelectedValue] = React.useState(\"\");\n * const fruitArray = [\"Apple\", \"Banana\", \"Orange\", \"Mango\", \"Pear\"];\n *\n * <SingleSelect\n *     placeholder=\"Choose a fruit\"\n *     onChange={setSelectedValue}\n *     selectedValue={selectedValue}\n * >\n *     {fruitArray.map((value, index) => (\n *         <OptionItem key={index} value={value} label={value} />\n *     ))}\n * </SingleSelect>\n * ```\n */\nexport default class SingleSelect extends React.Component<Props, State> {\n    selectedIndex: number;\n\n    static defaultProps: DefaultProps = {\n        alignment: \"left\",\n        autoFocus: true,\n        disabled: false,\n        enableTypeAhead: true,\n        light: false,\n        labels: {\n            clearSearch: defaultLabels.clearSearch,\n            filter: defaultLabels.filter,\n            noResults: defaultLabels.noResults,\n            someResults: defaultLabels.someSelected,\n        },\n    };\n\n    constructor(props: Props) {\n        super(props);\n\n        this.selectedIndex = 0;\n\n        this.state = {\n            open: false,\n            searchText: \"\",\n        };\n    }\n\n    /**\n     * Used to sync the `opened` state when this component acts as a controlled\n     * component\n     */\n    static getDerivedStateFromProps(\n        props: Props,\n        state: State,\n    ): Partial<State> | null {\n        return {\n            open: typeof props.opened === \"boolean\" ? props.opened : state.open,\n        };\n    }\n\n    handleOpenChanged: (opened: boolean) => void = (opened) => {\n        this.setState({\n            open: opened,\n            searchText: \"\",\n        });\n\n        if (this.props.onToggle) {\n            this.props.onToggle(opened);\n        }\n    };\n\n    handleToggle: (selectedValue: string) => void = (selectedValue) => {\n        // Call callback if selection changed.\n        if (selectedValue !== this.props.selectedValue) {\n            this.props.onChange(selectedValue);\n        }\n\n        // Bring focus back to the opener element.\n        if (this.state.open && this.state.openerElement) {\n            this.state.openerElement.focus();\n        }\n\n        this.setState({\n            open: false, // close the menu upon selection\n        });\n\n        if (this.props.onToggle) {\n            this.props.onToggle(false);\n        }\n    };\n\n    mapOptionItemsToDropdownItems: (\n        children: Array<\n            React.ReactElement<React.ComponentProps<typeof OptionItem>>\n        >,\n    ) => Array<DropdownItem> = (children) => {\n        // Figure out which index should receive focus when this select opens\n        // Needs to exclude counting items that are disabled\n        let indexCounter = 0;\n        this.selectedIndex = 0;\n\n        return children.map((option) => {\n            const {selectedValue} = this.props;\n            const {disabled, value} = option.props;\n            const selected = selectedValue === value;\n\n            if (selected) {\n                this.selectedIndex = indexCounter;\n            }\n\n            if (!disabled) {\n                indexCounter += 1;\n            }\n\n            return {\n                component: option,\n                focusable: !disabled,\n                populatedProps: {\n                    onToggle: this.handleToggle,\n                    selected: selected,\n                    variant: \"check\",\n                },\n            };\n        });\n    };\n\n    filterChildren(\n        children: Array<\n            React.ReactElement<React.ComponentProps<typeof OptionItem>>\n        >,\n    ): Array<React.ReactElement<React.ComponentProps<typeof OptionItem>>> {\n        const {searchText} = this.state;\n\n        const lowercasedSearchText = searchText.toLowerCase();\n\n        // Filter the children with the searchText if any.\n        return children.filter(\n            ({props}) =>\n                !searchText ||\n                props.label.toLowerCase().indexOf(lowercasedSearchText) > -1,\n        );\n    }\n\n    getMenuItems(\n        children: Array<\n            React.ReactElement<React.ComponentProps<typeof OptionItem>>\n        >,\n    ): Array<DropdownItem> {\n        const {isFilterable} = this.props;\n\n        // If it's not filterable, no need to do any extra besides mapping the\n        // option items to dropdown items.\n        return this.mapOptionItemsToDropdownItems(\n            isFilterable ? this.filterChildren(children) : children,\n        );\n    }\n\n    handleSearchTextChanged: (searchText: string) => void = (searchText) => {\n        this.setState({searchText});\n    };\n\n    handleOpenerRef: (node?: any) => void = (node) => {\n        const openerElement = ReactDOM.findDOMNode(node) as HTMLElement;\n        this.setState({openerElement});\n    };\n\n    handleClick: (e: React.SyntheticEvent) => void = (e) => {\n        this.handleOpenChanged(!this.state.open);\n    };\n\n    renderOpener(\n        numItems: number,\n    ):\n        | React.ReactElement<React.ComponentProps<typeof DropdownOpener>>\n        | React.ReactElement<React.ComponentProps<typeof SelectOpener>> {\n        const {\n            children,\n            disabled,\n            id,\n            light,\n            opener,\n            placeholder,\n            selectedValue,\n            testId,\n            // the following props are being included here to avoid\n            // passing them down to the opener as part of sharedProps\n            /* eslint-disable @typescript-eslint/no-unused-vars */\n            alignment,\n            autoFocus,\n            dropdownStyle,\n            enableTypeAhead,\n            isFilterable,\n            labels,\n            onChange,\n            onToggle,\n            opened,\n            style,\n            className,\n            /* eslint-enable @typescript-eslint/no-unused-vars */\n            ...sharedProps\n        } = this.props;\n\n        const selectedItem = React.Children.toArray(children).find(\n            // @ts-expect-error [FEI-5019] - TS2339 - Property 'props' does not exist on type 'ReactChild | ReactFragment | ReactPortal'.\n            (option) => option.props.value === selectedValue,\n        );\n        // If nothing is selected, or if the selectedValue doesn't match any\n        // item in the menu, use the placeholder.\n        // @ts-expect-error [FEI-5019] - TS2339 - Property 'props' does not exist on type 'ReactChild | ReactFragment | ReactPortal'.\n        const menuText = selectedItem ? selectedItem.props.label : placeholder;\n\n        const dropdownOpener = opener ? (\n            <DropdownOpener\n                onClick={this.handleClick}\n                disabled={numItems === 0 || disabled}\n                ref={this.handleOpenerRef}\n                text={menuText}\n            >\n                {opener}\n            </DropdownOpener>\n        ) : (\n            <SelectOpener\n                {...sharedProps}\n                disabled={numItems === 0 || disabled}\n                id={id}\n                isPlaceholder={!selectedItem}\n                light={light}\n                onOpenChanged={this.handleOpenChanged}\n                open={this.state.open}\n                ref={this.handleOpenerRef}\n                testId={testId}\n            >\n                {menuText}\n            </SelectOpener>\n        );\n        return dropdownOpener;\n    }\n\n    render(): React.ReactNode {\n        const {\n            alignment,\n            autoFocus,\n            children,\n            className,\n            dropdownStyle,\n            enableTypeAhead,\n            isFilterable,\n            labels,\n            light,\n            style,\n        } = this.props;\n        const {searchText} = this.state;\n        const allChildren = React.Children.toArray(children).filter(Boolean);\n        // @ts-expect-error [FEI-5019] - TS2345 - Argument of type '(ReactChild | ReactFragment | ReactPortal)[]' is not assignable to parameter of type 'ReactElement<{}, string | JSXElementConstructor<any>>[]'.\n        const items = this.getMenuItems(allChildren);\n        const opener = this.renderOpener(allChildren.length);\n\n        return (\n            <DropdownCore\n                role=\"listbox\"\n                selectionType=\"single\"\n                alignment={alignment}\n                autoFocus={autoFocus}\n                enableTypeAhead={enableTypeAhead}\n                dropdownStyle={[\n                    isFilterable && filterableDropdownStyle,\n                    selectDropdownStyle,\n                    dropdownStyle,\n                ]}\n                initialFocusedIndex={this.selectedIndex}\n                items={items}\n                light={light}\n                onOpenChanged={this.handleOpenChanged}\n                open={this.state.open}\n                opener={opener}\n                openerElement={this.state.openerElement}\n                style={style}\n                className={className}\n                isFilterable={isFilterable}\n                onSearchTextChanged={\n                    isFilterable ? this.handleSearchTextChanged : undefined\n                }\n                searchText={isFilterable ? searchText : \"\"}\n                labels={labels}\n            />\n        );\n    }\n}\n","import * as React from \"react\";\nimport * as ReactDOM from \"react-dom\";\n\nimport type {AriaProps, StyleType} from \"@khanacademy/wonder-blocks-core\";\n\nimport ActionItem from \"./action-item\";\nimport DropdownCore from \"./dropdown-core\";\nimport DropdownOpener from \"./dropdown-opener\";\nimport SelectOpener from \"./select-opener\";\nimport SeparatorItem from \"./separator-item\";\nimport {\n    defaultLabels,\n    selectDropdownStyle,\n    filterableDropdownStyle,\n} from \"../util/constants\";\n\nimport OptionItem from \"./option-item\";\nimport type {DropdownItem, OpenerProps} from \"../util/types\";\n\nexport type Labels = {\n    /**\n     * Label for describing the dismiss icon on the search filter.\n     */\n    clearSearch: string;\n    /**\n     * Label for the search placeholder.\n     */\n    filter: string;\n    /**\n     * Label for when the filter returns no results.\n     */\n    noResults: string;\n    /**\n     * Label for the \"select all\" shortcut option.\n     */\n    selectAllLabel: (numOptions: number) => string;\n    /**\n     * Label for the \"select none\" shortcut option\n     */\n\n    selectNoneLabel: string;\n    /**\n     * Label for the opening component when there are no items selected.\n     */\n    noneSelected: string;\n    /**\n     * Label for the opening component when there are some items selected.\n     */\n    someSelected: (numOptions: number) => string;\n    /**\n     * Label for the opening component when all the items have been selected.\n     */\n    allSelected: string;\n};\n\ntype DefaultProps = Readonly<{\n    /**\n     * Whether this dropdown should be left-aligned or right-aligned with the\n     * opener component. Defaults to left-aligned.\n     */\n    alignment: \"left\" | \"right\";\n    /**\n     * Whether this component is disabled. A disabled dropdown may not be opened\n     * and does not support interaction. Defaults to false.\n     */\n    disabled: boolean;\n    /**\n     * Whether to display the \"light\" version of this component instead, for\n     * use when the component is used on a dark background.\n     */\n    light: boolean;\n    /**\n     * The values of the items that are currently selected.\n     */\n    selectedValues: Array<string>;\n    /**\n     * Whether to display shortcuts for Select All and Select None.\n     */\n    shortcuts: boolean;\n}>;\n\ntype Props = AriaProps &\n    DefaultProps &\n    Readonly<{\n        /**\n         * The items in this select.\n         */\n        children?: Array<\n            | React.ReactElement<React.ComponentProps<typeof OptionItem>>\n            | false\n            | null\n            | undefined\n        >;\n        /**\n         * Optional styling to add to the dropdown wrapper.\n         */\n        dropdownStyle?: StyleType;\n        /**\n         * Unique identifier attached to the field control. If used, we need to\n         * guarantee that the ID is unique within everything rendered on a page.\n         * Used to match `<label>` with `<button>` elements for screenreaders.\n         */\n        id?: string;\n        /**\n         * When this is true, the menu text shows either \"All items\" or the value\n         * set in `props.labels.allSelected` when no item is selected.\n         */\n        implicitAllEnabled?: boolean;\n        /**\n         * When this is true, the dropdown body shows a search text input at the\n         * top. The items will be filtered by the input.\n         * Selected items will be moved to the top when the dropdown is re-opened.\n         */\n        isFilterable?: boolean;\n        /**\n         * The object containing the custom labels used inside this component.\n         */\n        labels?: Labels;\n        /**\n         * Callback for when the selection changes. Parameter is an updated array of\n         * the values that are now selected.\n         */\n        onChange: (selectedValues: Array<string>) => unknown;\n        /**\n         * In controlled mode, use this prop in case the parent needs to be notified\n         * when the menu opens/closes.\n         */\n        onToggle?: (opened: boolean) => unknown;\n        /**\n         * Can be used to override the state of the ActionMenu by parent elements\n         */\n        opened?: boolean;\n        /**\n         * The child function that returns the anchor the MultiSelect will be\n         * activated by. This function takes eventState, which allows the opener\n         * element to access pointer event state.\n         */\n        opener?: (openerProps: OpenerProps) => React.ReactElement<any>;\n        /**\n         * Optional styling to add to the opener component wrapper.\n         */\n        style?: StyleType;\n        /**\n         * Adds CSS classes to the opener component wrapper.\n         */\n        className?: string;\n        /**\n         * Test ID used for e2e testing.\n         */\n        testId?: string;\n    }>;\n\ntype State = Readonly<{\n    /**\n     * Whether or not the dropdown is open.\n     */\n    open: boolean;\n    /**\n     * The text input to filter the items by their label. Defaults to an empty\n     * string.\n     */\n    searchText: string;\n    /**\n     * The selected values that are set when the dropdown is opened. We use\n     * this to move the selected items to the top when the dropdown is\n     * re-opened.\n     */\n    lastSelectedValues: Array<string>;\n    /**\n     * The object containing the custom labels used inside this component.\n     */\n    labels: Labels;\n    /**\n     * The DOM reference to the opener element. This is mainly used to set focus\n     * to this element, and also to pass the reference to Popper.js.\n     */\n    openerElement?: HTMLElement;\n}>;\n\n/**\n * A dropdown that consists of multiple selection items. This select allows\n * multiple options to be selected. Clients are responsible for keeping track\n * of the selected items.\n *\n * The multi select stays open until closed by the user. The onChange callback\n * happens every time there is a change in the selection of the items.\n *\n * ## Usage\n *\n * ```jsx\n * import {OptionItem, MultiSelect} from \"@khanacademy/wonder-blocks-dropdown\";\n *\n * <MultiSelect onChange={setSelectedValues} selectedValues={selectedValues}>\n *  <OptionItem value=\"pear\">Pear</OptionItem>\n *  <OptionItem value=\"mango\">Mango</OptionItem>\n * </MultiSelect>\n * ```\n */\nexport default class MultiSelect extends React.Component<Props, State> {\n    labels: Labels;\n\n    static defaultProps: DefaultProps = {\n        alignment: \"left\",\n        disabled: false,\n        light: false,\n        shortcuts: false,\n        selectedValues: [],\n    };\n\n    constructor(props: Props) {\n        super(props);\n\n        this.state = {\n            open: false,\n            searchText: \"\",\n            lastSelectedValues: [],\n            // merge custom labels with the default ones\n            labels: {...defaultLabels, ...props.labels},\n        };\n        // merge custom labels with the default ones\n        this.labels = {...defaultLabels, ...props.labels};\n    }\n\n    /**\n     * Used to sync the `opened` state when this component acts as a controlled\n     * component\n     */\n    static getDerivedStateFromProps(\n        props: Props,\n        state: State,\n    ): Partial<State> | null {\n        return {\n            open: typeof props.opened === \"boolean\" ? props.opened : state.open,\n        };\n    }\n\n    componentDidUpdate(prevProps: Props) {\n        if (this.props.labels !== prevProps.labels) {\n            // eslint-disable-next-line react/no-did-update-set-state\n            this.setState({\n                labels: {...this.state.labels, ...this.props.labels},\n            });\n        }\n    }\n\n    handleOpenChanged: (opened: boolean) => void = (opened) => {\n        this.setState({\n            open: opened,\n            searchText: \"\",\n            lastSelectedValues: this.props.selectedValues,\n        });\n\n        if (this.props.onToggle) {\n            this.props.onToggle(opened);\n        }\n    };\n\n    handleToggle: (selectedValue: string) => void = (selectedValue) => {\n        const {onChange, selectedValues} = this.props;\n\n        if (selectedValues.includes(selectedValue)) {\n            const index = selectedValues.indexOf(selectedValue);\n            const updatedSelection = [\n                ...selectedValues.slice(0, index),\n                ...selectedValues.slice(index + 1),\n            ];\n            onChange(updatedSelection);\n        } else {\n            // Item was newly selected\n            onChange([...selectedValues, selectedValue]);\n        }\n    };\n\n    handleSelectAll: () => void = () => {\n        const {children, onChange} = this.props;\n        const selected = React.Children.toArray(children)\n            .filter(Boolean)\n            // @ts-expect-error [FEI-5019] - TS2339 - Property 'props' does not exist on type 'ReactChild | ReactFragment | ReactPortal'.\n            .map((option) => option.props.value);\n        onChange(selected);\n    };\n\n    handleSelectNone: () => void = () => {\n        const {onChange} = this.props;\n        onChange([]);\n    };\n\n    getMenuText(\n        children: Array<\n            React.ReactElement<React.ComponentProps<typeof OptionItem>>\n        >,\n    ): string {\n        const {implicitAllEnabled, selectedValues} = this.props;\n        const {noneSelected, someSelected, allSelected} = this.state.labels;\n\n        // When implicit all enabled, use `labels.allSelected` when no selection\n        // otherwise, use the `labels.noneSelected` value\n        const noSelectionText = implicitAllEnabled ? allSelected : noneSelected;\n\n        switch (selectedValues.length) {\n            case 0:\n                return noSelectionText;\n            case 1:\n                // If there is one item selected, we display its label. If for\n                // some reason we can't find the selected item, we use the\n                // display text for the case where nothing is selected.\n                const selectedItem = children.find(\n                    (option) => option.props.value === selectedValues[0],\n                );\n                return selectedItem\n                    ? selectedItem.props.label\n                    : noSelectionText;\n            case children.length:\n                return allSelected;\n            default:\n                return someSelected(selectedValues.length);\n        }\n    }\n\n    getShortcuts(numOptions: number): Array<DropdownItem> {\n        const {selectedValues, shortcuts} = this.props;\n        const {selectAllLabel, selectNoneLabel} = this.state.labels;\n\n        // When there's search text input to filter, shortcuts should be hidden\n        if (shortcuts && !this.state.searchText) {\n            const selectAllDisabled = numOptions === selectedValues.length;\n            const selectAll = {\n                component: (\n                    <ActionItem\n                        disabled={selectAllDisabled}\n                        label={selectAllLabel(numOptions)}\n                        indent={true}\n                        onClick={this.handleSelectAll}\n                    />\n                ),\n                focusable: !selectAllDisabled,\n                populatedProps: {},\n            } as const;\n\n            const selectNoneDisabled = selectedValues.length === 0;\n            const selectNone = {\n                component: (\n                    <ActionItem\n                        disabled={selectNoneDisabled}\n                        label={selectNoneLabel}\n                        indent={true}\n                        onClick={this.handleSelectNone}\n                    />\n                ),\n                focusable: !selectNoneDisabled,\n                populatedProps: {},\n            } as const;\n\n            const separator = {\n                component: <SeparatorItem key=\"shortcuts-separator\" />,\n                focusable: false,\n                populatedProps: {},\n            } as const;\n\n            return [selectAll, selectNone, separator];\n        } else {\n            return [];\n        }\n    }\n\n    getMenuItems(\n        children: Array<\n            React.ReactElement<React.ComponentProps<typeof OptionItem>>\n        >,\n    ): Array<DropdownItem> {\n        const {isFilterable} = this.props;\n        // If it's not filterable, no need to do any extra besides mapping the\n        // option items to dropdown items.\n        if (!isFilterable) {\n            return children.map(this.mapOptionItemToDropdownItem);\n        }\n\n        const {searchText, lastSelectedValues} = this.state;\n\n        const lowercasedSearchText = searchText.toLowerCase();\n\n        // Filter the children with the searchText if any.\n        const filteredChildren = children.filter(\n            ({props}) =>\n                !searchText ||\n                props.label.toLowerCase().indexOf(lowercasedSearchText) > -1,\n        );\n\n        // @ts-expect-error [FEI-5019] - TS2315 - Type 'Element' is not generic.\n        const lastSelectedChildren: Array<Element<typeof OptionItem>> = [];\n        // @ts-expect-error [FEI-5019] - TS2315 - Type 'Element' is not generic.\n        const restOfTheChildren: Array<Element<typeof OptionItem>> = [];\n        for (const child of filteredChildren) {\n            if (lastSelectedValues.includes(child.props.value)) {\n                lastSelectedChildren.push(child);\n            } else {\n                restOfTheChildren.push(child);\n            }\n        }\n\n        const lastSelectedItems = lastSelectedChildren.map(\n            this.mapOptionItemToDropdownItem,\n        );\n\n        // We want to add SeparatorItem in between last selected items and the\n        // rest of the items only when both of them exists.\n        if (lastSelectedChildren.length && restOfTheChildren.length) {\n            lastSelectedItems.push({\n                component: <SeparatorItem key=\"selected-separator\" />,\n                focusable: false,\n                populatedProps: {},\n            });\n        }\n\n        return [\n            ...lastSelectedItems,\n            ...restOfTheChildren.map(this.mapOptionItemToDropdownItem),\n        ];\n    }\n\n    mapOptionItemToDropdownItem: (\n        option: React.ReactElement<React.ComponentProps<typeof OptionItem>>,\n    ) => DropdownItem = (\n        option: React.ReactElement<React.ComponentProps<typeof OptionItem>>,\n    ): DropdownItem => {\n        const {selectedValues} = this.props;\n        const {disabled, value} = option.props;\n        return {\n            component: option,\n            focusable: !disabled,\n            populatedProps: {\n                onToggle: this.handleToggle,\n                selected: selectedValues.includes(value),\n                variant: \"checkbox\",\n            },\n        };\n    };\n\n    handleOpenerRef: (node?: any) => void = (node: any) => {\n        const openerElement = ReactDOM.findDOMNode(node) as HTMLElement;\n        this.setState({openerElement});\n    };\n\n    handleSearchTextChanged: (searchText: string) => void = (\n        searchText: string,\n    ) => {\n        this.setState({searchText});\n    };\n\n    handleClick: (e: React.SyntheticEvent) => void = (\n        e: React.SyntheticEvent,\n    ) => {\n        this.handleOpenChanged(!this.state.open);\n    };\n\n    renderOpener(\n        allChildren: Array<\n            React.ReactElement<React.ComponentProps<typeof OptionItem>>\n        >,\n    ):\n        | React.ReactElement<React.ComponentProps<typeof DropdownOpener>>\n        | React.ReactElement<React.ComponentProps<typeof SelectOpener>> {\n        const {\n            disabled,\n            id,\n            light,\n            opener,\n            testId,\n            // the following props are being included here to avoid\n            // passing them down to the opener as part of sharedProps\n            /* eslint-disable @typescript-eslint/no-unused-vars */\n            alignment,\n            dropdownStyle,\n            implicitAllEnabled,\n            isFilterable,\n            labels,\n            onChange,\n            onToggle,\n            opened,\n            selectedValues,\n            shortcuts,\n            style,\n            className,\n            /* eslint-enable @typescript-eslint/no-unused-vars */\n            ...sharedProps\n        } = this.props;\n        const {noneSelected} = this.state.labels;\n\n        const menuText = this.getMenuText(allChildren);\n        const numOptions = allChildren.length;\n\n        const dropdownOpener = opener ? (\n            <DropdownOpener\n                onClick={this.handleClick}\n                disabled={numOptions === 0 || disabled}\n                ref={this.handleOpenerRef}\n                text={menuText}\n            >\n                {opener}\n            </DropdownOpener>\n        ) : (\n            <SelectOpener\n                {...sharedProps}\n                disabled={numOptions === 0 || disabled}\n                id={id}\n                isPlaceholder={menuText === noneSelected}\n                light={light}\n                onOpenChanged={this.handleOpenChanged}\n                open={this.state.open}\n                ref={this.handleOpenerRef}\n                testId={testId}\n            >\n                {menuText}\n            </SelectOpener>\n        );\n\n        return dropdownOpener;\n    }\n\n    render(): React.ReactNode {\n        const {\n            alignment,\n            light,\n            style,\n            className,\n            dropdownStyle,\n            children,\n            isFilterable,\n        } = this.props;\n        const {open, searchText} = this.state;\n        const {clearSearch, filter, noResults, someSelected} =\n            this.state.labels;\n\n        const allChildren = React.Children.toArray(children).filter(Boolean);\n        const numOptions = allChildren.length;\n        // @ts-expect-error [FEI-5019] - TS2345 - Argument of type '(ReactChild | ReactFragment | ReactPortal)[]' is not assignable to parameter of type 'ReactElement<{}, string | JSXElementConstructor<any>>[]'.\n        const filteredItems = this.getMenuItems(allChildren);\n        // @ts-expect-error [FEI-5019] - TS2345 - Argument of type '(ReactChild | ReactFragment | ReactPortal)[]' is not assignable to parameter of type 'ReactElement<{}, string | JSXElementConstructor<any>>[]'.\n        const opener = this.renderOpener(allChildren);\n\n        return (\n            <DropdownCore\n                role=\"listbox\"\n                alignment={alignment}\n                dropdownStyle={[\n                    isFilterable && filterableDropdownStyle,\n                    selectDropdownStyle,\n                    dropdownStyle,\n                ]}\n                isFilterable={isFilterable}\n                items={[...this.getShortcuts(numOptions), ...filteredItems]}\n                light={light}\n                onOpenChanged={this.handleOpenChanged}\n                open={open}\n                opener={opener}\n                openerElement={this.state.openerElement}\n                selectionType=\"multi\"\n                style={style}\n                className={className}\n                onSearchTextChanged={\n                    isFilterable ? this.handleSearchTextChanged : undefined\n                }\n                searchText={isFilterable ? searchText : \"\"}\n                labels={{\n                    clearSearch,\n                    filter,\n                    noResults,\n                    someResults: someSelected,\n                }}\n            />\n        );\n    }\n}\n"],"names":["keyCodes","selectDropdownStyle","Spacing","filterableDropdownStyle","DROPDOWN_ITEM_HEIGHT","MAX_VISIBLE_ITEMS","SEPARATOR_ITEM_HEIGHT","defaultLabels","numOptions","numSelectedValues","blue","white","offBlack","offBlack32","Color","StyledAnchor","addStyle","StyledButton","StyledLink","Link","ActionItem","React.Component","instance","router","skipClientNav","disabled","href","target","indent","label","lang","onClick","role","style","testId","ClickableBehavior","getClickableBehavior","jsx","state","childrenProps","pressed","hovered","focused","defaultStyle","styles","props","children","React.Fragment","LabelMedium","isClientSideUrl","__RouterContext","StyleSheet","mix","fade","Check","selected","Icon","icons.check","Check$1","checkboxCheck","offBlack16","offBlack50","offWhite","Checkbox","activeBlue","clickInteraction","bgColor","checkColor","View","Checkbox$1","OptionItem","onToggle","value","variant","sharedProps","CheckComponent","jsxs","SeparatorItem","DropdownOpener","eventState","clickableChildrenProps","text","renderedChildren","childrenTestId","React.cloneElement","e","handlers","DropdownOpener$1","areInputsEqual","newInputs","lastInputs","i","memoizeOne","resultFn","isEqual","lastThis","lastArgs","lastResult","calledOnce","memoized","newArgs","_i","hasNativePerformanceNow","now","cancelTimeout","timeoutID","requestTimeout","callback","delay","start","tick","cachedRTLResult","getRTLOffsetType","recalculate","outerDiv","outerStyle","innerDiv","innerStyle","IS_SCROLLING_DEBOUNCE_INTERVAL$1","defaultItemKey$1","index","data","createListComponent","_ref","_class","getItemOffset","getEstimatedTotalSize","getItemSize","getOffsetForIndexAndAlignment","getStartIndexForOffset","getStopIndexForStartIndex","initInstanceProps","shouldResetStyleCacheOnItemSizeChange","validateProps","_PureComponent","_inheritsLoose","List","_this","_assertThisInitialized","overscanStartIndex","overscanStopIndex","visibleStartIndex","visibleStopIndex","scrollDirection","scrollOffset","scrollUpdateWasRequested","_this$props","direction","itemSize","layout","itemStyleCache","_offset","size","isHorizontal","isRtl","offsetHorizontal","_","__","___","event","_event$currentTarget","clientWidth","scrollLeft","scrollWidth","prevState","_event$currentTarget2","clientHeight","scrollHeight","scrollTop","ref","outerRef","nextProps","validateSharedProps$1","_proto","align","itemCount","_this$props2","initialScrollOffset","_this$props3","_this$state","_this$props4","className","height","innerRef","innerElementType","innerTagName","itemData","_this$props4$itemKey","itemKey","outerElementType","outerTagName","useIsScrolling","width","isScrolling","onScroll","_this$_getRangeToRend","startIndex","stopIndex","items","_index","createElement","estimatedTotalSize","_extends","_this$_getRangeToRend2","_overscanStartIndex","_overscanStopIndex","_visibleStartIndex","_visibleStopIndex","_this$state2","_scrollDirection","_scrollOffset","_scrollUpdateWasRequested","_this$props5","overscanCount","_this$state3","overscanBackward","overscanForward","PureComponent","_ref2","_ref3","DEFAULT_ESTIMATED_ITEM_SIZE$1","getItemMetadata$1","instanceProps","itemMetadataMap","lastMeasuredIndex","offset","itemMetadata","findNearestItem$1","lastMeasuredItemOffset","findNearestItemBinarySearch$1","findNearestItemExponentialSearch$1","high","low","middle","currentOffset","interval","estimatedItemSize","totalSizeOfMeasuredItems","numUnmeasuredItems","totalSizeOfUnmeasuredItems","VariableSizeList","maxOffset","minOffset","_ref4","shouldForceUpdate","_ref5","DropdownVirtualizedItem","item","component","populatedProps","getDropdownMenuHeight","initialHeight","sum","generateDropdownMenuStyles","minWidth","maxHeight","DropdownCoreVirtualized","schedule","prevProps","listRef","rootNode","ReactDOM.findDOMNode","parentNode","allComponents","React.Children","a","b","DropdownCoreVirtualized$1","withActionScheduler","modifiers","DropdownPopper","alignment","onPopperElement","referenceElement","modalHost","maybeGetPortalMountedModalHostElement","ReactDOM.createPortal","Popper","node","placement","hasPopperEscaped","isReferenceHidden","getStringForKey","key","debounce","wait","timeout","args","later","VIRTUALIZE_THRESHOLD","StyledSpan","_DropdownCore","React.createRef","open","onOpenChanged","thisElement","enableTypeAhead","searchText","keyCode","foundIndex","_a","isClosed","focusIndex","onSearchTextChanged","prevItems","currentItems","itemRefs","sameItemsFocusable","newFocusableIndex","initialFocusedIndex","autoFocus","onFocus","focusedItemRef","noResults","focusCounter","itemRole","focusable","currentRef","virtualizedItems","labels","SearchField","listRenderer","dropdownStyle","light","openerElement","openerStyle","minDropdownWidth","maxDropdownHeight","popperElement","totalItems","opener","DropdownCore","DropdownCore$1","ActionMenuOpenerCore","disabledProp","opened","ariaLabel","restProps","buttonColor","SemanticColor","buttonStyles","_generateStyles","sharedStyles","LabelLarge","Strut","icons.caretDown","color","buttonType","activeColor","newStyles","ActionMenu","selectedValue","onChange","selectedValues","updatedSelection","allChildren","isOptionItemIncluded","itemObject","numItems","menuText","openerProps","dropdownOpener","white50","offBlack64","SelectOpener","id","isPlaceholder","stateStyles2","iconColor","buttonRadius","adjustedPaddingLeft","adjustedPaddingRight","stateStyles","placeholder","styleKey","SingleSelect","indexCounter","option","lowercasedSearchText","isFilterable","selectedItem","MultiSelect","implicitAllEnabled","noneSelected","someSelected","allSelected","noSelectionText","shortcuts","selectAllLabel","selectNoneLabel","selectAllDisabled","selectAll","selectNoneDisabled","selectNone","lastSelectedValues","filteredChildren","lastSelectedChildren","restOfTheChildren","child","lastSelectedItems","clearSearch","filter","filteredItems"],"mappings":"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","x_google_ignoreList":[7,8]}