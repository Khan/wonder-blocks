{"version":3,"file":"gql-router-027fc1dc.js","sources":["../../packages/wonder-blocks-core/src/util/server.ts","../../node_modules/@khanacademy/wonder-stuff-core/dist/browser/es/index.js","../../packages/wonder-blocks-data/src/util/data-error.ts","../../packages/wonder-blocks-data/src/util/scoped-in-memory-cache.ts","../../packages/wonder-blocks-data/src/util/serializable-in-memory-cache.ts","../../packages/wonder-blocks-data/src/util/ssr-cache.ts","../../packages/wonder-blocks-data/src/util/request-fulfillment.ts","../../packages/wonder-blocks-data/src/util/request-tracking.ts","../../packages/wonder-blocks-data/src/components/track-data.tsx","../../packages/wonder-blocks-data/src/components/intercept-context.ts","../../packages/wonder-blocks-data/src/components/intercept-requests.tsx","../../packages/wonder-blocks-data/src/util/gql-router-context.ts","../../packages/wonder-blocks-data/src/components/gql-router.tsx"],"sourcesContent":["let serverSide = false;\n\nexport default {\n    /**\n     * Check if we are running in server-side mode.\n     *\n     * @returns {boolean} `true` if we are in server-side mode; otherwise,\n     * `false`\n     */\n    isServerSide: (): boolean => serverSide,\n\n    /**\n     * Set server-side mode to true.\n     */\n    setServerSide: () => {\n        serverSide = true;\n    },\n};\n","var t=e=>null==e||\"object\"!=typeof e?e:Array.isArray(e)?e.map(t):Object.keys(e).reduce(((n,r)=>(n[r]=t(e[r]),n)),{}),e=t=>Object.entries(t),n=Object.freeze({Unknown:\"Unknown\",Internal:\"Internal\",InvalidInput:\"InvalidInput\",InvalidUse:\"InvalidUse\",NotFound:\"NotFound\",NotAllowed:\"NotAllowed\",Unauthorized:\"Unauthorized\",NotImplemented:\"NotImplemented\"});function r(t,e,n){return(e=function(t){var e=function(t,e){if(\"object\"!=typeof t||null===t)return t;var n=t[Symbol.toPrimitive];if(void 0!==n){var r=n.call(t,e||\"default\");if(\"object\"!=typeof r)return r;throw new TypeError(\"@@toPrimitive must return a primitive value.\")}return(\"string\"===e?String:Number)(t)}(t,\"string\");return\"symbol\"==typeof e?e:String(e)}(e))in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}class s{constructor(t,e,n){r(this,\"_name\",void 0),r(this,\"_message\",void 0),r(this,\"_stackFrames\",void 0),this._name=t,this._message=e,this._stackFrames=[...n]}get message(){return this._message}get name(){return this._name}get messageWithName(){return\"\".concat(this.name,\": \").concat(this.message)}get stack(){return[...this._stackFrames]}get standardizedStack(){return\"\".concat(this.messageWithName,\"\\n\").concat(this._stackFrames.join(\"\\n\"))}static fromConsequenceAndCause(t,e){var n;if(\"production\"!==process.env.NODE_ENV){if(!(t instanceof s))throw new Error(\"consequence must be an instance of ErrorInfo\");if(!(e instanceof s))throw new Error(\"cause must be an instance of ErrorInfo\");if(e===t)throw new Error(\"cause and consequence must be different\")}for(var r=[],i=e.stack,a=null!==(n=null==t?void 0:t.stack)&&void 0!==n?n:[],o=i.length-1,c=a.length-1;o>=0&&c>=0&&i[o]===a[c];)r.unshift(i[o]),o--,c--;for(;o>=0;o--)r.unshift(i[o]);for(;c>=0;c--)r.unshift(a[c]);return new s(t.name,((t,e)=>{var n=t=>(null==t?void 0:t.trim())||\"(empty message)\",r=n(t);return null==e?r:\"\".concat(r,\"\\n\\tcaused by\\n\\t\\t\").concat(n(e))})(t.message,e.messageWithName),r)}static normalize(t){var e,n,r,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;if(\"production\"!==process.env.NODE_ENV){if(!(t instanceof Error))throw new Error(\"Error must be an instance of Error\");if(i<0)throw new Error(\"stripFrames must be >= 0\");if(a<0)throw new Error(\"minimumFrameCount must be >= 0\")}var o=null!==(e=t.message.toString().split(\"\\n\").find((t=>t.trim().length)))&&void 0!==e?e:\"(empty message)\",c=t.toString(),u=(null!==(n=t.stack)&&void 0!==n&&n.startsWith(c)&&t.stack!==c?t.stack.substring(c.length):null!==(r=t.stack)&&void 0!==r?r:\"\").split(\"\\n\").filter((t=>t.trim().length)),l=u.length>=i+a?i:0;return new s(t.name,o,u.slice(l))}static from(t){var e,n;if(\"production\"!==process.env.NODE_ENV&&!(t instanceof Error))throw new Error(\"Error must be an instance of Error\");var r=t.toString(),i=(null!==(e=t.stack)&&void 0!==e&&e.startsWith(r)&&t.stack!==r?t.stack.substring(r.length):null!==(n=t.stack)&&void 0!==n?n:\"\").split(\"\\n\").filter((t=>t.trim().length));return new s(t.name,t.message,i)}}class i extends Error{constructor(e){var i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:n.Unknown,{cause:a,prefix:o,name:c,metadata:u,stripStackFrames:l,minimumFrameCount:m,compositeStack:f}=arguments.length>2&&void 0!==arguments[2]?arguments[2]:Object.freeze({});if(\"production\"!==process.env.NODE_ENV){if(a&&!(a instanceof Error))throw new Error(\"cause must be an instance of Error\");if(null!=c&&/\\s/g.test(c))throw new Error(\"name must not contain whitespace\");if(/\\s/g.test(i))throw new Error(\"kind must not contain whitespace\");if(null!=o&&/\\s/g.test(o))throw new Error(\"prefix must not contain whitespace\");if(null!=l&&l<0)throw new Error(\"stripStackFrames must be >= 0\");if(null!=m&&m<0)throw new Error(\"minimumFrameCount must be >= 0\")}super(e),r(this,\"kind\",void 0),r(this,\"originalMessage\",void 0),r(this,\"originalStack\",void 0),r(this,\"metadata\",void 0),r(this,\"cause\",void 0),this.originalMessage=e,this.metadata=(e=>{if(null==e)return e;var n=t(e);return Object.freeze(n)})(u),this.name=\"\".concat(null!=o?o:\"\").concat(i).concat(null!=c?c:\"\",\"Error\"),this.kind=i,this.originalStack=this.stack,this.cause=a;var d=s.normalize(this,null!=l?l:0,null!=m?m:1);if(delete this.stack,this.stack=d.standardizedStack,null!=a){var h=s.from(a),v=s.fromConsequenceAndCause(d,h);this.message=v.message,!0===f&&(this.stack=v.standardizedStack)}}}var a=Object.freeze({ConsequenceFirst:\"consequence-first\",CauseFirst:\"cause-first\"});function*o(t,e){if(e!==a.CauseFirst&&e!==a.ConsequenceFirst)throw new i(\"Invalid sequence order\",n.InvalidInput,{metadata:{order:e}});null!=t&&(e===a.ConsequenceFirst&&(yield t),t instanceof i&&(yield*o(t.cause,e)),e===a.CauseFirst&&(yield t))}var c=t=>t instanceof i?t.kind:n.Unknown,u=t=>t instanceof i?t.originalStack:t.stack;function l(t){return Object.keys(t)}var m=t=>null==t||\"string\"==typeof t?{defaultValue:t}:t,f=function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:\"\",{defaultValue:n=\"\",indent:r}=m(e);if(null==t)return n;try{var s;return null!==(s=JSON.stringify(t,null,null!=r?r:0))&&void 0!==s?s:n}catch(t){return n}},d=\"...\";function h(t,e){if(t.length<=e)return t;var n=Math.floor(e/2),r=e-n-d.length,s=t.substr(0,n),i=t.substr(t.length-r);return\"\".concat(s).concat(d).concat(i)}var v=t=>Object.values(t),g=t=>t;export{n as Errors,i as KindError,a as Order,t as clone,e as entries,o as errorsFromError,c as getKindFromError,u as getOriginalStackFromError,l as keys,f as safeStringify,g as secret,h as truncateMiddle,v as values};\n//# sourceMappingURL=index.js.map\n","import {KindError} from \"@khanacademy/wonder-stuff-core\";\nimport type {ErrorOptions} from \"./types\";\n\n/**\n * Error kinds for DataError.\n */\nexport const DataErrors = Object.freeze({\n    /**\n     * The kind of error is not known.\n     */\n    Unknown: \"Unknown\",\n\n    /**\n     * The error is internal to the executing code.\n     */\n    Internal: \"Internal\",\n\n    /**\n     * There was a problem with the provided input.\n     */\n    InvalidInput: \"InvalidInput\",\n\n    /**\n     * A network error occurred.\n     */\n    Network: \"Network\",\n\n    /**\n     * There was a problem due to the state of the system not matching the\n     * requested operation or input.\n     */\n    NotAllowed: \"NotAllowed\",\n\n    /**\n     * Response could not be parsed.\n     */\n    Parse: \"Parse\",\n\n    /**\n     * An error that occurred during SSR and was hydrated from cache\n     */\n    Hydrated: \"Hydrated\",\n});\n\n/**\n * An error from the Wonder Blocks Data API.\n *\n * Errors of this type will have names of the format:\n *     `${kind}DataError`\n */\nexport class DataError extends KindError {\n    constructor(\n        message: string,\n        kind: typeof DataErrors[keyof typeof DataErrors],\n        {metadata, cause}: ErrorOptions = {} as Partial<ErrorOptions>,\n    ) {\n        super(message, kind, {\n            metadata,\n            cause,\n            name: \"Data\",\n        });\n    }\n}\n","import {DataError, DataErrors} from \"./data-error\";\nimport type {ScopedCache, RawScopedCache, ValidCacheData} from \"./types\";\n\n/**\n * Describe an in-memory cache.\n */\nexport class ScopedInMemoryCache implements ScopedCache {\n    _cache: RawScopedCache;\n\n    constructor(initialCache: RawScopedCache = {}) {\n        this._cache = initialCache;\n    }\n\n    /**\n     * Indicate if this cache is being used or not.\n     *\n     * When the cache has entries, returns `true`; otherwise, returns `false`.\n     */\n    get inUse(): boolean {\n        return Object.keys(this._cache).length > 0;\n    }\n\n    /**\n     * Set a value in the cache.\n     */\n    set(scope: string, id: string, value: ValidCacheData): void {\n        if (!id || typeof id !== \"string\") {\n            throw new DataError(\n                \"id must be non-empty string\",\n                DataErrors.InvalidInput,\n            );\n        }\n\n        if (!scope || typeof scope !== \"string\") {\n            throw new DataError(\n                \"scope must be non-empty string\",\n                DataErrors.InvalidInput,\n            );\n        }\n\n        if (typeof value === \"function\") {\n            throw new DataError(\n                \"value must be a non-function value\",\n                DataErrors.InvalidInput,\n            );\n        }\n\n        this._cache[scope] = this._cache[scope] ?? {};\n        this._cache[scope][id] = value;\n    }\n\n    /**\n     * Retrieve a value from the cache.\n     */\n    get(scope: string, id: string): ValidCacheData | null | undefined {\n        return this._cache[scope]?.[id] ?? null;\n    }\n\n    /**\n     * Purge an item from the cache.\n     */\n    purge(scope: string, id: string): void {\n        if (!this._cache[scope]?.[id]) {\n            return;\n        }\n        delete this._cache[scope][id];\n        if (Object.keys(this._cache[scope]).length === 0) {\n            delete this._cache[scope];\n        }\n    }\n\n    /**\n     * Purge a scope of items that match the given predicate.\n     *\n     * If the predicate is omitted, then all items in the scope are purged.\n     */\n    purgeScope(\n        scope: string,\n        predicate?: (id: string, value: ValidCacheData) => boolean,\n    ): void {\n        if (!this._cache[scope]) {\n            return;\n        }\n\n        if (predicate == null) {\n            delete this._cache[scope];\n            return;\n        }\n\n        for (const key of Object.keys(this._cache[scope])) {\n            if (predicate(key, this._cache[scope][key])) {\n                delete this._cache[scope][key];\n            }\n        }\n        if (Object.keys(this._cache[scope]).length === 0) {\n            delete this._cache[scope];\n        }\n    }\n\n    /**\n     * Purge all items from the cache that match the given predicate.\n     *\n     * If the predicate is omitted, then all items in the cache are purged.\n     */\n    purgeAll(\n        predicate?: (\n            scope: string,\n            id: string,\n            value: ValidCacheData,\n        ) => boolean,\n    ): void {\n        if (predicate == null) {\n            this._cache = {};\n            return;\n        }\n\n        for (const scope of Object.keys(this._cache)) {\n            this.purgeScope(scope, (id, value) => predicate(scope, id, value));\n        }\n    }\n}\n","import {clone} from \"@khanacademy/wonder-stuff-core\";\nimport {DataError, DataErrors} from \"./data-error\";\nimport {ScopedInMemoryCache} from \"./scoped-in-memory-cache\";\nimport type {ValidCacheData, RawScopedCache} from \"./types\";\n\n/**\n * Describe a serializable in-memory cache.\n */\nexport class SerializableInMemoryCache extends ScopedInMemoryCache {\n    constructor(initialCache: RawScopedCache = {}) {\n        try {\n            super(clone(initialCache));\n        } catch (e: any) {\n            throw new DataError(\n                `An error occurred trying to initialize from a response cache snapshot: ${e}`,\n                DataErrors.InvalidInput,\n            );\n        }\n    }\n\n    /**\n     * Set a value in the cache.\n     */\n    set(scope: string, id: string, value: ValidCacheData): void {\n        super.set(scope, id, Object.freeze(clone(value)));\n    }\n\n    /**\n     * Clone the cache.\n     */\n    clone(): RawScopedCache {\n        try {\n            return clone(this._cache);\n        } catch (e: any) {\n            throw new DataError(\n                \"An error occurred while trying to clone the cache\",\n                DataErrors.Internal,\n                {\n                    cause: e,\n                },\n            );\n        }\n    }\n}\n","import {Server} from \"@khanacademy/wonder-blocks-core\";\nimport {SerializableInMemoryCache} from \"./serializable-in-memory-cache\";\n\nimport type {ValidCacheData, CachedResponse, ResponseCache} from \"./types\";\n\nconst DefaultScope = \"default\";\n\n/**\n * The default instance is stored here.\n * It's created below in the Default() static property.\n */\nlet _default: SsrCache;\n\n/**\n * Implements the response cache.\n *\n * INTERNAL USE ONLY\n */\nexport class SsrCache {\n    static get Default(): SsrCache {\n        if (!_default) {\n            _default = new SsrCache();\n        }\n        return _default;\n    }\n\n    _hydrationCache: SerializableInMemoryCache;\n    _ssrOnlyCache: SerializableInMemoryCache;\n\n    constructor(\n        hydrationCache: SerializableInMemoryCache | null = null,\n        ssrOnlyCache: SerializableInMemoryCache | null = null,\n    ) {\n        this._ssrOnlyCache = ssrOnlyCache || new SerializableInMemoryCache();\n        this._hydrationCache =\n            hydrationCache || new SerializableInMemoryCache();\n    }\n\n    _setCachedResponse<TData extends ValidCacheData>(\n        id: string,\n        entry: CachedResponse<TData>,\n        hydrate: boolean,\n    ): CachedResponse<TData> {\n        const frozenEntry = Object.freeze(entry);\n        if (Server.isServerSide()) {\n            // We are server-side.\n            // We need to store this value.\n            if (hydrate) {\n                this._hydrationCache.set(DefaultScope, id, frozenEntry);\n            } else {\n                // Usually, when server-side, this cache will always be present.\n                // We do fake server-side in our doc example though, when it\n                // won't be.\n                this._ssrOnlyCache.set(DefaultScope, id, frozenEntry);\n            }\n        }\n        return frozenEntry;\n    }\n\n    /**\n     * Initialize the cache from a given cache state.\n     *\n     * This can only be called if the cache is not already in use.\n     */\n    initialize: (source: ResponseCache) => void = (source) => {\n        if (this._hydrationCache.inUse) {\n            throw new Error(\n                \"Cannot initialize data response cache more than once\",\n            );\n        }\n        this._hydrationCache = new SerializableInMemoryCache({\n            [DefaultScope]: source,\n        });\n    };\n\n    /**\n     * Cache data for a specific response.\n     *\n     * This is a noop when client-side.\n     */\n    cacheData: <TData extends ValidCacheData>(\n        id: string,\n        data: TData,\n        hydrate: boolean,\n    ) => CachedResponse<TData> = <TData extends ValidCacheData>(\n        id: string,\n        data: TData,\n        hydrate: boolean,\n    ): CachedResponse<TData> => this._setCachedResponse(id, {data}, hydrate);\n\n    /**\n     * Cache an error for a specific response.\n     *\n     * This is a noop when client-side.\n     */\n    cacheError: <TData extends ValidCacheData>(\n        id: string,\n        error: Error | string,\n        hydrate: boolean,\n    ) => CachedResponse<TData> = <TData extends ValidCacheData>(\n        id: string,\n        error: Error | string,\n        hydrate: boolean,\n    ): CachedResponse<TData> => {\n        const errorMessage = typeof error === \"string\" ? error : error.message;\n        return this._setCachedResponse(id, {error: errorMessage}, hydrate);\n    };\n\n    /**\n     * Retrieve data from our cache.\n     */\n    getEntry: <TData extends ValidCacheData>(\n        id: string,\n    ) => Readonly<CachedResponse<TData>> | null | undefined = <\n        TData extends ValidCacheData,\n    >(\n        id: string,\n    ): Readonly<CachedResponse<TData>> | null | undefined => {\n        // Get the cached entry for this value.\n\n        // We first look in the ssr cache, if we need to.\n        const ssrEntry = Server.isServerSide()\n            ? this._ssrOnlyCache.get(DefaultScope, id)\n            : null;\n\n        // Now we defer to the SSR value, and fallback to the hydration cache.\n        const internalEntry =\n            ssrEntry ?? this._hydrationCache.get(DefaultScope, id);\n\n        // If we are not server-side and we hydrated something, let's clear\n        // that from the hydration cache to save memory.\n        if (!Server.isServerSide() && internalEntry != null) {\n            // We now delete this from our hydration cache as we don't need it.\n            // This does mean that if another handler of the same type but\n            // without some sort of linked cache won't get the value, but\n            // that's not an expected use-case. If two different places use the\n            // same handler and options (i.e. the same request), then the\n            // handler should cater to that to ensure they share the result.\n            this._hydrationCache.purge(DefaultScope, id);\n        }\n        // Getting the typing right between the in-memory cache and this\n        // is hard. Just telling TypeScript it's OK.\n        // @ts-expect-error [FEI-5019] - TS2322 - Type 'string | number | boolean | Record<any, any> | null | undefined' is not assignable to type 'Readonly<CachedResponse<TData>> | null | undefined'.\n        return internalEntry;\n    };\n\n    /**\n     * Remove from cache, any entries matching the given handler and predicate.\n     *\n     * This will, if present therein, remove matching values from the framework\n     * in-memory cache.\n     *\n     * It returns a count of all records removed.\n     */\n    purgeData: (\n        predicate?: (\n            key: string,\n            cachedEntry: Readonly<CachedResponse<ValidCacheData>>,\n        ) => boolean,\n    ) => void = (predicate) => {\n        const realPredicate = predicate\n            ? // We know what we're putting into the cache so let's assume it\n              // conforms.\n              // @ts-expect-error [FEI-5019] - TS7006 - Parameter 'cachedEntry' implicitly has an 'any' type.\n              (_: string, key: string, cachedEntry) =>\n                  predicate(key, cachedEntry)\n            : undefined;\n\n        // Apply the predicate to what we have in our caches.\n        this._hydrationCache.purgeAll(realPredicate);\n        this._ssrOnlyCache.purgeAll(realPredicate);\n    };\n\n    /**\n     * Deep clone the hydration cache.\n     *\n     * By design, this only clones the data that is to be used for hydration.\n     */\n    cloneHydratableData: () => ResponseCache = (): ResponseCache => {\n        // We return our hydration cache only.\n        const cache = this._hydrationCache.clone();\n\n        // If we're empty, we still want to return an object, so we default\n        // to an empty object.\n        // We only need the default scope out of our scoped in-memory cache.\n        // We know that it conforms to our expectations.\n        // @ts-expect-error [FEI-5019] - TS2322 - Type '{ [id: string]: ValidCacheData; }' is not assignable to type 'ResponseCache'.\n        return cache[DefaultScope] ?? {};\n    };\n}\n","import type {Result, ValidCacheData} from \"./types\";\n\nimport {DataError, DataErrors} from \"./data-error\";\n\ntype RequestCache = {\n    [id: string]: Promise<Result<any>>;\n};\n\ntype FulfillOptions<TData extends ValidCacheData> = {\n    handler: () => Promise<TData>;\n    hydrate?: boolean;\n};\n\nlet _default: RequestFulfillment;\n\n/**\n * This fulfills a request, making sure that in-flight requests are shared.\n */\nexport class RequestFulfillment {\n    static get Default(): RequestFulfillment {\n        if (!_default) {\n            _default = new RequestFulfillment();\n        }\n        return _default;\n    }\n\n    _requests: RequestCache = {};\n\n    /**\n     * Get a promise of a request for a given handler and options.\n     *\n     * This will return an inflight request if one exists, otherwise it will\n     * make a new request. Inflight requests are deleted once they resolve.\n     */\n    fulfill: <TData extends ValidCacheData>(\n        id: string,\n        options: FulfillOptions<TData>,\n    ) => Promise<Result<TData>> = <TData extends ValidCacheData>(\n        id: string,\n        {handler, hydrate = true}: FulfillOptions<TData>,\n    ): Promise<Result<TData>> => {\n        /**\n         * If we have an inflight request, we'll provide that.\n         */\n        const inflight = this._requests[id];\n        if (inflight) {\n            return inflight;\n        }\n\n        /**\n         * We don't have an inflight request, so let's set one up.\n         */\n        const request = handler()\n            .then(\n                (data: TData): Result<TData> => ({\n                    status: \"success\",\n                    data,\n                }),\n            )\n            .catch((error: string | Error): Result<TData> => {\n                const actualError =\n                    typeof error === \"string\"\n                        ? new DataError(\"Request failed\", DataErrors.Unknown, {\n                              metadata: {\n                                  unexpectedError: error,\n                              },\n                          })\n                        : error;\n\n                // Return aborted result if the request was aborted.\n                // The only way to detect this reliably, it seems, is to\n                // check the error name and see if it's \"AbortError\" (this\n                // is also what Apollo does).\n                // Even then, it's reliant on the handler supporting aborts.\n                // TODO(somewhatabstract, FEI-4276): Add first class abort\n                // support to the handler API.\n                if (actualError.name === \"AbortError\") {\n                    return {\n                        status: \"aborted\",\n                    };\n                }\n                return {\n                    status: \"error\",\n                    error: actualError,\n                };\n            })\n            .finally(() => {\n                delete this._requests[id];\n            });\n\n        // Store the request in our cache.\n        this._requests[id] = request;\n\n        return request;\n    };\n\n    /**\n     * Abort an inflight request.\n     *\n     * NOTE: Currently, this does not perform an actual abort. It merely\n     * removes the request from being tracked.\n     */\n    abort: (id: string) => void = (id) => {\n        // TODO(somewhatabstract, FEI-4276): Add first class abort\n        // support to the handler API.\n        // For now, we will just clear the request out of the list.\n        // When abort is implemented, the `finally` in the `fulfill` method\n        // would handle the deletion.\n        delete this._requests[id];\n    };\n\n    /**\n     * Abort all inflight requests.\n     *\n     * NOTE: Currently, this does not perform actual aborts. It merely\n     * removes the requests from our tracking.\n     */\n    abortAll: () => void = (): void => {\n        Object.keys(this._requests).forEach((id) => this.abort(id));\n    };\n}\n","import * as React from \"react\";\nimport {SsrCache} from \"./ssr-cache\";\nimport {RequestFulfillment} from \"./request-fulfillment\";\n\nimport type {ResponseCache, ValidCacheData} from \"./types\";\n\ntype TrackerFn = <TData extends ValidCacheData>(\n    id: string,\n    handler: () => Promise<TData>,\n    hydrate: boolean,\n) => void;\n\ntype RequestCache = {\n    [id: string]: {\n        hydrate: boolean;\n        handler: () => Promise<any>;\n    };\n};\n\n/**\n * Used to inject our tracking function into the render framework.\n *\n * INTERNAL USE ONLY\n */\nconst TrackerContext: React.Context<TrackerFn | null | undefined> =\n    React.createContext<TrackerFn | null | undefined>(null);\nTrackerContext.displayName = \"TrackerContext\";\nexport {TrackerContext};\n\n/**\n * The default instance is stored here.\n * It's created below in the Default() static property.\n */\nlet _default: RequestTracker;\n\n/**\n * Implements request tracking and fulfillment.\n *\n * INTERNAL USE ONLY\n */\nexport class RequestTracker {\n    static get Default(): RequestTracker {\n        if (!_default) {\n            _default = new RequestTracker();\n        }\n        return _default;\n    }\n\n    /**\n     * These are the caches for tracked requests, their handlers, and responses.\n     */\n    _trackedRequests: RequestCache = {};\n    _responseCache: SsrCache;\n    _requestFulfillment: RequestFulfillment;\n\n    // @ts-expect-error [FEI-5019] - TS2322 - Type 'undefined' is not assignable to type 'SsrCache | null'.\n    constructor(responseCache: SsrCache | null = undefined) {\n        this._responseCache = responseCache || SsrCache.Default;\n        this._requestFulfillment = new RequestFulfillment();\n    }\n\n    /**\n     * Track a request.\n     *\n     * This method caches a request and its handler for use during server-side\n     * rendering to allow us to fulfill requests before producing a final render.\n     */\n    trackDataRequest: <TData extends ValidCacheData>(\n        id: string,\n        handler: () => Promise<TData>,\n        hydrate: boolean,\n    ) => void = <TData extends ValidCacheData>(\n        id: string,\n        handler: () => Promise<TData>,\n        hydrate: boolean,\n    ): void => {\n        /**\n         * If we don't already have this tracked, then let's track it.\n         */\n        if (this._trackedRequests[id] == null) {\n            this._trackedRequests[id] = {\n                handler,\n                hydrate,\n            };\n        }\n    };\n\n    /**\n     * Reset our tracking info.\n     */\n    reset: () => void = () => {\n        this._trackedRequests = {};\n    };\n\n    /**\n     * Indicates if we have requests waiting to be fulfilled.\n     */\n    get hasUnfulfilledRequests(): boolean {\n        return Object.keys(this._trackedRequests).length > 0;\n    }\n\n    /**\n     * Initiate fulfillment of all tracked requests.\n     *\n     * This loops over the requests that were tracked using TrackData, and asks\n     * the respective handlers to fulfill those requests in the order they were\n     * tracked.\n     *\n     * Calling this method marks tracked requests as fulfilled; requests are\n     * removed from the list of tracked requests by calling this method.\n     *\n     * @returns {Promise<ResponseCache>} The promise of the data that was\n     * cached as a result of fulfilling the tracked requests.\n     */\n    fulfillTrackedRequests: () => Promise<ResponseCache> =\n        (): Promise<ResponseCache> => {\n            const promises = [];\n            const {cacheData, cacheError} = this._responseCache;\n\n            for (const requestKey of Object.keys(this._trackedRequests)) {\n                const options = this._trackedRequests[requestKey];\n\n                try {\n                    promises.push(\n                        this._requestFulfillment\n                            .fulfill(requestKey, {...options})\n                            .then((result) => {\n                                switch (result.status) {\n                                    case \"success\":\n                                        /**\n                                         * Let's cache the data!\n                                         *\n                                         * NOTE: This only caches when we're\n                                         * server side.\n                                         */\n                                        cacheData(\n                                            requestKey,\n                                            result.data,\n                                            options.hydrate,\n                                        );\n                                        break;\n\n                                    case \"error\":\n                                        /**\n                                         * Let's cache the error!\n                                         *\n                                         * NOTE: This only caches when we're\n                                         * server side.\n                                         */\n                                        cacheError(\n                                            requestKey,\n                                            result.error,\n                                            options.hydrate,\n                                        );\n                                        break;\n                                }\n\n                                // For status === \"loading\":\n                                // Could never get here unless we wrote\n                                // the code wrong. Rather than bloat\n                                // code with useless error, just ignore.\n\n                                // For status === \"aborted\":\n                                // We won't cache this.\n                                // We don't hydrate aborted requests,\n                                // so the client would just see them\n                                // as unfulfilled data.\n                                return;\n                            }),\n                    );\n                } catch (e: any) {\n                    // This captures if there are problems in the code that\n                    // begins the requests.\n                    promises.push(\n                        Promise.resolve(\n                            cacheError(requestKey, e, options.hydrate),\n                        ),\n                    );\n                }\n            }\n\n            /**\n             * Clear out our tracked info.\n             *\n             * We call this now for a simpler API.\n             *\n             * If we reset the tracked calls after all promises resolve, any\n             * request tracking done while promises are in flight would be lost.\n             *\n             * If we don't reset at all, then we have to expose the `reset` call\n             * for consumers to use, or they'll only ever be able to accumulate\n             * more and more tracked requests, having to fulfill them all every\n             * time.\n             *\n             * Calling it here means we can have multiple \"track -> request\"\n             * cycles in a row and in an easy to reason about manner.\n             */\n            this.reset();\n\n            /**\n             * Let's wait for everything to fulfill, and then clone the cached data.\n             */\n            return Promise.all(promises).then(() =>\n                this._responseCache.cloneHydratableData(),\n            );\n        };\n}\n","import * as React from \"react\";\nimport {Server} from \"@khanacademy/wonder-blocks-core\";\n\nimport {RequestTracker, TrackerContext} from \"../util/request-tracking\";\n\ntype TrackDataProps = {\n    children: React.ReactNode;\n};\n\n/**\n * Component to enable data request tracking when server-side rendering.\n */\nexport default class TrackData extends React.Component<TrackDataProps> {\n    render(): React.ReactNode {\n        if (!Server.isServerSide()) {\n            throw new Error(\n                \"This component is not for use during client-side rendering\",\n            );\n        }\n        return (\n            <TrackerContext.Provider\n                value={RequestTracker.Default.trackDataRequest}\n            >\n                {this.props.children}\n            </TrackerContext.Provider>\n        );\n    }\n}\n","import * as React from \"react\";\nimport type {ValidCacheData} from \"../util/types\";\n\ntype InterceptContextData = ReadonlyArray<\n    (\n        requestId: string,\n    ) => Promise<ValidCacheData | null | undefined> | null | undefined\n>;\n\n/**\n * InterceptContext defines a map from request ID to interception methods.\n *\n * INTERNAL USE ONLY\n */\nconst InterceptContext: React.Context<InterceptContextData> =\n    React.createContext<InterceptContextData>([]);\nInterceptContext.displayName = \"InterceptContext\";\n\nexport default InterceptContext;\n","import * as React from \"react\";\n\nimport InterceptContext from \"./intercept-context\";\n\nimport type {ValidCacheData} from \"../util/types\";\n\ntype Props<TData extends ValidCacheData> = {\n    /**\n     * Called to intercept and possibly handle the request.\n     * If this returns null, the request will be handled by ancestor\n     * any ancestor interceptors, and ultimately, the original request\n     * handler, otherwise, this interceptor is handling the request.\n     *\n     * Interceptors are called in ancestor precedence, with the closest\n     * interceptor ancestor being called first, and the furthest ancestor\n     * being called last.\n     *\n     * Beware: Interceptors do not care about what data they are intercepting,\n     * so make sure to only intercept requests that you recognize from the\n     * identifier.\n     */\n    interceptor: (requestId: string) => Promise<TData> | null | undefined;\n    /**\n     * The children to render within this component. Any requests by `Data`\n     * components that use same ID as this component will be intercepted.\n     * If `InterceptRequests` is used within `children`, that interception will\n     * be given a chance to intercept first.\n     */\n    children: React.ReactNode;\n};\n\n/**\n * This component provides a mechanism to intercept data requests.\n * This is for use in testing.\n *\n * This component is not recommended for use in production code as it\n * can prevent predictable functioning of the Wonder Blocks Data framework.\n * One possible side-effect is that inflight requests from the interceptor could\n * be picked up by `Data` component requests from outside the children of this\n * component.\n *\n * Interceptions within the same component tree are chained such that the\n * interceptor closest to the intercepted request is called first, and the\n * furthest interceptor is called last.\n */\nconst InterceptRequests = <TData extends ValidCacheData>({\n    interceptor,\n    children,\n}: Props<TData>): React.ReactElement => {\n    const interceptors = React.useContext(InterceptContext);\n\n    const updatedInterceptors = React.useMemo(\n        // We could build this in reverse order so that our hook that does\n        // the interception didn't have to use reduceRight, but I think it\n        // is easier to think about if we do this in component tree order.\n        () => [...interceptors, interceptor],\n        [interceptors, interceptor],\n    );\n\n    return (\n        <InterceptContext.Provider value={updatedInterceptors}>\n            {children}\n        </InterceptContext.Provider>\n    );\n};\n\nexport default InterceptRequests;\n","import * as React from \"react\";\nimport type {GqlRouterConfiguration} from \"./gql-types\";\n\nconst GqlRouterContext: React.Context<\n    GqlRouterConfiguration<any> | null | undefined\n> = React.createContext<GqlRouterConfiguration<any> | null | undefined>(null);\nGqlRouterContext.displayName = \"GqlRouterContext\";\n\nexport {GqlRouterContext};\n","import * as React from \"react\";\n\nimport {GqlRouterContext} from \"../util/gql-router-context\";\n\nimport type {\n    GqlContext,\n    GqlFetchFn,\n    GqlRouterConfiguration,\n} from \"../util/gql-types\";\n\ntype Props<TContext extends GqlContext> = {\n    /**\n     * The default context to be used by operations when no context is provided.\n     */\n    defaultContext: TContext;\n    /**\n     * The function to use when fetching requests.\n     */\n    fetch: GqlFetchFn<any, any, TContext>;\n    /**\n     * The children to be rendered inside the router.\n     */\n    children: React.ReactNode;\n};\n\n/**\n * Configure GraphQL routing for GraphQL hooks and components.\n *\n * These can be nested. Components and hooks relying on the GraphQL routing\n * will use the configuration from their closest ancestral GqlRouter.\n */\nexport const GqlRouter = <TContext extends GqlContext>({\n    defaultContext: thisDefaultContext,\n    fetch: thisFetch,\n    children,\n}: Props<TContext>): React.ReactElement => {\n    // We don't care if we're nested. We always force our callers to define\n    // everything. It makes for a clearer API and requires less error checking\n    // code (assuming our TypeScript types are correct). We also don't default\n    // fetch to anything - our callers can tell us what function to use quite\n    // easily. If code that consumes this wants more nuanced nesting, it can\n    // implement it within its own GqlRouter than then defers to this one.\n\n    // We want to always use the same object if things haven't changed to avoid\n    // over-rendering consumers of our context, let's memoize the configuration.\n    // By doing this, if a component under children that uses this context\n    // uses React.memo, we won't force it to re-render every time we render\n    // because we'll only change the context value if something has actually\n    // changed.\n    const configuration: GqlRouterConfiguration<TContext> = React.useMemo(\n        () => ({\n            fetch: thisFetch,\n            defaultContext: thisDefaultContext,\n        }),\n        [thisDefaultContext, thisFetch],\n    );\n\n    return (\n        <GqlRouterContext.Provider value={configuration}>\n            {children}\n        </GqlRouterContext.Provider>\n    );\n};\n"],"names":["serverSide","Server","t","e","n","r","s","i","u","l","a","o","c","m","d","h","v","DataErrors","DataError","KindError","message","kind","metadata","cause","ScopedInMemoryCache","initialCache","scope","id","value","_a","predicate","key","SerializableInMemoryCache","clone","DefaultScope","_default","SsrCache","hydrationCache","ssrOnlyCache","source","data","hydrate","error","errorMessage","internalEntry","realPredicate","_","cachedEntry","entry","frozenEntry","RequestFulfillment","handler","inflight","request","actualError","TrackerContext","React.createContext","RequestTracker","responseCache","promises","cacheData","cacheError","requestKey","options","result","TrackData","React.Component","jsx","InterceptContext","InterceptRequests","interceptor","children","interceptors","React.useContext","updatedInterceptors","React.useMemo","GqlRouterContext","GqlRouter","thisDefaultContext","thisFetch","configuration"],"mappings":"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","x_google_ignoreList":[1]}