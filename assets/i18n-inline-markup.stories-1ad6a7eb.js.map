{"version":3,"file":"i18n-inline-markup.stories-1ad6a7eb.js","sources":["../../packages/wonder-blocks-i18n/src/functions/i18n-accents.ts","../../packages/wonder-blocks-i18n/src/functions/i18n-boxes.ts","../../packages/wonder-blocks-i18n/src/functions/locale.ts","../../packages/wonder-blocks-i18n/src/functions/i18n-faketranslate.ts","../../packages/wonder-blocks-i18n/src/functions/i18n.ts","../../packages/wonder-blocks-i18n/src/components/parse-simple-html.ts","../../packages/wonder-blocks-i18n/src/components/i18n-inline-markup.tsx"],"sourcesContent":["import type {IProvideTranslation} from \"./types\";\n\n// This map provides a way to get an \"accented\" character for any of the\n// 26 english alphabet characters in either upper or lower case.\n// This map is sourced from Wikipedia pages on diacritics and specific letters\n// (example URLs below):\n//    - https://en.wikipedia.org/wiki/Diacritic\n//    - https://en.wikipedia.org/wiki/W\nconst ACCENT_MAP = {\n    a: \"áàăắặâấåäãąā\",\n    A: \"ÁÀĂẮẶÂẤÅÄÃĄĀ\",\n    b: \"ƀḃḅ\",\n    B: \"ɃḂḄ\",\n    c: \"ćĉčç\",\n    C: \"ĆĈČÇ\",\n    d: \"ďđḑ\",\n    D: \"ĎĐḐ\",\n    e: \"éèêềěëėęē\",\n    E: \"ÉÈÊỀĚËĖĘĒ\",\n    f: \"ḟ\",\n    F: \"Ḟ\",\n    g: \"ĝǧģ\",\n    G: \"ĜǦĢ\",\n    h: \"ĥȟħḥ\",\n    H: \"ĤȞĦḤ\",\n    i: \"íìîïįī\",\n    I: \"ÎÏÍÌĮĪ\",\n    j: \"ĵ\",\n    J: \"Ĵ\",\n    k: \"ķḱ\",\n    K: \"ĶḰ\",\n    l: \"ĺľłļḷ\",\n    L: \"ĹĽŁĻḶ\",\n    m: \"ḿṁṃm̃\",\n    M: \"ḾṀṂM̃\",\n    n: \"ńňñņŋ\",\n    N: \"ŃŇÑŅŊ\",\n    o: \"óòôöőõȯȱøōỏ\",\n    O: \"ÓÒÔÖŐÕȮȰØŌỏ\",\n    p: \"ṕṗᵽ\",\n    P: \"ṔṖⱣ\",\n    q: \"ʠ\",\n    Q: \"Ɋ\",\n    r: \"ŕřŗ\",\n    R: \"ŔŘŖ\",\n    s: \"śŝšș\",\n    S: \"ŚŜŠŞ\",\n    t: \"ťț\",\n    T: \"ŤŢ\",\n    u: \"úùŭûůüųűūư\",\n    U: \"ÚÙŬÛŮÜŲŰŪƯ\",\n    v: \"ṽṿ\",\n    V: \"ṼṾ\",\n    w: \"ẃẁŵẅ\",\n    W: \"ẂẀŴẄ\",\n    y: \"ý\",\n    Y: \"Ý\",\n    x: \"ẍẋ\",\n    X: \"ẌẊ\",\n    z: \"źžż\",\n    Z: \"ŹŽŻ\",\n} as const;\n\n// This regular expression matches the keys in our map.\nconst SubstitutionRegex = new RegExp(\n    `[${Object.keys(ACCENT_MAP).join(\"\")}]`,\n    \"g\",\n);\n\nexport default class Accents implements IProvideTranslation {\n    _scaleFactor: number;\n\n    constructor(scaleFactor = 1) {\n        if (scaleFactor < 1) {\n            throw new Error(\"Scaling factor must be 1 or greater.\");\n        }\n        this._scaleFactor = scaleFactor;\n    }\n\n    translate: (input: string) => string = (input: string): string => {\n        if (!input) {\n            return \"\";\n        }\n\n        const countMap: Record<string, any> = {};\n        const updateCount = (char: string) => {\n            const count = countMap[char] || 0;\n            countMap[char] = count + 1;\n            return count;\n        };\n\n        // We want to substitute each character in the input string with\n        // a corresponding accent character from the map. We also want to\n        // ensure this is entirely deterministic, so we vary the accents based\n        // on our intended string width and the repetition of the characters.\n        return input.replace(SubstitutionRegex, (substring) => {\n            // @ts-expect-error [FEI-5019] - TS7053 - Element implicitly has an 'any' type because expression of type 'string' can't be used to index type '{ readonly a: \"áàăắặâấåäãąā\"; readonly A: \"ÁÀĂẮẶÂẤÅÄÃĄĀ\"; readonly b: \"ƀḃḅ\"; readonly B: \"ɃḂḄ\"; readonly c: \"ćĉčç\"; readonly C: \"ĆĈČÇ\"; readonly d: \"ďđḑ\"; readonly D: \"ĎĐḐ\"; readonly e: \"éèêềěëėęē\"; ... 42 more ...; readonly Z: \"ŹŽŻ\"; }'.\n            const possibles = ACCENT_MAP[substring];\n            const count = updateCount(substring);\n            return possibles[count % possibles.length].repeat(\n                this._scaleFactor,\n            );\n        });\n    };\n}\n","import type {IProvideTranslation} from \"./types\";\n\n// c.f. http://www.alanflavell.org.uk/unicode/unidata25.html\n// hollow (white) square; also try \\u25a0 or \\u25aa+b\nexport const BoxChar = \"\\u25a1\";\n\nconst AlphaNumRegex = /\\w/g;\n\nexport default class Boxes implements IProvideTranslation {\n    translate(input: string): string {\n        if (!input) {\n            return \"\";\n        }\n\n        if (input.startsWith(\"&\")) {\n            return BoxChar;\n        }\n\n        return input.replace(AlphaNumRegex, BoxChar);\n    }\n}\n","let __locale = \"en\"; // We default to English if no locale has been set\n\nexport const setLocale = (locale: string): void => {\n    __locale = locale;\n};\n\nexport const getLocale = (): string => {\n    return __locale;\n};\n","import Accents from \"./i18n-accents\";\nimport Boxes from \"./i18n-boxes\";\nimport {getLocale} from \"./locale\";\n\nimport type {IProvideTranslation} from \"./types\";\n\ntype TranslatorMap = {\n    [key: string]: IProvideTranslation;\n};\n\n/**\n * A map of language key to translator.\n *\n * This map is used by our i18n calls to look up client-side translations when\n * a match does not otherwise exist.\n */\nexport const Translators: TranslatorMap = {\n    boxes: new Boxes(),\n\n    // Our accents translation also makes the string twice as long.\n    // NOTE(jeff): If we want longer strings, change this number.\n    accents: new Accents(2),\n};\n\n/**\n * A translator that performs all the work of looking up what translation to use\n * and then uses it.\n *\n * @export\n * @class FakeTranslate\n * @implements {IProvideTranslation}\n */\nexport default class FakeTranslate implements IProvideTranslation {\n    get _translator(): IProvideTranslation | undefined {\n        // We look up our fake translator on the fly in case the kaLocale\n        // was changed.\n        return Translators[getLocale()];\n    }\n\n    _translateSegment(input: string): string {\n        // This method takes a string and returns an array.\n        // It looks for two things to separate text:\n        // 1. URLs\n        // 2. Python variable substitutions\n        const urlRegex =\n            /((http[s]?|ftp):\\/\\/)?([\\w-]+\\.)([\\w-.]+)((\\/[\\w-]+)*)?\\/?(#[\\w-]*)?(\\?[\\w-]+(=[\\w%\"']+)?(&[\\w-]+(=[\\w%\"']+)?)*)?/g;\n        const pythonSubstRegex = /%\\([\\w]+\\)s/g;\n\n        const tokenSearchRegex = new RegExp(\n            `${urlRegex.source}|${pythonSubstRegex.source}`,\n            \"g\",\n        );\n\n        const safeTranslate = (str: string) =>\n            // We know that we have a translator at this point, so just ignore\n            // TypeScript.\n            // @ts-expect-error [FEI-5019] - TS2533 - Object is possibly 'null' or 'undefined'.\n            this._translator.translate(str);\n\n        // The way it works.\n        // 1. Look for a thing\n        // 2. Take before the thing and lex against other things\n        // 3. Take after the thing and lex that for python vars\n        // 4. Flatten into a single array and return.\n        const subsegments: Array<any | string> = [];\n        let lastMatchEndIndex = 0;\n        let match = tokenSearchRegex.exec(input);\n        while (match !== null) {\n            if (match.index !== lastMatchEndIndex) {\n                subsegments.push(\n                    safeTranslate(\n                        input.substring(lastMatchEndIndex, match.index),\n                    ),\n                );\n            }\n            subsegments.push(match[0]);\n            lastMatchEndIndex = match.index + match[0].length;\n            match = tokenSearchRegex.exec(input);\n        }\n\n        if (lastMatchEndIndex < input.length) {\n            subsegments.push(safeTranslate(input.substring(lastMatchEndIndex)));\n        }\n\n        return subsegments.join(\"\");\n    }\n\n    _parseAndTranslate(input: string): string {\n        if (!this._translator || input == null) {\n            // We're doing nothing if we don't have to.\n            return input;\n        }\n\n        // Here we parse the input text into chunks. Some chunks need\n        // translating and some do not.\n\n        // The input is chunked to cater for embedded HTML tags and variable\n        // subsitution syntax. Tags and variables are left alone, with the\n        // surrounding text being translated using our fake translation.\n\n        // This is based off the more complex work done in the backend\n        // fake_translate.py. However, that handles far more scenarios as\n        // a lot more content passes through that system. We're fortunate here\n        // in that we only need consider the thing things that might get passed\n        // in frontend code, so we can be a little more general.\n\n        // The things that we are specifically looking for are:\n        // 1. HTML tags\n        // 2. Python-style variable substitutions like %(str)s\n        // 3. URLs\n\n        // So, first, let's get the content as an array of HTML and text nodes.\n        // We're leveraging the dom for this since it already knows about HTML.\n        const stringToHTMLElements = (htmlString: string) => {\n            const template = document.createElement(\"template\");\n            template.innerHTML = htmlString;\n            return template;\n        };\n\n        const html = stringToHTMLElements(input);\n\n        // Now we can go through each one and translate the text bits.\n        // This is a recursive function to cater for situations such as:\n        //\n        //      <a href=\"#\"><b>Some bold</b> and not bold link text</a>\n        const processChildNodes = (parent: Node | DocumentFragment): void => {\n            for (const node of parent.childNodes) {\n                if (node.nodeType === Node.TEXT_NODE) {\n                    // Something to translate!\n                    // @ts-expect-error [FEI-5019] - TS2345 - Argument of type 'string | null' is not assignable to parameter of type 'string'.\n                    const newText = this._translateSegment(node.textContent);\n                    if (newText != null) {\n                        const newTextNode = document.createTextNode(newText);\n                        parent.replaceChild(newTextNode, node);\n                    }\n                } else {\n                    switch (node.nodeName) {\n                        case \"CODE\":\n                        case \"PRE\":\n                            // Don't want to translate these tags.\n                            break;\n\n                        default:\n                            // Recurse into everything else.\n                            processChildNodes(node);\n                            break;\n                    }\n                }\n            }\n        };\n\n        processChildNodes(html.content);\n\n        // Because we used the parsing powers of the DOM, any special characters\n        // will have been encoded as entities. We want to strip those, so we do\n        // that here.\n        const tempNode = document.createElement(\"template\");\n        // @ts-expect-error [FEI-5019] - TS2769 - No overload matches this call.\n        const entitiesDecoded = html.innerHTML.replace(/&(\\w+);/g, (match) => {\n            tempNode.innerHTML = match;\n            return tempNode.content.textContent;\n        });\n        return entitiesDecoded;\n    }\n\n    translate: (input: string) => string = (input: string): string =>\n        this._parseAndTranslate(input);\n}\n","/* eslint-disable @babel/no-invalid-this */\n/* TODO(csilvers): fix these lint errors (http://eslint.org/docs/rules): */\n/* To fix, remove an entry above, run ka-lint, and fix errors. */\nimport * as React from \"react\";\n\nimport FakeTranslate from \"./i18n-faketranslate\";\nimport {allPluralForms} from \"./plural-forms\";\n\ntype InterpolationOptions<T> = {\n    [key: string]: T;\n};\n\ntype NGetOptions = {\n    [key: string]: any;\n};\n\ntype PluralConfigurationObject = {\n    lang: string;\n    messages: Array<string>;\n};\n\ninterface ngettextOverloads {\n    (\n        config: PluralConfigurationObject,\n        num?: number | null | undefined,\n        options?: NGetOptions,\n    ): string;\n    (\n        singular: string,\n        plural: string,\n        num?: number | null | undefined,\n        options?: NGetOptions,\n    ): string;\n}\n\ninterface _Overloads {\n    (\n        str: string,\n        options?:\n            | InterpolationOptions<string | number | null | undefined>\n            | null\n            | undefined,\n    ): string;\n    (\n        pluralConfig: PluralConfigurationObject,\n        options?:\n            | InterpolationOptions<string | number | null | undefined>\n            | null\n            | undefined,\n    ): string;\n}\n\ninterface internalTranslateOverloads {\n    (\n        str: string,\n        options:\n            | InterpolationOptions<string | number | null | undefined>\n            | null\n            | undefined,\n        additionalTranslation: (arg1: string) => string,\n    ): string;\n    (\n        pluralConfig: PluralConfigurationObject,\n        options:\n            | InterpolationOptions<string | number | null | undefined>\n            | null\n            | undefined,\n        additionalTranslation: (arg1: string) => string,\n    ): string;\n}\n\nconst {translate: fakeTranslate} = new FakeTranslate();\n\ntype Language = keyof typeof allPluralForms;\n\nconst interpolationMarker = /%\\(([\\w_]+)\\)s/g;\n/**\n * Performs sprintf-like %(name)s replacement on str, and returns a React\n * fragment of the string interleaved with those replacements. The replacements\n * can be any valid React node including strings and numbers.\n *\n * For example:\n *  interpolateStringToFragment(\"test\", {}) ->\n *      test\n *  interpolateStringToFragment(\"test %(num)s\", {num: 5}) ->\n *      test 5\n *  interpolateStringToFragment(\"test %(num)s\", {num: <Count />}) ->\n *      test <Count />\n */\nconst interpolateStringToFragment = function (\n    str: string,\n    options?: InterpolationOptions<React.ReactNode | null | undefined> | null,\n): React.ReactNode {\n    options = options || {};\n\n    // Split the string into its language fragments and substitutions\n    const split = fakeTranslate(str).split(interpolationMarker);\n\n    const result: {\n        [key: string]: React.ReactNode;\n    } = {text_0: split[0]};\n\n    // Replace the substitutions with the appropriate option\n    for (let i = 1; i < split.length; i += 2) {\n        const key = split[i];\n        let replaceWith = options[key];\n        if (replaceWith === undefined) {\n            replaceWith = `%(${key})s`;\n        }\n\n        // We prefix each substitution key with a number that increments each\n        // time it's used, so \"test %(num)s %(fruit)s and %(num)s again\" turns\n        // into an object with keys:\n        // [text_0, 0_num, text_2, 0_fruit, text_4, 1_num, text_6]\n        // This is better than just using the array index in the case that we\n        // switch between two translated strings with the same variables.\n        // Admittedly, an edge case.\n        let j = 0;\n        while (`${j}_${key}` in result) {\n            j++;\n        }\n        result[`${j}_${key}`] = replaceWith;\n        // Because the regex has one capturing group, the `split` array always\n        // has an odd number of elements, so this always stays in bounds.\n        result[`text_${i + 1}`] = split[i + 1];\n    }\n\n    if (Object.keys(result).length === 1 && result.text_0) {\n        return result.text_0;\n    }\n\n    // We have to cast the result to any here before then back to React.Node\n    // because Object.values is typed as returning Array<unknown> and TypeScript\n    // is not happy about `unknown` being turned into React.ReactElement and a couple\n    // of other subtypes of React.ReactNode. However, we know this is an array of\n    // React.Node so rather than lose all typing and ignoring the error, we\n    // do a little casting to any and then to React.ReactNode.\n    const children: Array<React.ReactNode> = Object.values(\n        result,\n    ) as Array<any>;\n\n    // NOTE: We need to use createElement here because\n    // <React.Fragment>{Object.values(result)}</React.Fragment>\n    // triggers the following error:\n    //      Warning: Each child in an array or iterator should have a\n    //      unique \"key\" prop.\n    return React.createElement(React.Fragment, {}, ...children);\n};\n\n/**\n * This is the real worker for handling substitution and fake translation.\n */\nconst internalTranslate: internalTranslateOverloads = (\n    strOrPluralConfig,\n    options,\n    additionalTranslation: (arg1: string) => string,\n) => {\n    // Sometimes we're given an argument that's meant for ngettext().  This\n    // happens if the same string is used in both i18n._() and i18n.ngettext()\n    // (.g. a = i18n._(foo); b = i18n.ngettext(\"foo\", \"bar\", count);\n    // In such cases, only the plural form ends up in the .po file, and\n    // then it gets sent to us for the i18n._() case too.  No problem, though:\n    // we'll just take the singular arg.\n    if (typeof strOrPluralConfig === \"object\" && strOrPluralConfig.messages) {\n        strOrPluralConfig = strOrPluralConfig.messages[0];\n    }\n\n    // @ts-expect-error [FEI-5019] - TS2345 - Argument of type 'string | PluralConfigurationObject' is not assignable to parameter of type 'string'.\n    const translated = additionalTranslation(strOrPluralConfig);\n    // Options are optional, if we don't have any, just return the string.\n    if (options == null) {\n        return translated;\n    }\n\n    // Otherwise, let's see if our string has anything to be replaced.\n    return translated.replace(interpolationMarker, (match, key) => {\n        const replaceWith = options[key];\n        return replaceWith != null ? String(replaceWith) : match;\n    });\n};\n\n/**\n * Simple i18n method with sprintf-like %(name)s replacement\n * To be used like so:\n *   i18n._(\"Some string\")\n *   i18n._(\"Hello %(name)s\", {name: \"John\"})\n */\nexport const _: _Overloads = (strOrPluralConfig, options) =>\n    // @ts-expect-error [FEI-5019] - TS2769 - No overload matches this call.\n    internalTranslate(strOrPluralConfig, options, fakeTranslate);\n\n/**\n * i18n method that supports sprintf-like %(name)s replacement for React nodes\n * as well as strings. To be used like so:\n *   i18n._(\n *       \"Look at this flashing text!: %(node)s\",\n *       {node: <blink>Ahh my eyes!</blink>}\n *   )\n */\nexport const $_: (\n    str: string,\n    options?:\n        | InterpolationOptions<React.ReactNode | null | undefined>\n        | null\n        | undefined,\n) => React.ReactNode = function (str, options) {\n    return interpolateStringToFragment(str, options);\n};\n\n/**\n * Simple ngettext method with sprintf-like %(name)s replacement\n * To be used like so:\n *   i18n.ngettext(\"Singular\", \"Plural\", 3)\n *   i18n.ngettext(\"%(num)s Cat\", \"%(num)s Cats\", 3)\n *   i18n.ngettext(\n *           \"%(num)s %(type)s Cat\",\n *           \"%(num)s %(type)s Cats\",\n *           3, {type: \"Calico\"})\n *\n * This method is also meant to be used when injecting for other\n * non-English languages, like so (taking an array of plural messages,\n * which varies based upon the language):\n *   i18n.ngettext({\n *     lang: \"ja\",\n *     messages: [\"%(num)s 猫 %(username)s\"]\n *   }, 3, {username: \"John\"});\n *\n * Note: the \"singular variant\" of a string isn't always associated with a\n * quantity of 1 in all languages, so do not hardcode one into the variant.\n * French uses it for 0 and 1. In Japanese, if the number of results is 100\n * (or any number) we'd be showing \"1 結果\" regardless of the number.\n * In Russian, any number ending in 1 (e.g. 21, 61) uses singular form.\n * You should instead still parameterize the number.\n */\nexport const ngettext: ngettextOverloads = (\n    singular: string | PluralConfigurationObject,\n    plural?: string | number | null | undefined,\n    num?: number | null | undefined | NGetOptions,\n    options?: NGetOptions,\n) => {\n    const {messages, lang}: PluralConfigurationObject =\n        typeof singular === \"object\"\n            ? singular\n            : {\n                  lang: \"en\",\n                  // We know plural is a string if singular is not a config object\n                  messages: [singular, plural as any],\n              };\n\n    const actualNum: number =\n        typeof singular === \"object\" ? plural : (num as any);\n    const actualOptions: NGetOptions =\n        (typeof singular === \"object\" ? num : (options as any)) || {};\n\n    // Get the translated string\n    const idx = ngetpos(actualNum, lang);\n\n    // The common (non-error) case is messages[idx].\n    const translation = idx < messages.length ? messages[idx] : \"\";\n\n    // Get the options to substitute into the string.\n    // We automatically add in the 'magic' option-variable 'num'.\n    actualOptions.num = actualOptions.num || actualNum;\n\n    // Then pass into i18n._ for the actual substitution\n    return _(translation, actualOptions);\n};\n\n/*\n * Return the ngettext position that matches the given number and lang.\n *\n * Arguments:\n *  - num: The number upon which to toggle the plural forms.\n *  - lang: The language to use as the basis for the pluralization.\n */\nexport const ngetpos = function (num: number, lang?: Language): number {\n    const pluralForm = (lang && allPluralForms[lang]) || allPluralForms[\"en\"];\n    const pos = pluralForm(num);\n    // Map true to 1 and false to 0, keep any numeric return value the same.\n    return pos === true ? 1 : pos ? pos : 0;\n};\n\n/*\n * A dummy identity function.  It's used as a signal to automatic\n * translation-identification tools that they shouldn't mark this\n * text up to be translated, even though it looks like\n * natural-language text.  (And likewise, a signal to linters that\n * they shouldn't complain that this text isn't translated.)\n * Use it like so: 'tag.author = i18n.doNotTranslate(\"Jim\");'\n */\nexport const doNotTranslate: _Overloads = (s, o) =>\n    // @ts-expect-error [FEI-5019] - TS2769 - No overload matches this call.\n    internalTranslate(s, o, (t) => t);\n\n/*\n * A dummy identity function, like i18n.doNotTranslate. It's used to\n * represent strings that may undergo revisions and should not be\n * translated yet.\n */\nexport const doNotTranslateYet: _Overloads = doNotTranslate;\n","/**\n * Simple parser for a subset of HTML.\n *\n * This is an internal function intended to be used by I18nInlineMarkup.\n */\n\nexport type Tag = {\n    type: \"tag\";\n    tag: string;\n    children: string | null;\n};\n\nexport type Text = {\n    type: \"text\";\n    text: string;\n};\n\nexport type SimpleHtmlNode = Tag | Text;\n\nexport function parseSimpleHTML(html: string): ReadonlyArray<SimpleHtmlNode> {\n    // This is a regex that can capture the following kinds of things:\n    //  - self-closing tags: (e.g., <myimg />)\n    //  - non self-closing tags. This regex captures an opening tag, and the\n    //    next tag (regardless of whether it is opening, closing, or\n    //    self-closing). We make sure, later in this function, that the second\n    //    tag is a closing tag of the same type as the opening tag.\n    //  - text (i.e., parts of the string that aren't tags).\n    //\n    // NOTE: Don't move simpleHtmlRegex out of this function. Regexes are\n    // stateful when used with `exec`, so we need to recreate it every time\n    // parseSimpleHTML is called.\n    //\n    // TODO(joshuan): This would be a great opportunity for named captures.\n    // If those are ever implemented in browsers we care about, this should\n    // be rewritten to use them.\n    const simpleHtmlRegex =\n        /(<([^>^/]+)\\s*\\/>)|(<([^>]+)>([^<]*)<(\\/?)([^>]+)>)|([^<]+)/gm;\n    // simpleHtmlRegex has numbered captures. The following are names for those\n    // captures. If you ever need to modify the above regex and need to\n    // figure out what the new capture numbers are, https://regex101.com\n    // must be helpful.\n    const SELF_CLOSE_NAME = 2;\n    const OPEN_NAME = 4;\n    const CHILDREN = 5;\n    const CLOSING_SLASH = 6;\n    const CLOSING_NAME = 7;\n    const TEXT = 8;\n\n    html = html.trim();\n\n    const result = [];\n\n    let match;\n    while ((match = simpleHtmlRegex.exec(html))) {\n        if (match[SELF_CLOSE_NAME] != null) {\n            const tag = match[SELF_CLOSE_NAME].trim();\n            if (tag.includes(\" \")) {\n                throw new Error(\n                    \"I18nInlineMarkup: expected a tag without \" +\n                        \"attributes, but received: \" +\n                        `<${tag}/>`,\n                );\n            }\n            result.push({\n                type: \"tag\",\n                tag,\n                children: null,\n            });\n        } else if (match[OPEN_NAME] != null) {\n            const tag = match[OPEN_NAME].trim();\n            if (tag.includes(\" \")) {\n                throw new Error(\n                    \"I18nInlineMarkup: expected a tag without \" +\n                        \"attributes, but received: \" +\n                        `<${match[OPEN_NAME]}>`,\n                );\n            }\n\n            if (match[CLOSING_SLASH] !== \"/\") {\n                throw new Error(\n                    `I18nInlineMarkup: nested tags are not ` +\n                        `supported, but <${match[CLOSING_NAME]}> is nested underneath ` +\n                        `<${tag}>.`,\n                );\n            }\n\n            const closingTag = match[CLOSING_NAME].trim();\n            if (tag !== closingTag) {\n                throw new Error(\n                    `I18nInlineMarkup: expected closing tag ` +\n                        `</${match[4]}>, but got </${match[7]}>`,\n                );\n            }\n            result.push({\n                type: \"tag\",\n                tag,\n                children: match[CHILDREN],\n            });\n        } else if (match[TEXT] != null) {\n            result.push({\n                type: \"text\",\n                text: match[TEXT],\n            });\n        } else {\n            throw new Error(\n                \"I18nInlineMarkup: unknown error (maybe you have an extra '<')?\",\n            );\n        }\n    }\n\n    if (\n        result.length === 1 &&\n        // A tag is allowed to wrap all NL text in the html.\n        (result[0].type === \"text\" || !result[0].children)\n    ) {\n        // eslint-disable-next-line no-console\n        console.warn(\"Unnecessary use of I18nInlineMarkup.\");\n    }\n    // @ts-expect-error [FEI-5019] - TS2322 - Type '({ type: string; tag: string; children: null; } | { type: string; tag: string; children: string; } | { type: string; text: string; })[]' is not assignable to type 'readonly SimpleHtmlNode[]'.\n    return result;\n}\n","/**\n * Render some HTML, using functions passed in as props to render tags.\n *\n * ADR: https://docs.google.com/document/d/15EP6E_nxrEhgb9jlR3v7S93S22E3KAH_XMqN2gBqyUQ/edit\n *\n * Why?\n * ====\n *\n * Sometimes strings that you want to translate have links, words that are\n * bolded, etc.\n *\n * Historically, developers have chopped up these strings into bits without\n * HTML and stitched them back together manually. This occasionally worked.\n * Other times, a bug prevented the strings from being translated. When they\n * were translatable, sometimes we'd get translations with mismatched verb\n * tenses or other grammatical errors. Developers sometimes gave up and\n * resorted to using dangerouslySetInnerHTML, which isn't great either -- it\n * gives volunteers the ability to add XSS and it doesn't allow us to use our\n * fancy client-side links.\n *\n * With <I18nInlineMarkup>, things are better. You pass in a full translated\n * string, with HTML tags. For every kind of tag in the child string, you also\n * pass in a function which, given children, renders that kind of tag.\n *\n * For example, here's one way you could use <I18nInlineMarkup> to render a\n * disclaimer about our terms and conditions and privacy policy.\n *\n * ```\n * <I18nInlineMarkup\n *     link1={node => <a href=\"/terms\">{node}</a>}\n *     link2={node => <a href=\"/privacy\">{node}</a>}\n *     link3={node => <a href=\"/gdpr\">{node}</a>}\n * >\n *     {i18n._(\n          \"By existing, you agree to our <link1>terms and conditions</link1>\" +\n              \"and <link2>privacy policy</link2>. If you are a resident \" +\n              \"of the European Union, you have <link3>options</link3>.\",\n *     )}\n * </I18nInlineMarkup>\n * ```\n *\n * Use\n * ===\n *\n * <I18nInlineMarkup> accepts a single HTML-like string as children. This\n * string must not have any HTML attributes or nested tags. You must pass in\n * a render prop for every kind of tag in this string.\n *\n * Any numeric or named HTML codes will be escaped. That is, if children\n * contains `&mdash;` or `&#8212`, the text `&mdash;` or `&#8212;` will\n * show up to the end user. Use unicode escape sequences (e.g., \\u2014)\n * instead.\n *\n * Here's a trivial use of I18nInlineMarkup:\n *\n * ```\n * <I18nInlineMarkup b={node => <b>{node}</b>}>\n *   {i18n._(\"Some <b>markup</b>\")}\n * </I18nInlineMarkup>\n * ```\n *\n * Note that `b` doesn't need to actually return a `<b>` tag. It could, for\n * example, return a Wonder Blocks Label instead.\n *\n * You can the same kind of tag multiple times:\n *\n * ```\n * <I18nInlineMarkup b={node => <b>{node}</b>}>\n *   {i18n._(\"Some <b>markup</b> that I <b>wrote</b>\")}\n * </I18nInlineMarkup>\n * ```\n *\n * Since attributes aren't supported, if you want to support different props\n * on the same kind of component, use multiple tag names. See the first\n * example in this comment.\n */\n\nimport * as React from \"react\";\n\nimport {parseSimpleHTML} from \"./parse-simple-html\";\nimport type {SimpleHtmlNode} from \"./parse-simple-html\";\n\ntype Props = {\n    // TODO(FEI-5019): This should be `[tag: string]: (content: string) => React.ReactElement`\n    // but TypeScript requires that the type of string indexers be compatible with all other\n    // properties in the type/interface.\n    [tag: string]: any;\n\n    /**\n     * A translated string.\n     *\n     * TODO(joshuan): if we ever add a type for translated strings, replace\n     * \"string\" with that type.\n     */\n    children: string;\n    /**\n     * A function which takes each top-level text or rendered tag,\n     * and returns an element that wraps it.\n     *\n     * `type` is \"text\" if the element is text, and a pseudotag, like\n     * \"newline\", or \"cirlced-box\" otherwise.\n     *\n     * We use this on the LOHP and marketing pages to provide a\n     * background around text when they are on top of an illustration.\n     *\n     * i is the index of the text or tag.\n     */\n    elementWrapper?: (\n        elem: React.ReactNode,\n        type: string,\n        i: number,\n    ) => React.ReactNode;\n    onError?: (e: Error) => React.ReactNode;\n};\n\nexport class I18nInlineMarkup extends React.PureComponent<Props> {\n    /**\n     * If an error occurs, we either call the onError prop, or throw the\n     * error.\n     */\n    handleError(error: Error): React.ReactNode {\n        const {onError} = this.props;\n\n        if (onError) {\n            return onError(error);\n        }\n\n        throw error;\n    }\n\n    render(): React.ReactNode {\n        const {children, elementWrapper, ...restProps} = this.props;\n        const renderers: Record<\n            string,\n            (content: string) => React.ReactElement\n        > = restProps;\n        let tree: ReadonlyArray<SimpleHtmlNode>;\n        try {\n            tree = parseSimpleHTML(children);\n        } catch (e: any) {\n            return this.handleError(e);\n        }\n        const nodes: Array<React.ReactNode> = tree.map((node, i) => {\n            if (node.type === \"text\") {\n                if (elementWrapper) {\n                    return (\n                        <React.Fragment key={i}>\n                            {elementWrapper(node.text, \"text\", i)}\n                        </React.Fragment>\n                    );\n                }\n                return node.text;\n            }\n            if (node.type === \"tag\") {\n                const renderer = renderers[node.tag];\n                if (!renderer) {\n                    return this.handleError(\n                        new Error(\n                            `I18nInlineMarkup: missing render prop for ${node.tag}`,\n                        ),\n                    );\n                }\n                if (elementWrapper) {\n                    return (\n                        <React.Fragment key={i}>\n                            {elementWrapper(\n                                /**\n                                 * TODO(somewhatabstract, JIRA-XXXX):\n                                 * node.children can be null but renderer does\n                                 * not accept null.\n                                 */\n                                // @ts-expect-error [FEI-5019] - TS2345 - Argument of type 'string | null' is not assignable to parameter of type 'string'.\n                                renderer(node.children),\n                                node.tag,\n                                i,\n                            )}\n                        </React.Fragment>\n                    );\n                }\n                return (\n                    <React.Fragment key={i}>\n                        {\n                            /**\n                             * TODO(somewhatabstract, JIRA-XXXX):\n                             * node.children can be null but renderer does\n                             * not accept null.\n                             */\n                            // @ts-expect-error [FEI-5019] - TS2345 - Argument of type 'string | null' is not assignable to parameter of type 'string'.\n                            renderer(node.children)\n                        }\n                    </React.Fragment>\n                );\n            }\n\n            // istanbul ignore\n            return this.handleError(new Error(\"Unknown child type.\"));\n        });\n        return nodes;\n    }\n}\n"],"names":["ACCENT_MAP","SubstitutionRegex","Accents","scaleFactor","input","countMap","updateCount","char","count","substring","possibles","BoxChar","AlphaNumRegex","Boxes","__locale","getLocale","Translators","FakeTranslate","urlRegex","pythonSubstRegex","tokenSearchRegex","safeTranslate","str","subsegments","lastMatchEndIndex","match","html","htmlString","template","processChildNodes","parent","node","newText","newTextNode","tempNode","fakeTranslate","interpolationMarker","internalTranslate","strOrPluralConfig","options","additionalTranslation","translated","key","replaceWith","parseSimpleHTML","simpleHtmlRegex","result","tag","closingTag","I18nInlineMarkup","React.PureComponent","error","onError","children","elementWrapper","restProps","renderers","tree","e","i","jsx","React.Fragment","renderer"],"mappings":"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"}