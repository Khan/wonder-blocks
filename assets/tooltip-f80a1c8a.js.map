{"version":3,"file":"tooltip-f80a1c8a.js","sources":["../../packages/wonder-blocks-tooltip/src/util/active-tracker.ts","../../packages/wonder-blocks-tooltip/src/util/constants.ts","../../packages/wonder-blocks-tooltip/src/components/tooltip-anchor.tsx","../../packages/wonder-blocks-tooltip/src/components/tooltip-tail.tsx","../../packages/wonder-blocks-tooltip/src/components/tooltip-bubble.tsx","../../packages/wonder-blocks-tooltip/src/components/tooltip-content.tsx","../../packages/wonder-blocks-tooltip/src/util/ref-tracker.ts","../../packages/wonder-blocks-tooltip/src/components/tooltip-popper.tsx","../../packages/wonder-blocks-tooltip/src/components/tooltip.tsx"],"sourcesContent":["/**\n * This interface should be implemented by types that are interested in the\n * notifications of active state being stolen. Generally, this would also be\n * subscribers that may also steal active state, but not necessarily.\n *\n * Once implemented, the type must call subscribe on a tracker to begin\n * receiving notifications.\n */\nexport interface IActiveTrackerSubscriber {\n    /**\n     * Notification raised when something steals the active state from a\n     * subscribed tracker.\n     */\n    activeStateStolen: () => void;\n}\n\n/**\n * This class is used to track the concept of active state (though technically\n * that could be any boolean state). The tracker has a variety of subscribers\n * that receive notifications of state theft and can steal the state.\n *\n * For the tooltip, this enables us to have a single tooltip active at any one\n * time. The tracker allows tooltip anchors to coordinate which of them is\n * active, and to ensure that if a different one becomes active, all the others\n * know that they aren't.\n *\n * - When notified that the state has been stolen, subscribers can immediately\n * reflect that theft (in the case of a tooltip, they would hide themselves).\n * - The thief does not get notified if they were the one who stole the state\n * since they should already know that they did that (this avoids having to have\n * checks for reentrancy, for example).\n * - When the subscriber that owns the state no longer needs it, it can\n * voluntarily give it up.\n * - If the state is stolen while a subscriber owns the\n * state, that subscriber does not give up the state, as it doesn't have it\n * anymore (it was stolen).\n */\nexport default class ActiveTracker {\n    _subscribers: Array<IActiveTrackerSubscriber> = [];\n    // @ts-expect-error [FEI-5019] - TS2564 - Property '_active' has no initializer and is not definitely assigned in the constructor.\n    _active: boolean;\n\n    _getIndex(who: IActiveTrackerSubscriber): number {\n        return this._subscribers.findIndex((v) => v === who);\n    }\n\n    /**\n     * Called when a tooltip anchor becomes active so that it can tell all other\n     * anchors that they are no longer the active tooltip. Returns true if\n     * the there was a steal of active state from another anchor; otherwise, if\n     * no other anchor had been active, returns false.\n     */\n    steal(who: IActiveTrackerSubscriber): boolean {\n        const wasActive = !!this._active;\n        this._active = true;\n        for (const anchor of this._subscribers) {\n            if (anchor === who) {\n                // We don't need to notify the thief.\n                continue;\n            }\n            anchor.activeStateStolen();\n        }\n        return wasActive;\n    }\n\n    /**\n     * Called if a tooltip doesn't want to be active anymore.\n     * Should not be called when being told the active spot was stolen by\n     * another anchor, only when the anchor is unhovered and unfocused and they\n     * were active.\n     */\n    giveup() {\n        this._active = false;\n    }\n\n    /**\n     * Subscribes a tooltip anchor to the tracker so that it can be notified of\n     * steals. Returns a method that can be used to unsubscribe the anchor from\n     * notifications.\n     */\n    subscribe(who: IActiveTrackerSubscriber): () => void {\n        if (this._getIndex(who) >= 0) {\n            throw new Error(\"Already subscribed.\");\n        }\n        this._subscribers.push(who);\n\n        const unsubscribe = () => {\n            const index = this._getIndex(who);\n            this._subscribers.splice(index, 1);\n        };\n        return unsubscribe;\n    }\n}\n","/**\n * The attribute used to identify a tooltip portal.\n */\nexport const TooltipPortalAttributeName = \"data-tooltip-portal\";\nexport const TooltipAppearanceDelay = 100;\nexport const TooltipDisappearanceDelay = 75;\n","/**\n * This component turns the given content into an accessible anchor for\n * positioning and displaying tooltips.\n */\nimport * as React from \"react\";\nimport * as ReactDOM from \"react-dom\";\n\nimport {Text as WBText} from \"@khanacademy/wonder-blocks-core\";\nimport type {IIdentifierFactory} from \"@khanacademy/wonder-blocks-core\";\n\nimport ActiveTracker from \"../util/active-tracker\";\nimport {\n    TooltipAppearanceDelay,\n    TooltipDisappearanceDelay,\n} from \"../util/constants\";\n\nimport type {IActiveTrackerSubscriber} from \"../util/active-tracker\";\n\ntype Props = {\n    /**\n     * The content for anchoring the tooltip.\n     * This element will be used to position the tooltip.\n     * If a string is passed as children we wrap it in a Text element.\n     * We allow children to be a string so that we can add tooltips to\n     * words within a large block of text easily.\n     */\n    children: React.ReactElement<any> | string;\n    /**\n     * Callback to be invoked when the anchored content is mounted.\n     * This provides a reference to the anchored content, which can then be\n     * used for calculating tooltip bubble positioning.\n     */\n    anchorRef: (arg1?: Element | null | undefined) => unknown;\n    /**\n     * When true, if a tabindex attribute is not already present on the element\n     * wrapped by the anchor, the element will be given tabindex=0 to make it\n     * keyboard focusable; otherwise, does not attempt to change the ability to\n     * focus the anchor element.\n     *\n     * Defaults to true.\n     *\n     * One might set this to false in circumstances where the wrapped component\n     * already can receive focus or contains an element that can.\n     * Use good judgement when overriding this value, the tooltip content should\n     * be accessible via keyboard in all circumstances where the tooltip would\n     * appear using the mouse, so verify those use-cases.\n     */\n    forceAnchorFocusivity?: boolean;\n    /**\n     * Callback to pass active state back to Tooltip.\n     *\n     * `active` will be true whenever the anchor is hovered or focused and false\n     * otherwise.\n     */\n    onActiveChanged: (active: boolean) => unknown;\n    /**\n     * Optional unique id factory.\n     */\n    ids?: IIdentifierFactory;\n};\n\ntype DefaultProps = {\n    forceAnchorFocusivity: Props[\"forceAnchorFocusivity\"];\n};\n\ntype State = {\n    /** Is the anchor active or not? */\n    active: boolean;\n};\n\nconst TRACKER = new ActiveTracker();\n\nexport default class TooltipAnchor\n    extends React.Component<Props, State>\n    implements IActiveTrackerSubscriber\n{\n    _weSetFocusivity: boolean | null | undefined;\n    _anchorNode: Element | null | undefined;\n    _focused: boolean;\n    _hovered: boolean;\n    // @ts-expect-error [FEI-5019] - TS2564 - Property '_stolenFromUs' has no initializer and is not definitely assigned in the constructor.\n    _stolenFromUs: boolean;\n    // @ts-expect-error [FEI-5019] - TS2564 - Property '_unsubscribeFromTracker' has no initializer and is not definitely assigned in the constructor.\n    _unsubscribeFromTracker: () => void | null | undefined;\n    _timeoutID: number | null | undefined;\n\n    static defaultProps: DefaultProps = {\n        forceAnchorFocusivity: true,\n    };\n\n    constructor(props: Props) {\n        super(props);\n\n        this._focused = false;\n        this._hovered = false;\n        this.state = {\n            active: false,\n        };\n    }\n\n    componentDidMount() {\n        const anchorNode = ReactDOM.findDOMNode(this);\n\n        // This should never happen, but we have this check here to make TypeScript\n        // happy and ensure that if this does happen, we'll know about it.\n        if (anchorNode instanceof Text) {\n            throw new Error(\n                \"TooltipAnchor must be applied to an Element. Text content is not supported.\",\n            );\n        }\n\n        this._unsubscribeFromTracker = TRACKER.subscribe(this);\n        this._anchorNode = anchorNode;\n        this._updateFocusivity();\n        if (anchorNode) {\n            /**\n             * TODO(somewhatabstract): Work out how to allow pointer to go over\n             * the tooltip content to keep it active. This likely requires\n             * pointer events but that would break the obscurement checks we do.\n             * So, careful consideration required. See WB-302.\n             */\n            anchorNode.addEventListener(\"focusin\", this._handleFocusIn);\n            anchorNode.addEventListener(\"focusout\", this._handleFocusOut);\n            anchorNode.addEventListener(\"mouseenter\", this._handleMouseEnter);\n            anchorNode.addEventListener(\"mouseleave\", this._handleMouseLeave);\n\n            this.props.anchorRef(this._anchorNode);\n        }\n    }\n\n    componentDidUpdate(prevProps: Props) {\n        if (\n            prevProps.forceAnchorFocusivity !==\n                this.props.forceAnchorFocusivity ||\n            prevProps.children !== this.props.children\n        ) {\n            this._updateFocusivity();\n        }\n    }\n\n    componentWillUnmount() {\n        if (this._unsubscribeFromTracker) {\n            this._unsubscribeFromTracker();\n        }\n        this._clearPendingAction();\n\n        const anchorNode = this._anchorNode;\n        if (anchorNode) {\n            anchorNode.removeEventListener(\"focusin\", this._handleFocusIn);\n            anchorNode.removeEventListener(\"focusout\", this._handleFocusOut);\n            anchorNode.removeEventListener(\n                \"mouseenter\",\n                this._handleMouseEnter,\n            );\n            anchorNode.removeEventListener(\n                \"mouseleave\",\n                this._handleMouseLeave,\n            );\n        }\n        if (this.state.active) {\n            document.removeEventListener(\"keyup\", this._handleKeyUp);\n        }\n    }\n\n    static ariaContentId = \"aria-content\";\n\n    activeStateStolen: () => void = () => {\n        // Something wants the active state.\n        // Do we have it? If so, let's remember that.\n        // If we are already active, or we're inactive but have a timeoutID,\n        // then it was stolen from us.\n        this._stolenFromUs = this.state.active || !!this._timeoutID;\n        // Let's first tell ourselves we're not focused (otherwise the tooltip\n        // will be sticky on the next hover of this anchor and that just looks\n        // weird).\n        this._focused = false;\n        // Now update our actual state.\n        this._setActiveState(false, true);\n    };\n\n    _updateFocusivity() {\n        const anchorNode = this._anchorNode;\n        if (!anchorNode) {\n            return;\n        }\n        const {forceAnchorFocusivity} = this.props;\n        const currentTabIndex = anchorNode.getAttribute(\"tabindex\");\n\n        if (forceAnchorFocusivity && !currentTabIndex) {\n            // Ensure that the anchor point is keyboard focusable so that\n            // we can show the tooltip for visually impaired users that don't\n            // use pointer devices nor assistive technology like screen readers.\n            anchorNode.setAttribute(\"tabindex\", \"0\");\n            this._weSetFocusivity = true;\n        } else if (!forceAnchorFocusivity && currentTabIndex) {\n            // We may not be forcing it, but we also want to ensure that if we\n            // did before, we remove it.\n            if (this._weSetFocusivity) {\n                anchorNode.removeAttribute(\"tabindex\");\n                this._weSetFocusivity = false;\n            }\n        }\n    }\n\n    _updateActiveState(hovered: boolean, focused: boolean) {\n        // Update our stored values.\n        this._hovered = hovered;\n        this._focused = focused;\n\n        this._setActiveState(hovered || focused);\n    }\n\n    _clearPendingAction() {\n        if (this._timeoutID) {\n            clearTimeout(this._timeoutID);\n            this._timeoutID = null;\n        }\n    }\n\n    _setActiveState(active: boolean, instant?: boolean) {\n        if (\n            this._stolenFromUs ||\n            active !== this.state.active ||\n            (!this.state.active && this._timeoutID)\n        ) {\n            // If we are about to lose active state or change it, we need to\n            // cancel any pending action to show ourselves.\n            // So, if active is stolen from us, we are changing active state,\n            // or we are inactive and have a timer, clear the action.\n            this._clearPendingAction();\n        } else if (active === this.state.active && !this._timeoutID) {\n            // Nothing to do if we're already active.\n            return;\n        }\n\n        // Determine if we are doing things immediately or not.\n        instant = instant || (active && TRACKER.steal(this));\n\n        if (instant) {\n            if (active) {\n                document.addEventListener(\"keyup\", this._handleKeyUp);\n            } else {\n                document.removeEventListener(\"keyup\", this._handleKeyUp);\n            }\n            this.setState({active});\n            this.props.onActiveChanged(active);\n            if (!this._stolenFromUs && !active) {\n                // Only the very last thing going inactive will giveup\n                // the stolen active state.\n                TRACKER.giveup();\n            }\n            this._stolenFromUs = false;\n        } else {\n            const delay = active\n                ? TooltipAppearanceDelay\n                : TooltipDisappearanceDelay;\n            // @ts-expect-error [FEI-5019] - TS2322 - Type 'Timeout' is not assignable to type 'number'.\n            this._timeoutID = setTimeout(() => {\n                this._timeoutID = null;\n                this._setActiveState(active, true);\n            }, delay);\n        }\n    }\n\n    _handleFocusIn: () => void = () => {\n        this._updateActiveState(this._hovered, true);\n    };\n\n    _handleFocusOut: () => void = () => {\n        this._updateActiveState(this._hovered, false);\n    };\n\n    _handleMouseEnter: () => void = () => {\n        this._updateActiveState(true, this._focused);\n    };\n\n    _handleMouseLeave: () => void = () => {\n        this._updateActiveState(false, this._focused);\n    };\n\n    _handleKeyUp: (e: KeyboardEvent) => void = (e) => {\n        // We check the key as that's keyboard layout agnostic and also avoids\n        // the minefield of deprecated number type properties like keyCode and\n        // which, with the replacement code, which uses a string instead.\n        if (e.key === \"Escape\" && this.state.active) {\n            // Stop the event going any further.\n            // For cancellation events, like the Escape key, we generally should\n            // air on the side of caution and only allow it to cancel one thing.\n            // So, it's polite for us to stop propagation of the event.\n            // Otherwise, we end up with UX where one Escape key press\n            // unexpectedly cancels multiple things.\n            //\n            // For example, using Escape to close a tooltip or a dropdown while\n            // displaying a modal and having the modal close as well. This would\n            // be annoyingly bad UX.\n            e.preventDefault();\n            e.stopPropagation();\n            this._updateActiveState(false, false);\n        }\n    };\n\n    _renderAnchorableChildren(): React.ReactElement<any> {\n        const {children} = this.props;\n        return typeof children === \"string\" ? (\n            <WBText>{children}</WBText>\n        ) : (\n            children\n        );\n    }\n\n    _renderAccessibleChildren(ids: IIdentifierFactory): React.ReactNode {\n        const anchorableChildren = this._renderAnchorableChildren();\n\n        return React.cloneElement(anchorableChildren, {\n            \"aria-describedby\": ids.get(TooltipAnchor.ariaContentId),\n        });\n    }\n\n    render(): React.ReactNode {\n        // We need to make sure we can anchor on our content.\n        // If the content is just a string, we wrap it in a Text element\n        // so as not to affect styling or layout but still have an element\n        // to anchor to.\n        if (this.props.ids) {\n            return this._renderAccessibleChildren(this.props.ids);\n        }\n        return this._renderAnchorableChildren();\n    }\n}\n","import * as React from \"react\";\nimport {css, StyleSheet} from \"aphrodite\";\n\nimport Colors from \"@khanacademy/wonder-blocks-color\";\nimport {View} from \"@khanacademy/wonder-blocks-core\";\nimport Spacing from \"@khanacademy/wonder-blocks-spacing\";\nimport {Strut} from \"@khanacademy/wonder-blocks-layout\";\n\nimport type {StyleType} from \"@khanacademy/wonder-blocks-core\";\nimport type {getRefFn, Placement, Offset} from \"../util/types\";\n\nexport type Props = {\n    /**\n     * Whether we should use the default white background color or switch to a\n     * different bg color.\n     *\n     * NOTE: Added to support custom popovers\n     * @ignore\n     */\n    color: keyof typeof Colors;\n    /** The offset of the tail indicating where it should be positioned. */\n    offset?: Offset;\n    /** The placement of the tail with respect to the tooltip anchor. */\n    placement: Placement;\n    /** A callback to update the ref of the tail element. */\n    updateRef?: getRefFn;\n    /** When true, the tail is shown; otherwise, it is not but it still takes\n     * space in the layout. */\n    show: boolean;\n};\n\ntype DefaultProps = {\n    color: Props[\"color\"];\n    show: Props[\"show\"];\n};\n\ntype Dimensions = {\n    trimlinePoints: [string, string];\n    points: [string, string, string];\n    height: number;\n    width: number;\n};\n\ntype FilterPosition = {\n    y: string;\n    x: string;\n    offsetShadowX: number;\n};\n\n// TODO(somewhatabstract): Replace this really basic unique ID work with\n// something SSR-friendly and more robust.\nlet tempIdCounter = 0;\n\nexport default class TooltipTail extends React.Component<Props> {\n    static defaultProps: DefaultProps = {\n        color: \"white\",\n        show: true,\n    };\n\n    _calculateDimensionsFromPlacement(): Dimensions {\n        const {placement} = this.props;\n\n        // The trimline, which we draw to make the tail flush to the bubble,\n        // has a thickness of 1. Since the line is drawn centered to the\n        // coordinates, we use an offset of 0.5 so that it properly covers what\n        // we want it to.\n        const trimlineOffset = 0.5;\n\n        // Calculate the three points of the arrow. Depending on the tail's\n        // direction (i.e., the tooltip's \"side\"), we choose different points,\n        // and set our SVG's bounds differently.\n        //\n        // Note that when the tail points to the left or right, the width/height\n        // are inverted.\n        switch (placement) {\n            case \"top\":\n                return {\n                    trimlinePoints: [\n                        `0,-${trimlineOffset}`,\n                        `${ARROW_WIDTH},-${trimlineOffset}`,\n                    ],\n                    points: [\n                        \"0,0\",\n                        `${ARROW_WIDTH / 2},${ARROW_HEIGHT}`,\n                        `${ARROW_WIDTH},0`,\n                    ],\n                    height: ARROW_HEIGHT,\n                    width: ARROW_WIDTH,\n                };\n\n            case \"right\":\n                return {\n                    trimlinePoints: [\n                        `${ARROW_HEIGHT + trimlineOffset},0`,\n                        `${ARROW_HEIGHT + trimlineOffset},${ARROW_WIDTH}`,\n                    ],\n                    points: [\n                        `${ARROW_HEIGHT},0`,\n                        `0,${ARROW_WIDTH / 2}`,\n                        `${ARROW_HEIGHT},${ARROW_WIDTH}`,\n                    ],\n                    width: ARROW_HEIGHT,\n                    height: ARROW_WIDTH,\n                };\n\n            case \"bottom\":\n                return {\n                    trimlinePoints: [\n                        `0, ${ARROW_HEIGHT + trimlineOffset}`,\n                        `${ARROW_WIDTH},${ARROW_HEIGHT + trimlineOffset}`,\n                    ],\n                    points: [\n                        `0, ${ARROW_HEIGHT}`,\n                        `${ARROW_WIDTH / 2},0`,\n                        `${ARROW_WIDTH},${ARROW_HEIGHT}`,\n                    ],\n                    width: ARROW_WIDTH,\n                    height: ARROW_HEIGHT,\n                };\n\n            case \"left\":\n                return {\n                    trimlinePoints: [\n                        `-${trimlineOffset},0`,\n                        `-${trimlineOffset},${ARROW_WIDTH}`,\n                    ],\n                    points: [\n                        `0,0`,\n                        `${ARROW_HEIGHT},${ARROW_WIDTH / 2}`,\n                        `0,${ARROW_WIDTH}`,\n                    ],\n                    width: ARROW_HEIGHT,\n                    height: ARROW_WIDTH,\n                };\n\n            default:\n                throw new Error(`Unknown placement: ${placement}`);\n        }\n    }\n\n    _getFilterPositioning(): FilterPosition | null | undefined {\n        const {placement} = this.props;\n        switch (placement) {\n            case \"top\":\n                return {\n                    y: \"-50%\",\n                    x: \"-50%\",\n                    offsetShadowX: 0,\n                };\n\n            case \"bottom\":\n                // No shadow on the arrow as it falls \"under\" the bubble.\n                return null;\n\n            case \"left\":\n                return {\n                    y: \"-50%\",\n                    x: \"0%\",\n                    offsetShadowX: 1,\n                };\n\n            case \"right\":\n                return {\n                    y: \"-50%\",\n                    x: \"-100%\",\n                    offsetShadowX: -1,\n                };\n\n            default:\n                throw new Error(`Unknown placement: ${placement}`);\n        }\n    }\n\n    /**\n     * Create an SVG filter that applies a blur to an element.\n     * We'll apply it to a dark shape outlining the tooltip, which\n     * will produce the overall effect of a drop-shadow.\n     *\n     * Also, scope its ID by side, so that tooltips with other\n     * \"side\" values don't end up using the wrong filter from\n     * elsewhere in the document. (The `height` value depends on\n     * which way the arrow is turned!)\n     */\n    _maybeRenderDropshadow(points: [string, string, string]): React.ReactNode {\n        const position = this._getFilterPositioning();\n        if (!position) {\n            return null;\n        }\n        const {placement} = this.props;\n        const {y, x, offsetShadowX} = position;\n        const dropShadowFilterId = `tooltip-dropshadow-${placement}-${tempIdCounter++}`;\n        return [\n            <filter\n                key=\"filter\"\n                id={dropShadowFilterId}\n                // Height and width tell the filter how big of a canvas to\n                // draw based on its parent size. i.e. 2 times bigger.\n                // This is so that the diffuse gaussian blur has space to\n                // bleed into.\n                width=\"200%\"\n                height=\"200%\"\n                // The x and y values tell the filter where, relative to its\n                // parent, it should begin showing its canvas. Without these\n                // the filter would clip at 0,0, which would look really\n                // strange.\n                x={x}\n                y={y}\n            >\n                {/* Here we provide a nice blur that will be our shadow\n                 * The stdDeviation is the spread of the blur. We don't want it\n                 * too diffuse.\n                 */}\n                <feGaussianBlur\n                    in=\"SourceAlpha\"\n                    stdDeviation={Spacing.xxSmall_6 / 2}\n                />\n\n                {/* Here we adjust the alpha (feFuncA) linearly so as to blend\n                 * the shadow to match the rest of the tooltip bubble shadow.\n                 * It is a combination of the diffuse blur and this alpha\n                 * value that will make it look right.\n                 *\n                 * The value of 0.3. was arrived at from trial and error.\n                 */}\n                <feComponentTransfer>\n                    <feFuncA type=\"linear\" slope=\"0.3\" />\n                </feComponentTransfer>\n            </filter>,\n            /**\n             * Draw the tooltip arrow and apply the blur filter we created\n             * above, to produce a drop shadow effect.\n             * We move it down a bit with a translation, so that it is what\n             * we want.\n             *\n             * We offset the shadow on the X-axis because for left/right\n             * tails, we move the tail 1px toward the bubble. If we didn't\n             * offset the shadow, it would crash the bubble outline.\n             *\n             * See styles below for why we offset the arrow.\n             */\n            <g key=\"dropshadow\" transform={`translate(${offsetShadowX},5.5)`}>\n                <polyline\n                    fill={Colors.offBlack16}\n                    points={points.join(\" \")}\n                    stroke={Colors.offBlack32}\n                    filter={`url(#${dropShadowFilterId})`}\n                />\n            </g>,\n        ];\n    }\n\n    _getFullTailWidth(): number {\n        return ARROW_WIDTH + 2 * MIN_DISTANCE_FROM_CORNERS;\n    }\n\n    _getFullTailHeight(): number {\n        return ARROW_HEIGHT + DISTANCE_FROM_ANCHOR;\n    }\n\n    _getContainerStyle(): StyleType {\n        const {placement} = this.props;\n        /**\n         * Ensure the container is sized properly for us to be placed correctly\n         * by the Popper.js code.\n         *\n         * Here we offset the arrow 1px toward the bubble. This ensures the arrow\n         * outline meets the bubble outline and allows the arrow to erase the bubble\n         * outline between the ends of the arrow outline. We do this so that the\n         * arrow outline and bubble outline create a single, seamless outline of\n         * the callout.\n         *\n         * NOTE: The widths and heights refer to the downward-pointing tail\n         * (i.e. placement=\"top\"). When the tail points to the left or right\n         * instead, the width/height are inverted.\n         */\n        const fullTailWidth = this._getFullTailWidth();\n        const fullTailHeight = this._getFullTailHeight();\n\n        switch (placement) {\n            case \"top\":\n                return {\n                    top: -1,\n                    width: fullTailWidth,\n                    height: fullTailHeight,\n                };\n\n            case \"right\":\n                return {\n                    left: 1,\n                    width: fullTailHeight,\n                    height: fullTailWidth,\n                };\n\n            case \"bottom\":\n                return {\n                    top: 1,\n                    width: fullTailWidth,\n                    height: fullTailHeight,\n                };\n\n            case \"left\":\n                return {\n                    left: -1,\n                    width: fullTailHeight,\n                    height: fullTailWidth,\n                };\n\n            default:\n                throw new Error(`Unknown placement: ${placement}`);\n        }\n    }\n\n    _getArrowStyle(): React.CSSProperties {\n        const {placement} = this.props;\n        switch (placement) {\n            case \"top\":\n                return {\n                    marginLeft: MIN_DISTANCE_FROM_CORNERS,\n                    marginRight: MIN_DISTANCE_FROM_CORNERS,\n                    paddingBottom: DISTANCE_FROM_ANCHOR,\n                };\n\n            case \"right\":\n                return {\n                    marginTop: MIN_DISTANCE_FROM_CORNERS,\n                    marginBottom: MIN_DISTANCE_FROM_CORNERS,\n                    paddingLeft: DISTANCE_FROM_ANCHOR,\n                };\n\n            case \"bottom\":\n                return {\n                    marginLeft: MIN_DISTANCE_FROM_CORNERS,\n                    marginRight: MIN_DISTANCE_FROM_CORNERS,\n                    paddingTop: DISTANCE_FROM_ANCHOR,\n                };\n\n            case \"left\":\n                return {\n                    marginTop: MIN_DISTANCE_FROM_CORNERS,\n                    marginBottom: MIN_DISTANCE_FROM_CORNERS,\n                    paddingRight: DISTANCE_FROM_ANCHOR,\n                };\n\n            default:\n                throw new Error(`Unknown placement: ${placement}`);\n        }\n    }\n\n    _renderArrow(): React.ReactNode {\n        const {trimlinePoints, points, height, width} =\n            this._calculateDimensionsFromPlacement();\n\n        const {color, show} = this.props;\n\n        if (!show) {\n            // If we aren't showing the tail, we still need to take up space\n            // so we render a strut instead.\n            return <Strut size={height} />;\n        }\n\n        return (\n            <svg\n                className={css(styles.arrow)}\n                style={this._getArrowStyle()}\n                width={width}\n                height={height}\n                aria-hidden\n            >\n                {this._maybeRenderDropshadow(points)}\n\n                {/**\n                 * Draw the actual background of the tooltip arrow.\n                 *\n                 * We draw the outline in white too so that when we draw the\n                 * outline, it draws over white and not the dropshadow behind.\n                 */}\n                <polyline\n                    fill={Colors[color]}\n                    stroke={Colors[color]}\n                    points={points.join(\" \")}\n                />\n\n                {/* Draw the tooltip outline around the tooltip arrow. */}\n                <polyline\n                    // Redraw the stroke on top of the background color,\n                    // so that the ends aren't extra dark where they meet\n                    // the border of the tooltip.\n                    fill={Colors[color]}\n                    points={points.join(\" \")}\n                    stroke={Colors.offBlack16}\n                />\n\n                {/* Draw a trimline to make the arrow appear flush */}\n                <polyline\n                    stroke={Colors[color]}\n                    points={trimlinePoints.join(\" \")}\n                />\n            </svg>\n        );\n    }\n\n    render(): React.ReactNode {\n        const {offset, placement, updateRef} = this.props;\n        return (\n            <View\n                style={[\n                    styles.tailContainer,\n                    {...offset},\n                    this._getContainerStyle(),\n                ]}\n                data-placement={placement}\n                ref={updateRef}\n            >\n                {this._renderArrow()}\n            </View>\n        );\n    }\n}\n\n/**\n * Some constants to make style generation easier to understand.\n * NOTE: The widths and heights refer to the downward-pointing tail\n * (i.e. placement=\"top\"). When the tail points to the left or right instead,\n * the width/height are inverted.\n */\nconst DISTANCE_FROM_ANCHOR = Spacing.xSmall_8;\n\nconst MIN_DISTANCE_FROM_CORNERS = Spacing.xSmall_8;\n\nconst ARROW_WIDTH = Spacing.large_24;\nconst ARROW_HEIGHT = Spacing.small_12;\n\nconst styles = StyleSheet.create({\n    /**\n     * Container\n     */\n    tailContainer: {\n        position: \"relative\",\n        pointerEvents: \"none\",\n    },\n\n    /**\n     * Arrow\n     */\n    arrow: {\n        // Ensure the dropshadow bleeds outside our bounds.\n        overflow: \"visible\",\n    },\n});\n","import {StyleSheet} from \"aphrodite\";\nimport * as React from \"react\";\nimport Colors from \"@khanacademy/wonder-blocks-color\";\nimport {View} from \"@khanacademy/wonder-blocks-core\";\nimport Spacing from \"@khanacademy/wonder-blocks-spacing\";\n\nimport type {StyleType} from \"@khanacademy/wonder-blocks-core\";\nimport TooltipContent from \"./tooltip-content\";\nimport TooltipTail from \"./tooltip-tail\";\n\nimport type {getRefFn, Offset, Placement} from \"../util/types\";\n\nexport type PopperElementProps = {\n    /** The placement of the bubble with respect to the anchor. */\n    placement: Placement;\n    /** Whether the bubble is out of bounds or not. */\n    isReferenceHidden?: boolean | null | undefined;\n    /** A callback for updating the ref of the bubble itself. */\n    updateBubbleRef?: getRefFn;\n    /** A callback for updating the ref of the bubble's tail. */\n    updateTailRef?: getRefFn;\n    /** Where the tail is to be rendered. */\n    tailOffset?: Offset;\n    /** Additional styles to be applied by the bubble. */\n    style?: StyleType;\n};\n\nexport type Props = {\n    /** The unique identifier for this component. */\n    id: string;\n    /** The `TooltipContent` element that will be rendered in the bubble. */\n    children: React.ReactElement<React.ComponentProps<typeof TooltipContent>>;\n    onActiveChanged: (active: boolean) => unknown;\n} & PopperElementProps; // (v3 beta introduces this) // TODO(somewhatabstract): Update react-docgen to support spread operators\n\ntype State = {\n    active: boolean;\n};\n\nexport default class TooltipBubble extends React.Component<Props, State> {\n    state: State = {\n        active: false,\n    };\n\n    _setActiveState(active: boolean) {\n        this.setState({active});\n        this.props.onActiveChanged(active);\n    }\n\n    handleMouseEnter: () => void = () => {\n        this._setActiveState(true);\n    };\n\n    handleMouseLeave: () => void = () => {\n        this.props.onActiveChanged(false);\n    };\n\n    render(): React.ReactNode {\n        const {\n            id,\n            children,\n            updateBubbleRef,\n            placement,\n            isReferenceHidden,\n            style,\n            updateTailRef,\n            tailOffset,\n        } = this.props;\n\n        return (\n            <View\n                id={id}\n                role=\"tooltip\"\n                data-placement={placement}\n                onMouseEnter={this.handleMouseEnter}\n                onMouseLeave={this.handleMouseLeave}\n                ref={updateBubbleRef}\n                style={[\n                    isReferenceHidden && styles.hide,\n                    styles.bubble,\n                    styles[`content-${placement}`],\n                    style,\n                ]}\n            >\n                <View style={styles.content}>{children}</View>\n                <TooltipTail\n                    updateRef={updateTailRef}\n                    placement={placement}\n                    offset={tailOffset}\n                />\n            </View>\n        );\n    }\n}\n\nconst styles = StyleSheet.create({\n    bubble: {\n        position: \"absolute\",\n    },\n\n    /**\n     * The hide style ensures that the bounds of the bubble stay unchanged.\n     * This is because popper.js calculates the bubble position based off its\n     * bounds and if we stopped rendering it entirely, it wouldn't know where to\n     * place it when it reappeared.\n     */\n    hide: {\n        pointerEvents: \"none\",\n        opacity: 0,\n        backgroundColor: \"transparent\",\n        color: \"transparent\",\n    },\n\n    /**\n     * Ensure the content and tail are properly arranged.\n     */\n    \"content-top\": {\n        flexDirection: \"column\",\n    },\n    \"content-right\": {\n        flexDirection: \"row-reverse\",\n    },\n    \"content-bottom\": {\n        flexDirection: \"column-reverse\",\n    },\n    \"content-left\": {\n        flexDirection: \"row\",\n    },\n\n    content: {\n        maxWidth: 472,\n        borderRadius: Spacing.xxxSmall_4,\n        border: `solid 1px ${Colors.offBlack16}`,\n        backgroundColor: Colors.white,\n        boxShadow: `0 ${Spacing.xSmall_8}px ${Spacing.xSmall_8}px 0 ${Colors.offBlack8}`,\n        justifyContent: \"center\",\n    },\n});\n","import * as React from \"react\";\nimport {StyleSheet} from \"aphrodite\";\n\nimport {View} from \"@khanacademy/wonder-blocks-core\";\nimport {Strut} from \"@khanacademy/wonder-blocks-layout\";\nimport Spacing from \"@khanacademy/wonder-blocks-spacing\";\nimport {HeadingSmall, LabelMedium} from \"@khanacademy/wonder-blocks-typography\";\n\nimport type {Typography} from \"@khanacademy/wonder-blocks-typography\";\n\ntype Props = {\n    /**\n     * The title for the tooltip content.\n     * Optional.\n     */\n    title?: string | React.ReactElement<React.ComponentProps<Typography>>;\n    /**\n     * The main content for a tooltip.\n     */\n    children:\n        | string\n        | React.ReactElement<React.ComponentProps<Typography>>\n        | Array<React.ReactElement<React.ComponentProps<Typography>>>;\n};\n\n/**\n * This component is used to provide the content that is to be rendered in the\n * tooltip bubble.\n *\n * ### Usage\n *\n * ```jsx\n * import {TooltipContent} from \"@khanacademy/wonder-blocks-tooltip\";\n *\n * <TooltipContent title=\"Title text!\">\n *  Some content in my tooltip.\n * </TooltipContent>\n * ```\n */\nexport default class TooltipContent extends React.Component<Props> {\n    _renderTitle(): React.ReactNode {\n        const {title} = this.props;\n        if (title) {\n            if (typeof title === \"string\") {\n                return <HeadingSmall>{title}</HeadingSmall>;\n            } else {\n                return title;\n            }\n        }\n        return null;\n    }\n\n    _renderChildren(): React.ReactNode {\n        const {children} = this.props;\n        if (typeof children === \"string\") {\n            return <LabelMedium>{children}</LabelMedium>;\n        } else {\n            return children;\n        }\n    }\n\n    render(): React.ReactNode {\n        const title = this._renderTitle();\n        const children = this._renderChildren();\n        const containerStyle = title ? styles.withTitle : styles.withoutTitle;\n        return (\n            <View style={containerStyle}>\n                {title}\n                {title && children && <Strut size={Spacing.xxxSmall_4} />}\n                {children}\n            </View>\n        );\n    }\n}\n\nconst styles = StyleSheet.create({\n    withoutTitle: {\n        padding: `10px ${Spacing.medium_16}px`,\n    },\n\n    withTitle: {\n        padding: Spacing.medium_16,\n    },\n});\n","/**\n * This is a little helper that we can use to wrap the react-popper reference\n * update methods so that we can convert a regular React ref into a DOM node\n * as react-popper expects, and also ensure we only update react-popper\n * on actual changes, and not just renders of the same thing.\n */\nimport * as React from \"react\";\nimport * as ReactDOM from \"react-dom\";\n\nimport type {PopperChildrenProps} from \"react-popper\";\n\ntype PopperRef = PopperChildrenProps[\"ref\"];\n\nexport default class RefTracker {\n    _lastRef: HTMLElement | null | undefined;\n    // @ts-expect-error [FEI-5019] - TS2564 - Property '_targetFn' has no initializer and is not definitely assigned in the constructor.\n    _targetFn: (\n        arg1?: HTMLElement | null | undefined,\n    ) => void | null | undefined;\n\n    updateRef: (\n        ref?: React.Component<any> | Element | null | undefined,\n    ) => void = (ref) => {\n        if (ref) {\n            // We only want to update the reference if it is\n            // actually changed. Otherwise, we can trigger another render that\n            // would then update the reference again and just keep looping.\n            const domNode = ReactDOM.findDOMNode(ref);\n            if (domNode instanceof HTMLElement && domNode !== this._lastRef) {\n                this._lastRef = domNode;\n                this._targetFn?.(domNode);\n            }\n        }\n    };\n\n    setCallback: (targetFn?: PopperRef | null | undefined) => void = (\n        targetFn,\n    ) => {\n        if (this._targetFn !== targetFn) {\n            if (targetFn && typeof targetFn !== \"function\") {\n                throw new Error(\"targetFn must be a function\");\n            }\n\n            // @ts-expect-error [FEI-5019] - TS2322 - Type '((instance: any) => void) | null' is not assignable to type '(arg1?: HTMLElement | null | undefined) => void | null | undefined'.\n            this._targetFn = targetFn || null;\n            if (this._lastRef && this._targetFn) {\n                this._targetFn(this._lastRef);\n            }\n        }\n    };\n}\n","/**\n * This component is a light wrapper for react-popper, allowing us to position\n * and control the tooltip bubble location and visibility as we need.\n */\nimport * as React from \"react\";\nimport {Popper} from \"react-popper\";\nimport type {PopperChildrenProps} from \"react-popper\";\n\nimport RefTracker from \"../util/ref-tracker\";\nimport type {Placement} from \"../util/types\";\nimport type {PopperElementProps} from \"./tooltip-bubble\";\n\ntype Props = {\n    /**\n     * This uses the children-as-a-function approach, mirroring react-popper's\n     * implementation.\n     *\n     * TODO(WB-624): figure out to only allow TooltipBubble and PopoverDialog\n     */\n    children: (arg1: PopperElementProps) => React.ReactNode;\n    /**\n     * The element that anchors the tooltip bubble.\n     * This is used to position the bubble.\n     */\n    anchorElement?: HTMLElement;\n    /** Where should the bubble try to go with respect to its anchor. */\n    placement: Placement;\n};\n\nexport default class TooltipPopper extends React.Component<Props> {\n    _bubbleRefTracker: RefTracker = new RefTracker();\n    _tailRefTracker: RefTracker = new RefTracker();\n\n    _renderPositionedContent(\n        popperProps: PopperChildrenProps,\n    ): React.ReactNode {\n        const {children} = this.props;\n\n        // We'll hide some complexity from the children here and ensure\n        // that our placement always has a value.\n        const placement: Placement =\n            popperProps.placement || this.props.placement;\n\n        // Just in case the callbacks have changed, let's update our reference\n        // trackers.\n        this._bubbleRefTracker.setCallback(popperProps.ref);\n        this._tailRefTracker.setCallback(popperProps.arrowProps.ref);\n\n        // Here we translate from the react-popper's PropperChildrenProps\n        // to our own TooltipBubbleProps.\n        const bubbleProps = {\n            placement,\n            style: {\n                // NOTE(jeresig): We can't just use `popperProps.style` here\n                // as the TypeScript type doesn't match Aphrodite's CSS TypeScript\n                // props (as it doesn't camelCase props). So we just copy over the\n                // props that we need, instead.\n                top: popperProps.style.top,\n                left: popperProps.style.left,\n                bottom: popperProps.style.bottom,\n                right: popperProps.style.right,\n                position: popperProps.style.position,\n                transform: popperProps.style.transform,\n            },\n            updateBubbleRef: this._bubbleRefTracker.updateRef,\n            tailOffset: {\n                bottom: popperProps.arrowProps.style.bottom,\n                right: popperProps.arrowProps.style.right,\n                top: popperProps.arrowProps.style.top,\n                left: popperProps.arrowProps.style.left,\n                transform: popperProps.arrowProps.style.transform,\n            },\n            updateTailRef: this._tailRefTracker.updateRef,\n            isReferenceHidden: popperProps.isReferenceHidden,\n        } as const;\n        return children(bubbleProps);\n    }\n\n    render(): React.ReactNode {\n        const {anchorElement, placement} = this.props;\n        return (\n            <Popper\n                referenceElement={anchorElement}\n                strategy=\"fixed\"\n                placement={placement}\n                modifiers={[\n                    {\n                        name: \"preventOverflow\",\n                        options: {\n                            rootBoundary: \"viewport\",\n                        },\n                    },\n                ]}\n            >\n                {(props) => this._renderPositionedContent(props)}\n            </Popper>\n        );\n    }\n}\n","/**\n * The Tooltip component provides the means to anchor some additional\n * information to some content. The additional information is shown in a\n * callout that hovers above the page content. This additional information is\n * invoked by hovering over the anchored content, or focusing all or part of the\n * anchored content.\n *\n * This component is structured as follows:\n *\n * Tooltip (this component)\n * - TooltipAnchor (provides hover/focus behaviors on anchored content)\n *   - TooltipPortalMounter (creates portal into which the callout is rendered)\n * --------------------------- [PORTAL BOUNDARY] ------------------------------\n * - TooltipPopper (provides positioning for the callout using react-popper)\n *   - TooltipBubble (renders the callout borders, background and shadow)\n *     - TooltipContent (renders the callout content; the actual information)\n *     - TooltipTail (renders the callout tail and shadow that points from the\n *                     callout to the anchor content)\n */\nimport * as React from \"react\";\nimport * as ReactDOM from \"react-dom\";\n\nimport {\n    UniqueIDProvider,\n    IIdentifierFactory,\n} from \"@khanacademy/wonder-blocks-core\";\nimport {maybeGetPortalMountedModalHostElement} from \"@khanacademy/wonder-blocks-modal\";\nimport type {Typography} from \"@khanacademy/wonder-blocks-typography\";\nimport type {AriaProps} from \"@khanacademy/wonder-blocks-core\";\n\nimport TooltipAnchor from \"./tooltip-anchor\";\nimport TooltipBubble from \"./tooltip-bubble\";\nimport TooltipContent from \"./tooltip-content\";\nimport TooltipPopper from \"./tooltip-popper\";\nimport type {Placement} from \"../util/types\";\n\ntype Props = AriaProps &\n    Readonly<{\n        /**\n         * The content for anchoring the tooltip.\n         * This component will be used to position the tooltip.\n         */\n        children: React.ReactElement<any> | string;\n        /**\n         * The title of the tooltip.\n         * Optional.\n         */\n        title?: string | React.ReactElement<React.ComponentProps<Typography>>;\n        /**\n         * The content to render in the tooltip.\n         */\n        content:\n            | string\n            | React.ReactElement<React.ComponentProps<typeof TooltipContent>>;\n        /**\n         * The unique identifier to give to the tooltip. Provide this in cases where\n         * you want to override the default accessibility solution. This identifier\n         * will be applied to the tooltip bubble content.\n         *\n         * By providing this identifier, the children that this tooltip anchors to\n         * will not be automatically given the aria-desribedby attribute. Instead,\n         * the accessibility solution is the responsibility of the caller.\n         *\n         * If this is not provided, the aria-describedby attribute will be added\n         * to the children with a unique identifier pointing to the tooltip bubble\n         * content.\n         */\n        id?: string;\n        /**\n         * When true, if a tabindex attribute is not already present on the element\n         * wrapped by the anchor, the element will be given tabindex=0 to make it\n         * keyboard focusable; otherwise, does not attempt to change the ability to\n         * focus the anchor element.\n         *\n         * Defaults to true.\n         *\n         * One might set this to false in circumstances where the wrapped component\n         * already can receive focus or contains an element that can.\n         * Use good judgement when overriding this value, the tooltip content should\n         * be accessible via keyboard in all circumstances where the tooltip would\n         * appear using the mouse, so verify those use-cases.\n         *\n         * Also, note that the aria-describedby attribute is attached to the root\n         * anchor element, so you may need to implement an additional accessibility\n         * solution when overriding anchor focusivity.\n         */\n        forceAnchorFocusivity?: boolean;\n        /**\n         * Where the tooltip should appear in relation to the anchor element.\n         * Defaults to \"top\".\n         */\n        placement: Placement;\n        /**\n         * Renders the tooltip when true, renders nothing when false.\n         *\n         * Using this prop makes the component behave as a controlled component. The\n         * parent is responsible for managing the opening/closing of the tooltip\n         * when using this prop.\n         */\n        opened?: boolean;\n        /**\n         * Test ID used for e2e testing.\n         */\n        testId?: string;\n    }>;\n\ntype State = Readonly<{\n    /**\n     * Whether the tooltip is open by hovering/focusing on the anchor element.\n     */\n    active: boolean;\n    /**\n     * Whether the tooltip is open by hovering on the tooltip bubble.\n     */\n    activeBubble: boolean;\n    /**\n     * The element that activates the tooltip.\n     */\n    anchorElement?: HTMLElement;\n}>;\n\ntype DefaultProps = {\n    forceAnchorFocusivity: Props[\"forceAnchorFocusivity\"];\n    placement: Props[\"placement\"];\n};\n\n/**\n * Use a tooltip to help describe an on screen object.\n *\n * Tooltips:\n *  - contain text\n *  - (optional) contain small graphic elements to complement the text\n *  - appear on hover or focus (for non-assistive tech keyboard users)\n *  - must have a tail that points to a parent object\n *  - DO NOT include actions\n *\n * For more rich content see Popovers, for taking action on an object, see\n * Snackbars (proposed).\n *\n * ### Usage\n *\n * ```jsx\n * import Tooltip from \"@khanacademy/wonder-blocks-tooltip\";\n *\n * <Tooltip content=\"This is a text tooltip\">\n *  Tooltip anchor\n * </Tooltip>\n * ```\n *\n */\nexport default class Tooltip extends React.Component<Props, State> {\n    static defaultProps: DefaultProps = {\n        forceAnchorFocusivity: true,\n        placement: \"top\",\n    };\n\n    /**\n     * Used to sync the `opened` state when Tooltip acts as a controlled\n     * component\n     */\n    static getDerivedStateFromProps(\n        props: Props,\n        state: State,\n    ): Partial<State> | null {\n        return {\n            active:\n                typeof props.opened === \"boolean\" ? props.opened : state.active,\n        };\n    }\n\n    state: State = {\n        active: false,\n        activeBubble: false,\n    };\n    static ariaContentId = \"aria-content\";\n\n    _updateAnchorElement(ref?: Element | null) {\n        if (ref && ref !== this.state.anchorElement) {\n            this.setState({anchorElement: ref as HTMLElement});\n        }\n    }\n\n    _renderBubbleContent(): React.ReactElement<\n        React.ComponentProps<typeof TooltipContent>\n    > {\n        const {title, content} = this.props;\n        if (typeof content === \"string\") {\n            return <TooltipContent title={title}>{content}</TooltipContent>;\n        } else if (title) {\n            return React.cloneElement(content, {title});\n        } else {\n            return content;\n        }\n    }\n\n    _renderPopper(ids?: IIdentifierFactory): React.ReactNode {\n        const {id} = this.props;\n        const bubbleId = ids ? ids.get(Tooltip.ariaContentId) : id;\n        if (!bubbleId) {\n            throw new Error(\"Did not get an identifier factory nor a id prop\");\n        }\n\n        const {placement} = this.props;\n        return (\n            <TooltipPopper\n                anchorElement={this.state.anchorElement}\n                placement={placement}\n            >\n                {(props) => (\n                    <TooltipBubble\n                        id={bubbleId}\n                        style={props.style}\n                        tailOffset={props.tailOffset}\n                        isReferenceHidden={props.isReferenceHidden}\n                        placement={props.placement}\n                        updateTailRef={props.updateTailRef}\n                        updateBubbleRef={props.updateBubbleRef}\n                        onActiveChanged={(active) =>\n                            this.setState({activeBubble: active})\n                        }\n                    >\n                        {this._renderBubbleContent()}\n                    </TooltipBubble>\n                )}\n            </TooltipPopper>\n        );\n    }\n\n    _getHost(): Element | null | undefined {\n        const {anchorElement} = this.state;\n\n        return (\n            maybeGetPortalMountedModalHostElement(anchorElement) ||\n            document.body\n        );\n    }\n\n    _renderTooltipAnchor(ids?: IIdentifierFactory): React.ReactNode {\n        const {children, forceAnchorFocusivity} = this.props;\n        const {active, activeBubble} = this.state;\n\n        const popperHost = this._getHost();\n\n        // TODO(kevinb): update to use ReactPopper's React 16-friendly syntax\n        return (\n            <React.Fragment>\n                <TooltipAnchor\n                    forceAnchorFocusivity={forceAnchorFocusivity}\n                    anchorRef={(r) => this._updateAnchorElement(r)}\n                    onActiveChanged={(active) => this.setState({active})}\n                    ids={ids}\n                >\n                    {children}\n                </TooltipAnchor>\n                {popperHost &&\n                    (active || activeBubble) &&\n                    ReactDOM.createPortal(this._renderPopper(ids), popperHost)}\n            </React.Fragment>\n        );\n    }\n\n    render(): React.ReactNode {\n        const {id} = this.props;\n        if (id) {\n            // Let's bypass the extra weight of an id provider since we don't\n            // need it.\n            return this._renderTooltipAnchor();\n        } else {\n            return (\n                <UniqueIDProvider scope=\"tooltip\" mockOnFirstRender={true}>\n                    {(ids) => this._renderTooltipAnchor(ids)}\n                </UniqueIDProvider>\n            );\n        }\n    }\n}\n"],"names":["ActiveTracker","who","v","wasActive","anchor","index","TooltipAppearanceDelay","TooltipDisappearanceDelay","TRACKER","_TooltipAnchor","React.Component","props","e","anchorNode","ReactDOM.findDOMNode","prevProps","forceAnchorFocusivity","currentTabIndex","hovered","focused","active","instant","delay","children","jsx","WBText","ids","anchorableChildren","React.cloneElement","TooltipAnchor","tempIdCounter","TooltipTail","placement","trimlineOffset","ARROW_WIDTH","ARROW_HEIGHT","points","position","y","x","offsetShadowX","dropShadowFilterId","jsxs","Spacing","Colors","MIN_DISTANCE_FROM_CORNERS","DISTANCE_FROM_ANCHOR","fullTailWidth","fullTailHeight","trimlinePoints","height","width","color","show","css","styles","Strut","offset","updateRef","View","StyleSheet","TooltipBubble","id","updateBubbleRef","isReferenceHidden","style","updateTailRef","tailOffset","TooltipContent","title","HeadingSmall","LabelMedium","containerStyle","RefTracker","ref","domNode","_a","targetFn","TooltipPopper","popperProps","bubbleProps","anchorElement","Popper","_Tooltip","state","content","bubbleId","maybeGetPortalMountedModalHostElement","activeBubble","popperHost","React.Fragment","r","active2","ReactDOM.createPortal","UniqueIDProvider","Tooltip"],"mappings":"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"}