import {Meta} from "@storybook/blocks";

<Meta
    title="Packages / Testing / Test Harness / Exports / makeTestHarness()"
/>

# makeTestHarness()

```ts
makeTestHarness<TAdapters: TestHarnessAdapters>(
    adapters: TAdapters,
    defaultConfigs: TestHarnessConfigs<TAdapters>,
): (<-TProps, +Instance = mixed>(
    Component: React.AbstractComponent<TProps, Instance>,
    configs?: $Shape<TestHarnessConfigs<TAdapters>>,
) => React.AbstractComponent<TProps, Instance>);
```

This method takes a set of adapters (such as <a href="./?path=/docs/packages-testing-test-harness-exports-harnessadapters--docs">`harnessAdapters.DefaultAdapters`</a>) and a set of default configurations for those adapters (such as <a href="./?path=/docs/packages-testing-test-harness-exports-harnessadapters--docs">`harnessAdapters.DefaultConfigs`</a>), and returns a function that can be called to create a component that applys those adapters with those default configs, or overrides to those configs, around another component.

The returned method will ensure refs are forwarded to the harnessed component, and the component the method returns will have the same props as the component it is harnessing.

The harnessed component can be used in unit tests, such as in Jest, to reduce boilerplate needed to setup the test case. It can also be used as to create a Storybook decorator when defining a Story a component.
