/**
 * This script processes the styleguide.config.js to generate a version for
 * our production documentation.
 *
 * 1. It strips any dev-only docs from the styleguide
 *    This is any section with the property "private" set to true.
 *
 * 2. Adds the design package versions from the package.json of each package so
 *    that we know what design spec and package versions were last released.
 *
 * Running `yarn build:styleguidist` will run this script and then run the
 * styleguidist build, which will generate the docs.
 *
 * Running `yarn start` will skip this script so that developers can see both
 * exported and development documentation.
 */
const fs = require("fs");
const path = require("path");
const process = require("process");

const {
    getComponentFilesFromSection,
} = require("./styleguidist-config-utils.js");

const styleguideConfig = require("../styleguide.config.js");

/**
 * Writes a styleguide configuration to a file with the given path.
 */
function writeStyleguideConfig(filepath, config) {
    const lines = [
        `// This file is auto-generated by gen-styleguide-prod-config.js`,
        `// Do not edit this file.`,
        `const {createConfig, babel, postcss} = require("webpack-blocks");`,
        ``,
        `module.exports = {`,
    ];
    Object.entries(config).forEach((entry) => {
        // HACK(somewhatabstract): We can't just output the webpackConfig
        // because we executed some things when we loaded it. We could write a
        // whole thing that reads the text and parses things out, but we don't
        // need to. We'll just recreate the executed property here.
        switch (entry[0]) {
            case "webpackConfig":
                lines.push(
                    "    webpackConfig: createConfig([babel(), postcss()]),",
                );
                break;

            case "serverPort":
                // Skip. We do a different port for prod so that prod and dev servers can coexist, if necessary.
                break;

            default:
                lines.push(`    ${entry[0]}: ${JSON.stringify(entry[1])},`);
                break;
        }
    });
    // Let's specify the production server port.
    lines.push(`    serverPort: 6061,`);
    lines.push("};\n");

    const data = lines.join("\n");
    fs.writeFileSync(filepath, data, "utf8");
}

/**
 * This function recurses through the sections and sub-sections, removing
 * any that are marked as private. It returns the modified array with the
 * private sections removed.
 */
function removePrivateSections(sections) {
    if (!sections) {
        return sections;
    }
    for (let i = sections.length; i > 0; i--) {
        const sectionIndex = i - 1;
        if (sections[sectionIndex].private) {
            // eslint-disable-next-line no-console
            console.log(
                `Removing private section ${sections[sectionIndex].name}`,
            );

            // If the section is private, we presume all content of the section is
            // private too.
            sections.splice(sectionIndex, 1);
        } else {
            // And now, we move into the chilren of the section and repeat.
            sections[sectionIndex].sections = removePrivateSections(
                sections[sectionIndex].sections,
            );
        }
    }
    return sections;
}

function maybeGetPackagePathForSection(section) {
    const getPackageDirFromPath = (filepath) => {
        if (!filepath) {
            return null;
        }

        do {
            const parentPath = path.dirname(filepath);
            if (parentPath) {
                const parentName = path.basename(parentPath);
                if (parentName === "packages") {
                    return filepath;
                } else if (parentName === parentPath) {
                    break;
                } else {
                    filepath = parentPath;
                }
            }
        } while (filepath);

        return null;
    };

    if (section.content) {
        return getPackageDirFromPath(section.content);
    } else {
        // Other option is to get one of the component file paths and use that.
        const files = getComponentFilesFromSection(section);
        if (files.length) {
            return getPackageDirFromPath(files[0]);
        }
    }

    // We get here, we got nothing.
    return null;
}

function getVersionInfoForSection(section) {
    const pathForSection = maybeGetPackagePathForSection(section);
    if (!pathForSection) {
        // We can't help you.
        return null;
    }

    const pkgJsonPath = path.join(path.resolve(pathForSection), "package.json");
    if (fs.existsSync(pkgJsonPath)) {
        // We have a package file, let's read it and find out what we can.
        const pkgJson = require(pkgJsonPath);

        return {
            name: pkgJson.name,
            lastRelease: pkgJson.version,
            design: pkgJson.design,
            prototype: pkgJson.private,
        };
    } else {
        return null;
    }
}

function genStyleguideProdConfig() {
    if (!process.env.PULL_REQUEST) {
        // We iterate over the configuration and remove private sections.
        styleguideConfig.sections = removePrivateSections(
            styleguideConfig.sections,
        );
    }

    // Then we go one more time at the root level and augment the sections with
    // some additional version information.
    for (const section of styleguideConfig.sections) {
        const info = getVersionInfoForSection(section);
        if (info) {
            // eslint-disable-next-line no-console
            console.log(
                `Adding package information for ${
                    section.name
                }: ${JSON.stringify(info)}`,
            );
            // Let's add some info!
            const currentDescription = section.description;
            const lines = [
                info.prototype ? "***PROTOTYPE***" : null,
                `Package: **${info.name}**`,
                `Design Specification: **${info.design}**`,
                `Last released @ **${info.lastRelease}**\n`,
                currentDescription,
            ];
            section.description = lines.filter((l) => !!l).join("  \n");
        } else {
            // eslint-disable-next-line no-console
            console.log(`No package information found for ${section.name}`);
        }
    }

    // Finally, we output the results.
    // We assume we're being run from the root.
    writeStyleguideConfig("./styleguide.prod.config.js", styleguideConfig);
}

/**
 *
 *
 * This is where the magic begins!
 *
 *
 */
genStyleguideProdConfig();
