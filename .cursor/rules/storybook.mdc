---
description: Storybook best practices for Wonder Blocks component stories
globs: *.stories.tsx,*.stories.ts
alwaysApply: false
---
# Storybook Best Practices

This guide covers conventions and best practices for creating Storybook stories (`.stories.tsx` or `.stories.ts`) in the Wonder Blocks design system.

## File Structure and Organization

### Import Order

**✅ Follow this import order:**

1. React imports
2. Third-party libraries (aphrodite, storybook actions/types)
3. Phosphor icons
4. Wonder Blocks packages (sorted by purpose)
5. Local imports (package config, argtypes, components)
6. Types and interfaces

```tsx
// ✅ Good
import * as React from "react";
import {StyleSheet} from "aphrodite";
import {action} from "storybook/actions";
import type {Meta, StoryObj} from "@storybook/react-vite";

import magnifyingGlass from "@phosphor-icons/core/regular/magnifying-glass.svg";

import Button from "@khanacademy/wonder-blocks-button";
import {View} from "@khanacademy/wonder-blocks-core";
import {semanticColor, spacing} from "@khanacademy/wonder-blocks-tokens";

import packageConfig from "../../packages/wonder-blocks-button/package.json";
import ComponentInfo from "../components/component-info";
import ButtonArgTypes from "./button.argtypes";
```

### TypeScript Types

**✅ Define story types consistently:**

```tsx
// ✅ Good - Use StoryObj for type safety
type StoryComponentType = StoryObj<typeof Component>;

export const Default: StoryComponentType = {
    args: {
        // props here
    },
};
```

**❌ Avoid using `any` types:**

```tsx
// ❌ Bad
export const Default: any = {
    args: {
        // props here
    },
};
```

## Default Export Configuration

### Meta Configuration

**✅ Include all relevant meta properties:**

```tsx
export default {
    title: "Packages / ComponentName / SubComponent",
    component: ComponentName,
    subcomponents: {SubComponent1, SubComponent2}, // If applicable
    parameters: {
        componentSubtitle: (
            <ComponentInfo
                name={packageConfig.name}
                version={packageConfig.version}
            />
        ),
        chromatic: {
            disableSnapshot: false, // or true with reason
        },
    },
    argTypes: ComponentArgTypes,
    args: {
        // Default args for all stories
    },
    decorators: [
        // Optional decorators
    ],
} as Meta<typeof ComponentName>;
```

**Key properties:**
- **`title`**: Hierarchical path in Storybook sidebar
- **`component`**: The main component being documented
- **`subcomponents`**: Related components shown in docs
- **`parameters`**: Meta-level configuration (Chromatic, a11y, etc.)
- **`argTypes`**: Control definitions (usually imported from separate file)
- **`args`**: Default values applied to all stories
- **`decorators`**: Layout wrappers applied to all stories

### Title Naming Convention

**✅ Follow the hierarchy:**

```tsx
// ✅ Good - Clear hierarchy
title: "Packages / Button / Button"
title: "Packages / Dropdown / SingleSelect"
title: "Packages / Button / Testing / Snapshots / ActivityButton"
```

**❌ Avoid flat or unclear titles:**

```tsx
// ❌ Bad
title: "Button Stories"
title: "Components"
```

## Story Patterns

### General Tips for Stories

**✅ Follow these best practices when writing stories:**

* **The Default story** should be interactive and work with the Storybook controls. Users should be able to modify props using the controls panel.
* **Write stories for all possible prop combinations/states**. This is very helpful for identifying that all states are styled correctly and any changes can be confirmed in visual regression tests.
* **Disable Chromatic for stories that don't need visual regression tests** (we have a limited number of Chromatic snapshots monthly). For example:
  * Stories already covered by another story
  * Stories for testing purposes only
  * Stories that don't have any visual differences from other stories
* **Avoid including specific background colors in Stories** so that we can dynamically change the background in Storybook using the Storybook background control in the toolbar. Let users control the background through Storybook's built-in controls.

### Basic Story Structure

**✅ Export stories with descriptive JSDoc comments:**

```tsx
/**
 * This is the default state of the button showing standard usage.
 * It demonstrates the basic props and expected behavior.
 */
export const Default: StoryComponentType = {
    args: {
        children: "Click me",
        onClick: () => {},
    },
};
```

### Interactive Stories with State

**✅ Use render functions for stateful stories:**

```tsx
export const WithState: StoryComponentType = {
    render: function Render(args) {
        const [value, setValue] = React.useState(args.value || "");

        return (
            <Component
                {...args}
                value={value}
                onChange={setValue}
            />
        );
    },
    args: {
        // initial args
    },
};
```

**⚠️ Important: Use function declarations, not arrow functions:**

```tsx
// ✅ Good - Named function for better debugging
render: function Render(args) {
    // ...
}

// ❌ Avoid - Arrow functions don't have clear names
render: (args) => {
    // ...
}
```

### Variant Stories

**✅ Show different variants in a single story:**

```tsx
/**
 * Buttons have three kinds: `primary` (default), `secondary`, and `tertiary`.
 */
export const Kinds: StoryComponentType = {
    render: () => (
        <View style={{gap: spacing.medium_16}}>
            <Button onClick={() => {}}>Primary</Button>
            <Button kind="secondary" onClick={() => {}}>Secondary</Button>
            <Button kind="tertiary" onClick={() => {}}>Tertiary</Button>
        </View>
    ),
};
```

## JSDoc Documentation

### Story Comments

**✅ Include comprehensive JSDoc comments:**

```tsx
/**
 * This example demonstrates how SingleSelect behaves with an initial value.
 * The screen reader will not announce the initial value on mount, but will
 * announce when the value changes through user interaction.
 */
export const WithInitialValue: StoryComponentType = {
    // story configuration
};
```

### Prop Documentation

* The props table on the autodocs page for Storybook should be extracted from the JSDoc comments on the props for a component.
* If the auto-generated type for a prop is not helpful (e.g., something generic like `"union"`), the type can be overridden in an `argTypes.ts` file.
* Props in the table can be grouped into categories like `Visual style`, `Events`, `Accessibility`. Use the `table.category` property in argTypes to group props.

### ArgTypes Files

**When to use:** Override auto-generated prop types when they're not helpful or need customization.

**✅ Create an argTypes file for your component:**

```tsx
// __docs__/wonder-blocks-button/button.argtypes.ts
import type {ArgTypes} from "@storybook/react-vite";

export default {
    // Override type display for union types
    kind: {
        control: {type: "select"},
        options: ["primary", "secondary", "tertiary"],
        table: {
            category: "Visual style",
            type: {summary: `"primary" | "secondary" | "tertiary"`},
            defaultValue: {summary: `"primary"`},
        },
    },
    // Group related props
    size: {
        control: {type: "select"},
        table: {
            category: "Layout",
            type: {summary: `"medium" | "small" | "large"`},
        },
    },
    // Improve descriptions for complex props
    style: {
        table: {
            category: "Layout",
            type: {summary: "StyleType"},
        },
    },
} satisfies ArgTypes;
```

**✅ Use argTypes in your story's meta:**

```tsx
import ComponentArgTypes from "./component.argtypes";

export default {
    title: "Packages / Component",
    component: Component,
    argTypes: ComponentArgTypes,
} as Meta<typeof Component>;
```

**Common argTypes configurations:**

| Property | Purpose |
|----------|---------|
| `control.type` | Control widget (`"select"`, `"boolean"`, `"text"`, etc.) |
| `options` | Available options for select controls |
| `table.category` | Group props in the docs table |
| `table.type.summary` | Override the displayed type |
| `table.defaultValue.summary` | Show default value in docs |
| `mapping` | Map control values to actual prop values |

### Examples in Stories

* The stories should showcase the different ways a component can be used.
* The comment block before a story declaration can be used to document more about a specific prop or behavior highlighted in the example.

### Accessibility Guidelines Documentation

* Document accessibility guidelines and what's been implemented in the component.
* Create separate pages in Storybook to describe the accessibility for a component.
* Examples of accessibility documentation pages:
  * Accordion Accessibility
  * Combobox Accessibility
  * TextArea Accessibility


## Styling in Stories

### Aphrodite Styles

**✅ Define styles using StyleSheet.create:**

```tsx
const styles = StyleSheet.create({
    container: {
        width: "100%",
        gap: sizing.size_160,
    },
    row: {
        flexDirection: "row",
        alignItems: "center",
        gap: spacing.medium_16,
    },
});
```

**✅ Use Wonder Blocks tokens for values:**

```tsx
// ✅ Good - Use tokens
const styles = StyleSheet.create({
    container: {
        gap: sizing.medium_16,
        padding: sizing.size_160,
        backgroundColor: semanticColor.core.background.base.subtle,
    },
});

// ❌ Avoid - Hard-coded values
const styles = StyleSheet.create({
    container: {
        gap: 16,
        padding: 10,
        backgroundColor: "#f0f0f0",
    },
});
```

## Parameters Configuration

### Chromatic Configuration

**✅ Disable snapshots with clear reasoning:**

```tsx
export const Interactive: StoryComponentType = {
    render: () => {/* ... */},
    parameters: {
        chromatic: {
            // Disabling because this is for manual testing purposes
            disableSnapshot: true,
        },
    },
};
```

**✅ Configure snapshot timing when needed:**

```tsx
export const ControlledOpened: StoryComponentType = {
    render: (args) => <Component {...args} />,
    parameters: {
        // Added to ensure that the dropdown menu is rendered using PopperJS.
        chromatic: {delay: 500},
    },
};
```

**✅ Enable snapshots for important visual states:**

```tsx
export const WithIcon: StoryComponentType = {
    render: () => <IconExample />,
    parameters: {
        chromatic: {
            modes: themeModes, // Test in multiple themes
        },
    },
};
```

### Theme Modes Configuration

Theme modes allow Chromatic to capture snapshots of components in multiple themes (e.g., default and Khanmigo/ThunderBlocks themes).

**✅ Import and use `themeModes` for visual regression testing:**

```tsx
import {themeModes} from "../../.storybook/modes";

export default {
    title: "Packages / Component / Testing / Snapshots",
    parameters: {
        chromatic: {
            modes: themeModes, // Captures snapshots in all themes
        },
    },
    tags: ["!autodocs"],
} as Meta<typeof Component>;
```

**Available modes (defined in `.storybook/modes.ts`):**

**⚠️ Use theme modes sparingly** - Each mode multiplies the number of Chromatic snapshots. Only add theme modes to snapshot stories that specifically test theming or visual appearance.

## Testing-Specific Stories

**⚠️ Important: StateSheet and Scenarios stories are specifically designed for Chromatic visual regression testing.** These stories systematically capture different states and edge cases to ensure visual consistency across code changes.

### Snapshot Stories

**✅ Create dedicated snapshot stories:**

```tsx
/**
 * The following stories are used to generate the pseudo states for the
 * ActivityButton component. This is only used for visual testing in Chromatic.
 */
export default {
    title: "Packages / Button / Testing / Snapshots / ActivityButton",
    tags: ["!autodocs"], // Exclude from auto-generated docs
    parameters: {
        chromatic: {
            modes: themeModes,
        },
    },
} as Meta;
```

**✅ Use StateSheet for pseudo-state testing (Chromatic visual regression):**

```tsx
export const StateSheetStory: Story = {
    name: "StateSheet",
    render: (args) => {
        return (
            <StateSheet
                rows={kinds}
                columns={actionTypes}
                title="Kind / Action Type"
            >
                {({props, className, name}) => (
                    <Component
                        {...args}
                        {...props}
                        className={className}
                    />
                )}
            </StateSheet>
        );
    },
    parameters: {
        pseudo: defaultPseudoStates,
    },
};
```

**⚠️ Important: StateSheet stories should cover:**
- **Focus state** (`:focus-visible`) - Test keyboard navigation and focus indicators
- **Hover state** (`:hover`) - Test mouse hover interactions
- **Pressed/Active state** (`:active`) - Test click/press feedback
- **Disabled state** - Test with `disabled` prop set to `true`
- **Relevant prop combinations** - Test all important combinations of `kind`, `actionType`, `size`, etc.

**Example of comprehensive state coverage:**

```tsx
const kinds = [
    {name: "Primary", props: {kind: "primary"}},
    {name: "Secondary", props: {kind: "secondary"}},
    {name: "Tertiary", props: {kind: "tertiary"}},
];

const actionTypes = [
    {name: "Progressive", props: {actionType: "progressive"}},
    {name: "Neutral", props: {actionType: "neutral"}},
    {name: "Disabled", props: {disabled: true}},
];

export const StateSheetStory: Story = {
    name: "StateSheet",
    render: (args) => {
        return (
            <StateSheet
                rows={kinds}
                columns={actionTypes}
                title="Kind / Action Type"
            >
                {({props, className, name}) => (
                    <Component
                        {...args}
                        {...props}
                        className={className}
                    />
                )}
            </StateSheet>
        );
    },
    parameters: {
        pseudo: defaultPseudoStates, // Includes focus, hover, active states
    },
};
```

### Scenario Stories

**✅ Test specific scenarios (Chromatic visual regression):**

```tsx
export const Scenarios: Story = {
    render() {
        const scenarios = [
            {
                name: "Long label",
                props: {
                    children: (
                        <Component>{longText}</Component>
                    ),
                },
            },
            {
                name: "Long label overflowing",
                props: {
                    children: (
                        <Component styles={{root: {maxWidth: 200}}}>
                            {longTextWithNoWordBreak}
                        </Component>
                    ),
                },
            },
            {
                name: "Right-to-left (RTL)",
                decorator: <div dir="rtl" />,
                props: {
                    children: (
                        <Component>یہ اردو میں لکھا ہے۔</Component>
                    ),
                },
            },
            {
                name: "With custom styles",
                props: {
                    children: (
                        <Component
                            styles={{
                                root: {
                                    maxWidth: 300,
                                    backgroundColor: semanticColor.core.background.base.subtle,
                                }
                            }}
                        >
                            Custom styled component
                        </Component>
                    ),
                },
            },
        ];
        return (
            <ScenariosLayout scenarios={scenarios}>
                {(props) => props.children}
            </ScenariosLayout>
        );
    },
};
```

**⚠️ Important: Scenario stories should include:**
- **RTL cases**: Test right-to-left layouts when component supports directional content. Use the `decorator: <div dir="rtl" />` property to wrap the scenario.
- **Custom styles**: Test components with custom style overrides to ensure flexibility
- **Edge cases**: Long text, overflow, truncation, empty states

## Advanced Patterns

### Custom Openers and Complex Props

**✅ Document custom implementations:**

```tsx
/**
 * In case you need to use a custom opener with the `SingleSelect`, you can use
 * the opener property to achieve this. In this example, the opener prop accepts
 * a function with the following arguments:
 *  - `eventState`: lets you customize the style for different states
 *  - `text`: Passes the menu label defined in the parent component
 *  - `opened`: Whether the dropdown is opened
 */
export const CustomOpener: StoryComponentType = {
    render: Template,
    args: {
        opener: ({focused, hovered, pressed, text, opened}: OpenerProps) => {
            return (
                <Button
                    style={[
                        styles.customOpener,
                        focused && styles.focused,
                        hovered && styles.hovered,
                        pressed && styles.pressed,
                    ]}
                >{`${text} ${opened ? ": opened" : ""}`}</Button>
            );
        },
    },
};
```

## Story Naming Conventions

**✅ Use clear, descriptive names:**

```tsx
// ✅ Good - Clear and descriptive
export const Default: StoryComponentType = {/* ... */};
export const WithIcon: StoryComponentType = {/* ... */};
export const Disabled: StoryComponentType = {/* ... */};
export const LongOptionLabels: StoryComponentType = {/* ... */};
export const ErrorFromValidation: StoryComponentType = {/* ... */};
```

**✅ Override story names when needed:**

```tsx
export const WithRouter: StoryComponentType = {
    name: "Navigation with React Router", // Overrides story name in UI
    render: () => {/* ... */},
};
```

## Actions and Event Handlers

**✅ Use storybook actions for event logging:**

```tsx
import {action} from "storybook/actions";

export const Default: StoryComponentType = {
    args: {
        onClick: action("clicked"),
        onChange: action("changed"),
    },
};
```

**✅ Combine actions with state updates:**

```tsx
export const Interactive: StoryComponentType = {
    render: function Render(args) {
        const [value, setValue] = React.useState("");

        const handleChange = (newValue: string) => {
            action("onChange")(newValue);
            setValue(newValue);
        };

        return <Component value={value} onChange={handleChange} />;
    },
};
```

## Common Pitfalls to Avoid

**❌ Don't mix testing snapshots with documentation stories:**

```tsx
// ❌ Bad - Testing story in documentation
export default {
    title: "Packages / Button", // Main docs path
    // ... testing configurations
};

// ✅ Good - Separate testing stories
export default {
    title: "Packages / Button / Testing / Snapshots",
    tags: ["!autodocs"],
};
```

**❌ Don't forget to disable snapshots when appropriate:**

```tsx
// ❌ Bad - No chromatic config for interactive-only story
export const WithForm: StoryComponentType = {
    render: () => <form>{/* ... */}</form>,
};

// ✅ Good - Explicitly disable snapshots
export const WithForm: StoryComponentType = {
    render: () => <form>{/* ... */}</form>,
    parameters: {
        chromatic: {
            // Form submission requires user interaction
            disableSnapshot: true,
        },
    },
};
```

**❌ Don't use `React.FC` for component props:**

```tsx
// ❌ Bad
const Component: React.FC<Props> = (props) => {/* ... */};

// ✅ Good
const Component = (props: Props) => {/* ... */};
```

## Best Practices Summary

1. **✅ Structure**: Follow consistent import order and file organization
2. **✅ Types**: Use TypeScript types for story definitions
3. **✅ Documentation**: Include comprehensive JSDoc comments with usage examples
4. **✅ Variants**: Show all important component variants
5. **✅ Accessibility**: Test and document a11y considerations
6. **✅ Visual Testing**: Configure Chromatic appropriately
7. **✅ State Management**: Use proper patterns for stateful stories
8. **✅ Naming**: Use clear, descriptive names for stories
9. **✅ Tokens**: Use Wonder Blocks tokens instead of hard-coded values
10. **✅ Testing**: Separate documentation stories from visual testing stories
