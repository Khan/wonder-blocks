---
description: Jest testing best practices and patterns for unit tests
globs: *.test.ts,*.test.tsx
alwaysApply: false
---
# Jest Testing Best Practices

This guide covers testing patterns and best practices for Jest and React Testing Library in the Wonder Blocks codebase.

## Core Testing Principles

### ⚠️ Critical Setup Rules

**Test Workflow Priority:**
- ✅ **ALWAYS fix failing tests BEFORE fixing linting errors**
- ✅ **Focus on underlying errors, not `Unhandled console.error call` messages**
- ⚠️ When tests fail with `Unhandled console.error call`, look for the **root cause error** (e.g., `ReferenceError: window is not defined`)
- ⚠️ The console.error messages are symptoms, not the actual problem - fix the underlying issue

**File Structure:**
- ✅ Name test files with `.test.ts` or `.test.tsx` suffix
- ✅ Place in `__tests__/` directory OR colocate with source files (follow local conventions)

**Test Framework Setup:**
- ✅ Additional matchers from React Testing Library (RTL) and `jest-extended` are available
- ✅ Use `describe`/`it` pattern for test organization
- ✅ Use `globalThis` prefix when accessing global objects
- ✅ **Prioritize testing non-trivial business logic** over trivial implementations

### Arrange-Act-Assert Pattern

**⚠️ ALWAYS use this three-section structure:**

```typescript
describe("Calculator", () => {
    it("should add two numbers correctly", () => {
        // Arrange
        const a = 5;
        const b = 3;

        // Act
        const result = add(a, b);

        // Assert
        expect(result).toBe(8);
    });
});
```

**Rules:**
- ✅ **ALWAYS divide tests** into Arrange, Act, Assert sections with comments
- ✅ **ALWAYS use separate comments** for each section (`// Arrange`, `// Act`, `// Assert`)
- ❌ **NEVER combine sections** (e.g., don't write `// Act & Assert`)
- ❌ **NEVER use multiple Act or Assert sections** in a single test (split into separate tests instead)

**Exception - Testing Thrown Errors:**

When testing errors, use an `underTest` variable in the Act section:

```typescript
it("should throw an error when input is invalid", () => {
    // Arrange
    const invalidInput = "invalid";

    // Act
    const underTest = () => {
        processInput(invalidInput);
    };

    // Assert
    expect(underTest).toThrow("Invalid input");
});
```

### Assertions

**Best Practices:**
- ✅ **Use specific matchers** when possible (e.g., `toBe`, `toEqual`, `toHaveBeenCalledWith`)
- ✅ **Use `.toMatchInlineSnapshot()`** for complex output validation (auto-updates)
- ✅ **Prefer explicit assertions** over implicit ones
- ✅ Use semantic matchers from RTL: `toBeInTheDocument()`, `toBeVisible()`, `toHaveAttribute()`

### Parameterized Tests with `it.each`

**When to use:** Testing the same logic with multiple input/output combinations

**✅ DO: Use `it.each` for data-driven tests**

```typescript
describe("Calculator", () => {
    it.each([
        [2, 3, 5],
        [0, 0, 0],
        [-1, 1, 0],
        [10, -5, 5],
    ])("should add %i and %i to equal %i", (a, b, expected) => {
        // Arrange & Act
        const result = add(a, b);

        // Assert
        expect(result).toBe(expected);
    });
});
```

**Benefits:**
- ✅ **Reduces Duplication**: Test same logic with different inputs
- ✅ **Clear Test Names**: Each test shows specific values being tested
- ✅ **Easy to Extend**: Simply add new arrays to test data
- ✅ **Better Coverage**: Test edge cases and boundary conditions efficiently

#### Alternative Syntax

```typescript
it.each`
    a    | b    | expected
    ${2} | ${3} | ${5}
    ${0} | ${0} | ${0}
    ${-1} | ${1} | ${0}
    `("should add $a and $b to equal $expected", ({ a, b, expected }) => {
    const result = add(a, b);
    expect(result).toBe(expected);
});
```

## Mocking and Spying

### ⚠️ Critical Rules - ALWAYS Follow These

1. **NEVER mock `console.error`** - This hides real implementation issues and errors
2. **ALWAYS use `jest.spyOn()` to create spies** - Never treat the original function as though it were a spy
3. **Store spy return values in variables ONLY when asserting on them** - Avoids unused variable linter errors
4. **NEVER mock outside of tests** - Even if it means code duplication, keep mocks inside test cases

### Method Spying - Correct Pattern

**✅ DO: Use jest.spyOn and store the result when asserting**

```typescript
import * as SomeFile from "./some-file.ts";

describe("MyComponent", () => {
    it("should call someMethod with correct args", () => {
        // Arrange
        // Store spy because we'll assert on it later
        const spy = jest.spyOn(SomeFile, "someMethod").mockReturnValue(mockValue);

        // Act
        myFunction();

        // Assert
        expect(spy).toHaveBeenCalledWith(expectedArgs);
    });
});
```

**❌ DON'T: Treat the original function as a spy without jest.spyOn()**

```typescript
// ❌ WRONG - This will fail because someMethod is not a spy
import * as SomeFile from "./some-file.ts";

describe("MyComponent", () => {
    it("should call someMethod", () => {
        // Act
        myFunction();

        // Assert
        expect(SomeFile.someMethod).toHaveBeenCalled(); // ❌ ERROR! Not a spy
    });
});
```

### When to Store Spies in Variables

**Spies serve two purposes:**
1. **Mocking behavior** - Replace function implementation or return value
2. **Verification** - Assert the function was called with correct arguments

**✅ Mocking only (no variable needed):**

```typescript
it("should process user data", () => {
    // Arrange
    // Mock the API call to return test data, but don't store it
    jest.spyOn(API, "fetchUser").mockResolvedValue(mockUserData);

    // Act
    const result = processUserProfile();

    // Assert
    // We're testing processUserProfile's logic, not that fetchUser was called
    expect(result.displayName).toBe("John Doe");
    // No spy variable = no unused variable linter error
});
```

**✅ Mocking AND verification (store in variable):**

```typescript
it("should call analytics when button is clicked", () => {
    // Arrange
    // Store the spy because we'll assert on it
    const trackEventSpy = jest
        .spyOn(Analytics, "trackEvent")
        .mockReturnValue(undefined);

    // Act
    userEvent.click(screen.getByRole("button"));

    // Assert
    // We're testing that the analytics call happens correctly
    expect(trackEventSpy).toHaveBeenCalledWith("button_click", {
        buttonId: "submit",
    });
});
```

**Key point:** Only store the spy in a variable if you're going to assert on it. This avoids unused variable linter errors while still allowing you to verify calls when needed.

### Common Spy Patterns

**Mock only (no variable):**

```typescript
// When you only need to control the return value
jest.spyOn(module, "functionName").mockReturnValue(mockValue);
jest.spyOn(module, "asyncFunction").mockResolvedValue(mockValue);
jest.spyOn(module, "asyncFunction").mockRejectedValue(new Error("Test error"));
```

**Mock and verify (store in variable):**

```typescript
// When you need to assert the spy was called
const spy = jest.spyOn(module, "functionName").mockReturnValue(mockValue);
// ... later in Assert section:
expect(spy).toHaveBeenCalledWith(expectedArgs);
```

**Spy with mock implementation:**

```typescript
// Store only if you'll verify it was called
const spy = jest.spyOn(module, "functionName").mockImplementation((arg) => {
    return processedValue;
});
```

### Mocking Guidelines

**DO:**
- ✅ Use `jest.spyOn()` for mocking functions and tracking calls
- ✅ Store spy return values in variables ONLY when you need to assert on them
- ✅ Chain `.mockReturnValue()` or similar directly on `jest.spyOn()` when only mocking behavior
- ✅ Keep mocks and spies inside test cases when possible
- ✅ Use mocking and spies to isolate the code under test at boundaries with other code
- ✅ Clean up spies after tests (Jest does this automatically with `clearAllMocks`)

**DON'T:**
- ❌ Never mock `console.error` - this hides real implementation issues
- ❌ Never treat original functions as spies without `jest.spyOn()`
- ❌ Never store spies in variables if you won't assert on them (causes unused variable linter errors)
- ❌ Never use `jest.spyOn()` to mock `khanFetch` - use `setKhanFetchOverride` instead (see HTTP/API Mocking section)
- ❌ Avoid mocking outside of tests, even if it means code duplication
- ❌ Avoid using `withVariables` and `withContext` unless exact variable/context matches are absolutely necessary (leads to brittle tests)

### File System Mocking

**When to use each approach:**

**✅ Simple file operations: Use `jest.spyOn` on `fs` module**

```typescript
import * as FS from "fs";

describe("File operations", () => {
    it("should read file", () => {
        // Arrange
        const readFileSyncSpy = jest
            .spyOn(FS, "readFileSync")
            .mockReturnValue("file contents");

        // Act
        const result = myFileReader("path/to/file");

        // Assert
        expect(readFileSyncSpy).toHaveBeenCalledWith("path/to/file", "utf-8");
    });
});
```

**✅ Complex file operations: Use `memfs` for in-memory filesystem**

```typescript
// At the top of test file - mock entire fs modules
jest.mock("node:fs", () => jest.requireActual("memfs").fs);
jest.mock("node:fs/promises", () => jest.requireActual("memfs").fs.promises);

// Now you can read/write files in tests without touching real filesystem
```

**When to use which:**
- ✅ **Use spies** for 1-2 simple fs calls (read/write/exists)
- ✅ **Use memfs** when testing complex file operations, directory structures, or multiple files

## Component Testing

### Hook Testing

**✅ Use `renderHook`:**

```typescript
import {renderHook} from "@testing-library/react";

// Direct for simple hooks
const {result} = renderHook(() => useMyHook(params));
```

### User Interactions

**✅ ALWAYS use `userEvent` for interactions:**

```typescript
import userEvent from "@testing-library/user-event";

// ✅ DO: Use userEvent (realistic, includes focus/blur/typing)
await userEvent.click(screen.getByRole("button"));
await userEvent.type(screen.getByRole("textbox"), "hello");

// ❌ DON'T: Use fireEvent (low-level, less realistic)
fireEvent.click(button);
```

### Element Selection

**Query priority (use in this order):**

1. ✅ **Semantic queries** (best): `getByRole`, `getByLabelText`, `getByText`
2. ✅ **Test IDs** (fallback): `getByTestId` with `data-testid` attribute
3. ❌ **NEVER use** CSS classes, IDs, or structural selectors (brittle)

```typescript
// ✅ DO: Semantic queries
screen.getByRole("button", {name: /submit/i});
screen.getByLabelText("Email address");
screen.findByText("Welcome back");

// ✅ DO: Test IDs when semantic queries don't work
screen.getByTestId("custom-widget");

// ❌ DON'T: CSS selectors or implementation details
container.querySelector(".my-class");
container.querySelector("#my-id");
```

## Wonder Blocks Component Testing

### Accessibility Testing

**✅ ALWAYS test accessibility features:**

```typescript
// Check disabled state
expect(button).toHaveAttribute("aria-disabled", "true");

// Verify ARIA labels
expect(dialog).toHaveAttribute("aria-labelledby", "dialog-title");

// Test keyboard navigation
await userEvent.tab();
expect(screen.getByRole("button")).toHaveFocus();
```

**Required accessibility tests:**
- ✅ Disabled states with `aria-disabled`
- ✅ Keyboard navigation and focus management
- ✅ ARIA attributes and roles
- ✅ Screen reader labels

### MultiSelect Testing

**✅ Test selection states:**
- ✅ **Multiple selections**: Select at least 2 items when testing multi-select mode
- ✅ **Single selection**: Test single-item selection
- ✅ **Empty state**: Test with no selections
- ✅ **All selected**: Test maximum selection scenarios

## Tools and Commands

### Terminal Commands

```bash
# Run all tests
pnpm jest

# Run tests in watch mode
pnpm jest --watch

# Update snapshots
pnpm jest -u

# Run tests with coverage
pnpm jest --coverage

# Run specific test file
pnpm jest path/to/test-file.test.ts

# Debug with verbose output
pnpm jest --verbose --runInBand
```

### Debugging Priority Order

**Terminal Commands**
- Add `console.log` statements for debugging
- Use `--verbose` flag for detailed output
- Use `--runInBand` for sequential execution (easier to debug)
- Use Node debugger with `debugger` statements
