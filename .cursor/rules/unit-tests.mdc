---
description: Jest testing best practices and patterns for unit tests
globs: *.test.ts,*.test.tsx
alwaysApply: false
---
# Jest Testing Best Practices

This guide covers testing patterns and best practices for Jest and React Testing Library in the Wonder Blocks codebase.

## Core Testing Principles

### ⚠️ Critical Setup Rules

**Test Workflow Priority:**
- ✅ **ALWAYS fix failing tests BEFORE fixing linting errors**
- ✅ **Focus on underlying errors, not `Unhandled console.error call` messages**
- ⚠️ When tests fail with `Unhandled console.error call`, look for the **root cause error** (e.g., `ReferenceError: window is not defined`)
- ⚠️ The console.error messages are symptoms, not the actual problem - fix the underlying issue

**File Structure:**
- ✅ Name test files with `.test.ts` or `.test.tsx` suffix
- ✅ Place in `__tests__/` directory OR colocate with source files (follow local conventions)

**Test Framework Setup:**
- ✅ Additional matchers from React Testing Library (RTL) and `jest-extended` are available
- ✅ Use `describe`/`it` pattern for test organization
- ✅ Use `globalThis` prefix when accessing global objects
- ✅ **Prioritize testing non-trivial business logic** over trivial implementations

### Arrange-Act-Assert Pattern

**⚠️ ALWAYS use this three-section structure:**

```typescript
describe("Calculator", () => {
    it("should add two numbers correctly", () => {
        // Arrange
        const a = 5;
        const b = 3;

        // Act
        const result = add(a, b);

        // Assert
        expect(result).toBe(8);
    });
});
```

**Rules:**
- ✅ **ALWAYS divide tests** into Arrange, Act, Assert sections with comments
- ✅ **ALWAYS use separate comments** for each section (`// Arrange`, `// Act`, `// Assert`)
- ❌ **NEVER combine sections** (e.g., don't write `// Act & Assert`)
- ❌ **NEVER use multiple Act or Assert sections** in a single test (split into separate tests instead)

**Exception - Testing Thrown Errors:**

When testing errors, use an `underTest` variable in the Act section:

```typescript
it("should throw an error when input is invalid", () => {
    // Arrange
    const invalidInput = "invalid";

    // Act
    const underTest = () => {
        processInput(invalidInput);
    };

    // Assert
    expect(underTest).toThrow("Invalid input");
});
```

### Be Concise and Avoid Over-Testing

**⚠️ Focus on what matters - don't overdo it:**

**DO Test:**
- ✅ **Non-trivial business logic** - Complex calculations, data transformations, validation rules
- ✅ **User interactions** - Click handlers, form submissions, keyboard navigation
- ✅ **Accessibility** - ARIA attributes, keyboard support, focus management
- ✅ **Edge cases and error conditions** - Null values, empty states, error handling
- ✅ **Integration points** - API calls, event callbacks, state changes

**DON'T Test:**
- ❌ **Trivial implementations** - Simple getters/setters, pass-through functions
- ❌ **Style-only props** - Visual appearance is covered by visual regression tests in Storybook
- ❌ **Third-party libraries** - Assume they work; test your usage of them
- ❌ **Implementation details** - Internal state that doesn't affect output/behavior

```typescript
// ❌ DON'T: Testing style-only props (use visual regression tests instead)
it("should apply primary color when kind is primary", () => {
    render(<Button kind="primary" />);
    expect(screen.getByRole("button")).toHaveStyle({ backgroundColor: "blue" });
});

// ✅ DO: Test meaningful behavior
it("should call onClick when clicked", async () => {
    // Arrange
    const handleClick = jest.fn();
    render(<Button onClick={handleClick}>Click me</Button>);

    // Act
    await userEvent.click(screen.getByRole("button"));

    // Assert
    expect(handleClick).toHaveBeenCalledTimes(1);
});

// ✅ DO: Test non-trivial logic
it("should validate email format and return error message", () => {
    // Arrange
    const invalidEmail = "not-an-email";

    // Act
    const result = validateEmail(invalidEmail);

    // Assert
    expect(result).toBe("Please enter a valid email address");
});
```

**Key Principles:**
- ✅ **Test behavior, not implementation** - Focus on what the component does, not how
- ✅ **Prioritize critical paths** - Test the most important user flows first
- ✅ **Keep tests simple and readable** - Each test should have a clear, single purpose
- ✅ **Use visual regression tests for styling** - Storybook snapshot tests handle visual appearance
- ✅ **Balance coverage with maintainability** - More tests ≠ better tests

### Assertions

**Best Practices:**
- ✅ **Use specific matchers** when possible (e.g., `toBe`, `toEqual`, `toHaveBeenCalledWith`)
- ✅ **Use `.toMatchInlineSnapshot()`** for complex output validation (auto-updates)
- ✅ **Prefer explicit assertions** over implicit ones
- ✅ Use semantic matchers from RTL: `toBeInTheDocument()`, `toBeVisible()`, `toHaveAttribute()`

### One Expect Per Test

**⚠️ Prefer a single assertion per test when possible:**

```typescript
// ✅ DO: Single assertion per test
it("should have the correct role", () => {
    // Arrange
    render(<Button>Click me</Button>);

    // Act
    const button = screen.getByRole("button");

    // Assert
    expect(button).toBeInTheDocument();
});

it("should have the correct text", () => {
    // Arrange
    render(<Button>Click me</Button>);

    // Act
    const button = screen.getByRole("button");

    // Assert
    expect(button).toHaveTextContent("Click me");
});
```

**Key Principle:** If assertions test different behaviors or could fail independently, split them into separate tests. This makes test failures clearer and easier to debug.

### Parameterized Tests with `it.each`

**When to use:** Testing the same logic with multiple input/output combinations

**✅ DO: Use `it.each` for data-driven tests**

```typescript
describe("Calculator", () => {
    it.each([
        [2, 3, 5],
        [0, 0, 0],
        [-1, 1, 0],
        [10, -5, 5],
    ])("should add %i and %i to equal %i", (a, b, expected) => {
        // Arrange & Act
        const result = add(a, b);

        // Assert
        expect(result).toBe(expected);
    });
});
```

**Benefits:**
- ✅ **Reduces Duplication**: Test same logic with different inputs
- ✅ **Clear Test Names**: Each test shows specific values being tested
- ✅ **Easy to Extend**: Simply add new arrays to test data
- ✅ **Better Coverage**: Test edge cases and boundary conditions efficiently
- ✅ **Comprehensive Testing**: Essential for testing all prop combinations and states in Wonder Blocks components

#### Alternative Syntax

```typescript
it.each`
    a    | b    | expected
    ${2} | ${3} | ${5}
    ${0} | ${0} | ${0}
    ${-1} | ${1} | ${0}
    `("should add $a and $b to equal $expected", ({ a, b, expected }) => {
    const result = add(a, b);
    expect(result).toBe(expected);
});
```

## Mocking and Spying

### ⚠️ Critical Rules - ALWAYS Follow These

1. **NEVER mock `console.error`** - This hides real implementation issues and errors
2. **ALWAYS use `jest.spyOn()` to create spies** - Never treat the original function as though it were a spy
3. **Store spy return values in variables ONLY when asserting on them** - Avoids unused variable linter errors
4. **NEVER mock outside of tests** - Even if it means code duplication, keep mocks inside test cases

### Method Spying - Correct Pattern

**✅ DO: Use jest.spyOn and store the result when asserting**

```typescript
import * as SomeFile from "./some-file.ts";

describe("MyComponent", () => {
    it("should call someMethod with correct args", () => {
        // Arrange
        // Store spy because we'll assert on it later
        const spy = jest.spyOn(SomeFile, "someMethod").mockReturnValue(mockValue);

        // Act
        myFunction();

        // Assert
        expect(spy).toHaveBeenCalledWith(expectedArgs);
    });
});
```

**❌ DON'T: Treat the original function as a spy without jest.spyOn()**

```typescript
// ❌ WRONG - This will fail because someMethod is not a spy
import * as SomeFile from "./some-file.ts";

describe("MyComponent", () => {
    it("should call someMethod", () => {
        // Act
        myFunction();

        // Assert
        expect(SomeFile.someMethod).toHaveBeenCalled(); // ❌ ERROR! Not a spy
    });
});
```

### When to Store Spies in Variables

**Spies serve two purposes:**
1. **Mocking behavior** - Replace function implementation or return value
2. **Verification** - Assert the function was called with correct arguments

**✅ Mocking only (no variable needed):**

```typescript
it("should process user data", () => {
    // Arrange
    // Mock the API call to return test data, but don't store it
    jest.spyOn(API, "fetchUser").mockResolvedValue(mockUserData);

    // Act
    const result = processUserProfile();

    // Assert
    // We're testing processUserProfile's logic, not that fetchUser was called
    expect(result.displayName).toBe("John Doe");
    // No spy variable = no unused variable linter error
});
```

**✅ Mocking AND verification (store in variable):**

```typescript
it("should call analytics when button is clicked", () => {
    // Arrange
    // Store the spy because we'll assert on it
    const trackEventSpy = jest
        .spyOn(Analytics, "trackEvent")
        .mockReturnValue(undefined);

    // Act
    userEvent.click(screen.getByRole("button"));

    // Assert
    // We're testing that the analytics call happens correctly
    expect(trackEventSpy).toHaveBeenCalledWith("button_click", {
        buttonId: "submit",
    });
});
```

**Key point:** Only store the spy in a variable if you're going to assert on it. This avoids unused variable linter errors while still allowing you to verify calls when needed.

### Common Spy Patterns

**Mock only (no variable):**

```typescript
// When you only need to control the return value
jest.spyOn(module, "functionName").mockReturnValue(mockValue);
jest.spyOn(module, "asyncFunction").mockResolvedValue(mockValue);
jest.spyOn(module, "asyncFunction").mockRejectedValue(new Error("Test error"));
```

**Mock and verify (store in variable):**

```typescript
// When you need to assert the spy was called
const spy = jest.spyOn(module, "functionName").mockReturnValue(mockValue);
// ... later in Assert section:
expect(spy).toHaveBeenCalledWith(expectedArgs);
```

**Spy with mock implementation:**

```typescript
// Store only if you'll verify it was called
const spy = jest.spyOn(module, "functionName").mockImplementation((arg) => {
    return processedValue;
});
```

### Mocking Guidelines

**DO:**
- ✅ Use `jest.spyOn()` for mocking functions and tracking calls
- ✅ Store spy return values in variables ONLY when you need to assert on them
- ✅ Chain `.mockReturnValue()` or similar directly on `jest.spyOn()` when only mocking behavior
- ✅ Keep mocks and spies inside test cases when possible
- ✅ Use mocking and spies to isolate the code under test at boundaries with other code
- ✅ Clean up spies after tests (Jest does this automatically with `clearAllMocks`)

**DON'T:**
- ❌ Never mock `console.error` - this hides real implementation issues
- ❌ Never treat original functions as spies without `jest.spyOn()`
- ❌ Never store spies in variables if you won't assert on them (causes unused variable linter errors)
- ❌ Never use `jest.spyOn()` to mock `khanFetch` - use `setKhanFetchOverride` instead (see HTTP/API Mocking section)
- ❌ Avoid mocking outside of tests, even if it means code duplication
- ❌ Avoid using `withVariables` and `withContext` unless exact variable/context matches are absolutely necessary (leads to brittle tests)

### File System Mocking

**When to use each approach:**

**✅ Simple file operations: Use `jest.spyOn` on `fs` module**

```typescript
import * as FS from "fs";

describe("File operations", () => {
    it("should read file", () => {
        // Arrange
        const readFileSyncSpy = jest
            .spyOn(FS, "readFileSync")
            .mockReturnValue("file contents");

        // Act
        const result = myFileReader("path/to/file");

        // Assert
        expect(readFileSyncSpy).toHaveBeenCalledWith("path/to/file", "utf-8");
    });
});
```

**✅ Complex file operations: Use `memfs` for in-memory filesystem**

```typescript
// At the top of test file - mock entire fs modules
jest.mock("node:fs", () => jest.requireActual("memfs").fs);
jest.mock("node:fs/promises", () => jest.requireActual("memfs").fs.promises);

// Now you can read/write files in tests without touching real filesystem
```

**When to use which:**
- ✅ **Use spies** for 1-2 simple fs calls (read/write/exists)
- ✅ **Use memfs** when testing complex file operations, directory structures, or multiple files

### Hook Testing

**✅ Use `renderHook`:**

```typescript
import {renderHook} from "@testing-library/react";

// Direct for simple hooks
const {result} = renderHook(() => useMyHook(params));
```

### User Interactions

**✅ ALWAYS use `userEvent` for interactions:**

```typescript
import userEvent from "@testing-library/user-event";

// ✅ DO: Use userEvent (realistic, includes focus/blur/typing)
await userEvent.click(screen.getByRole("button"));
await userEvent.type(screen.getByRole("textbox"), "hello");

// ❌ DON'T: Use fireEvent (low-level, less realistic)
fireEvent.click(button);
```

### Element Selection

**Query priority (use in this order):**

1. ✅ **Semantic queries** (best): `getByRole`, `getByLabelText`, `getByText`
2. ✅ **Test IDs** (fallback): `getByTestId` with `data-testid` attribute
3. ❌ **NEVER use** CSS classes, IDs, or structural selectors (brittle)

```typescript
// ✅ DO: Semantic queries
screen.getByRole("button", {name: /submit/i});
screen.getByLabelText("Email address");
screen.findByText("Welcome back");

// ✅ DO: Test IDs when semantic queries don't work
screen.getByTestId("custom-widget");

// ❌ DON'T: CSS selectors or implementation details
container.querySelector(".my-class");
container.querySelector("#my-id");
```

## Wonder Blocks Component Testing

### Test Organization

**✅ Group related tests together using `describe` blocks:**

When writing jest unit tests for a component, it is helpful to group related tests together. Here is an example structure:

```typescript
describe("MyComponent", () => {
    describe("Props", () => {
        it("should do X when Y prop is set to Z", () => {});

        it.each([
            ["primary", "blue"],
            ["secondary", "gray"],
            ["tertiary", "transparent"],
        ])("should apply %s color when kind is %s", (kind, expectedColor) => {
            // Test implementation
        });
    });

    describe("Event Handlers", () => {
        it("should call onClick prop when clicked", () => {});
        it("should call onChange prop when value changes", () => {});
    });

    describe("Accessibility", () => {
        describe("axe", () => {
            it("should have no a11y violations", async () => {
                // Arrange
                // Act
                const {container} = render(<MyComponent />);

                // Assert
                await expect(container).toHaveNoA11yViolations();
            });

            it("should have no a11y violations when disabled", async () => {});
        });

        describe("ARIA", () => {
            it("should set aria props on the correct element", () => {});
            it("should set aria-disabled when disabled", () => {});
        });

        describe("Focus", () => {
            it("should focus element when autoFocus is true", () => {});
        });

        describe("Keyboard Interactions", () => {
            it("should trigger action when Enter is pressed", () => {});
        });
    });
});
```

### Test Coverage

Unit tests for a component should cover:

#### Base Tests
- ref is forwarded

#### Props
- Cover expected behaviour when certain props are set. **Exclude when the props are related to styles only**, since this should be covered by visual regression tests instead
- Cover expected behaviour with default prop values
- Use `it.each` when there are multiple combinations of things you want to test together

#### Event Handlers
- Check that any event handlers are triggered by the expected conditions
- Verify callbacks are called with correct arguments

#### Accessibility
- Confirm that roles, semantics, and aria attributes are correctly set and wired together
- Use the `.toHaveNoA11yViolations` jest matcher to confirm that a component doesn't have accessibility warnings
- Confirm keyboard interactions and navigation
- Focus management
- Confirm accessible names
- Check for `aria-disabled="true"` for determining disabled state (not the `disabled` attribute)

## Tools and Commands

### Terminal Commands

```bash
# Run all tests
pnpm jest

# Run tests in watch mode
pnpm jest --watch

# Update snapshots
pnpm jest -u

# Run tests with coverage
pnpm jest --coverage

# Run specific test file
pnpm jest path/to/test-file.test.ts

# Debug with verbose output
pnpm jest --verbose --runInBand
```

### Debugging Priority Order

**Terminal Commands**
- Add `console.log` statements for debugging
- Use `--verbose` flag for detailed output
- Use `--runInBand` for sequential execution (easier to debug)
- Use Node debugger with `debugger` statements
