---
description: Jest testing best practices and patterns for unit tests
globs: *.test.ts,*.test.tsx
alwaysApply: false
---
# Jest Testing Best Practices

This guide covers testing patterns and best practices for Jest and React Testing Library in the Khan Academy frontend codebase.

## Core Testing Principles

### ‚ö†Ô∏è Critical Setup Rules

**Test Workflow Priority:**
- ‚úÖ **ALWAYS fix failing tests BEFORE fixing linting errors**
- ‚úÖ **Focus on underlying errors, not `Unhandled console.error call` messages**
- ‚ö†Ô∏è When tests fail with `Unhandled console.error call`, look for the **root cause error** (e.g., `ReferenceError: window is not defined`)
- ‚ö†Ô∏è The console.error messages are symptoms, not the actual problem - fix the underlying issue

**Environment:**
- ‚úÖ Tests run in a **JSDOM environment by default** (includes DOM APIs)
- ‚úÖ Use `@jest-environment node` directive when tests don't need DOM (faster execution)
- ‚ö†Ô∏è If you get `ReferenceError: window is not defined`, **remove** `@jest-environment node` directive
- ‚ö†Ô∏è Only use `@jest-environment node` if the code being tested truly doesn't need browser APIs

```typescript
/**
 * @jest-environment node
 */
```

**File Structure:**
- ‚úÖ Name test files with `.test.ts` or `.test.tsx` suffix
- ‚úÖ Place in `__tests__/` directory OR colocate with source files (follow local conventions)

**Test Framework Setup:**
- ‚úÖ **ALWAYS import** `describe`, `it`, `expect`, `afterEach`, `beforeEach` from `@jest/globals`
- ‚úÖ **NEVER import** `jest` from `@jest/globals` - it's available globally
- ‚úÖ Additional matchers from React Testing Library (RTL) and `jest-extended` are available
- ‚úÖ Use `describe`/`it` pattern for test organization
- ‚úÖ Use `globalThis` prefix when accessing global objects
- ‚úÖ **Prioritize testing non-trivial business logic** over trivial implementations

### Arrange-Act-Assert Pattern

**‚ö†Ô∏è ALWAYS use this three-section structure:**

```typescript
describe("Calculator", () => {
    it("should add two numbers correctly", () => {
        // Arrange
        const a = 5;
        const b = 3;

        // Act
        const result = add(a, b);

        // Assert
        expect(result).toBe(8);
    });
});
```

**Rules:**
- ‚úÖ **ALWAYS divide tests** into Arrange, Act, Assert sections with comments
- ‚úÖ **ALWAYS use separate comments** for each section (`// Arrange`, `// Act`, `// Assert`)
- ‚ùå **NEVER combine sections** (e.g., don't write `// Act & Assert`)
- ‚ùå **NEVER use multiple Act or Assert sections** in a single test (split into separate tests instead)

**Exception - Testing Thrown Errors:**

When testing errors, use an `underTest` variable in the Act section:

```typescript
it("should throw an error when input is invalid", () => {
    // Arrange
    const invalidInput = "invalid";

    // Act
    const underTest = () => {
        processInput(invalidInput);
    };

    // Assert
    expect(underTest).toThrow("Invalid input");
});
```

### Assertions

**Best Practices:**
- ‚úÖ **Use specific matchers** when possible (e.g., `toBe`, `toEqual`, `toHaveBeenCalledWith`)
- ‚úÖ **Use `.toMatchInlineSnapshot()`** for complex output validation (auto-updates)
- ‚úÖ **Prefer explicit assertions** over implicit ones
- ‚úÖ Use semantic matchers from RTL: `toBeInTheDocument()`, `toBeVisible()`, `toHaveAttribute()`

### Parameterized Tests with `it.each`

**When to use:** Testing the same logic with multiple input/output combinations

**‚úÖ DO: Use `it.each` for data-driven tests**

```typescript
describe("Calculator", () => {
    it.each([
        [2, 3, 5],
        [0, 0, 0],
        [-1, 1, 0],
        [10, -5, 5],
    ])("should add %i and %i to equal %i", (a, b, expected) => {
        // Arrange & Act
        const result = add(a, b);

        // Assert
        expect(result).toBe(expected);
    });
});
```

**Benefits:**
- ‚úÖ **Reduces Duplication**: Test same logic with different inputs
- ‚úÖ **Clear Test Names**: Each test shows specific values being tested
- ‚úÖ **Easy to Extend**: Simply add new arrays to test data
- ‚úÖ **Better Coverage**: Test edge cases and boundary conditions efficiently

#### Alternative Syntax

```typescript
it.each`
    a    | b    | expected
    ${2} | ${3} | ${5}
    ${0} | ${0} | ${0}
    ${-1} | ${1} | ${0}
    `("should add $a and $b to equal $expected", ({ a, b, expected }) => {
    const result = add(a, b);
    expect(result).toBe(expected);
});
```

## Mocking and Spying

### ‚ö†Ô∏è Critical Rules - ALWAYS Follow These

1. **NEVER mock `console.error`** - This hides real implementation issues and errors
2. **ALWAYS use `jest.spyOn()` to create spies** - Never treat the original function as though it were a spy
3. **Store spy return values in variables ONLY when asserting on them** - Avoids unused variable linter errors
4. **NEVER mock outside of tests** - Even if it means code duplication, keep mocks inside test cases

### Method Spying - Correct Pattern

**‚úÖ DO: Use jest.spyOn and store the result when asserting**

```typescript
import * as SomeFile from "./some-file.ts";

describe("MyComponent", () => {
    it("should call someMethod with correct args", () => {
        // Arrange
        // Store spy because we'll assert on it later
        const spy = jest.spyOn(SomeFile, "someMethod").mockReturnValue(mockValue);

        // Act
        myFunction();

        // Assert
        expect(spy).toHaveBeenCalledWith(expectedArgs);
    });
});
```

**‚ùå DON'T: Treat the original function as a spy without jest.spyOn()**

```typescript
// ‚ùå WRONG - This will fail because someMethod is not a spy
import * as SomeFile from "./some-file.ts";

describe("MyComponent", () => {
    it("should call someMethod", () => {
        // Act
        myFunction();

        // Assert
        expect(SomeFile.someMethod).toHaveBeenCalled(); // ‚ùå ERROR! Not a spy
    });
});
```

### When to Store Spies in Variables

**Spies serve two purposes:**
1. **Mocking behavior** - Replace function implementation or return value
2. **Verification** - Assert the function was called with correct arguments

**‚úÖ Mocking only (no variable needed):**

```typescript
it("should process user data", () => {
    // Arrange
    // Mock the API call to return test data, but don't store it
    jest.spyOn(API, "fetchUser").mockResolvedValue(mockUserData);

    // Act
    const result = processUserProfile();

    // Assert
    // We're testing processUserProfile's logic, not that fetchUser was called
    expect(result.displayName).toBe("John Doe");
    // No spy variable = no unused variable linter error
});
```

**‚úÖ Mocking AND verification (store in variable):**

```typescript
it("should call analytics when button is clicked", () => {
    // Arrange
    // Store the spy because we'll assert on it
    const trackEventSpy = jest
        .spyOn(Analytics, "trackEvent")
        .mockReturnValue(undefined);

    // Act
    userEvent.click(screen.getByRole("button"));

    // Assert
    // We're testing that the analytics call happens correctly
    expect(trackEventSpy).toHaveBeenCalledWith("button_click", {
        buttonId: "submit",
    });
});
```

**Key point:** Only store the spy in a variable if you're going to assert on it. This avoids unused variable linter errors while still allowing you to verify calls when needed.

### Common Spy Patterns

**Mock only (no variable):**

```typescript
// When you only need to control the return value
jest.spyOn(module, "functionName").mockReturnValue(mockValue);
jest.spyOn(module, "asyncFunction").mockResolvedValue(mockValue);
jest.spyOn(module, "asyncFunction").mockRejectedValue(new Error("Test error"));
```

**Mock and verify (store in variable):**

```typescript
// When you need to assert the spy was called
const spy = jest.spyOn(module, "functionName").mockReturnValue(mockValue);
// ... later in Assert section:
expect(spy).toHaveBeenCalledWith(expectedArgs);
```

**Spy with mock implementation:**

```typescript
// Store only if you'll verify it was called
const spy = jest.spyOn(module, "functionName").mockImplementation((arg) => {
    return processedValue;
});
```

### Mocking Guidelines

**DO:**
- ‚úÖ Use `jest.spyOn()` for mocking functions and tracking calls
- ‚úÖ Store spy return values in variables ONLY when you need to assert on them
- ‚úÖ Chain `.mockReturnValue()` or similar directly on `jest.spyOn()` when only mocking behavior
- ‚úÖ Keep mocks and spies inside test cases when possible
- ‚úÖ Use `matchGql` when specifying GraphQL operations for better type safety
- ‚úÖ Use mocking and spies to isolate the code under test at boundaries with other code
- ‚úÖ Clean up spies after tests (Jest does this automatically with `clearAllMocks`)

**DON'T:**
- ‚ùå Never mock `console.error` - this hides real implementation issues
- ‚ùå Never treat original functions as spies without `jest.spyOn()`
- ‚ùå Never store spies in variables if you won't assert on them (causes unused variable linter errors)
- ‚ùå Never use `jest.spyOn()` to mock `khanFetch` - use `setKhanFetchOverride` instead (see HTTP/API Mocking section)
- ‚ùå Avoid mocking outside of tests, even if it means code duplication
- ‚ùå Avoid using `withVariables` and `withContext` unless exact variable/context matches are absolutely necessary (leads to brittle tests)

### File System Mocking

**When to use each approach:**

**‚úÖ Simple file operations: Use `jest.spyOn` on `fs` module**

```typescript
import * as FS from "fs";

describe("File operations", () => {
    it("should read file", () => {
        // Arrange
        const readFileSyncSpy = jest
            .spyOn(FS, "readFileSync")
            .mockReturnValue("file contents");

        // Act
        const result = myFileReader("path/to/file");

        // Assert
        expect(readFileSyncSpy).toHaveBeenCalledWith("path/to/file", "utf-8");
    });
});
```

**‚úÖ Complex file operations: Use `memfs` for in-memory filesystem**

```typescript
// At the top of test file - mock entire fs modules
jest.mock("node:fs", () => jest.requireActual("memfs").fs);
jest.mock("node:fs/promises", () => jest.requireActual("memfs").fs.promises);

// Now you can read/write files in tests without touching real filesystem
```

**When to use which:**
- ‚úÖ **Use spies** for 1-2 simple fs calls (read/write/exists)
- ‚úÖ **Use memfs** when testing complex file operations, directory structures, or multiple files

### HTTP/API Mocking with khanFetch

**‚ö†Ô∏è CRITICAL: Never use `jest.spyOn()` to mock `khanFetch` - use `setKhanFetchOverride` instead**

When testing code that makes HTTP requests using `khanFetch`, **ALWAYS use `setKhanFetchOverride` with `mockKhanFetch()`**.

**‚úÖ DO: Use `setKhanFetchOverride` with `mockKhanFetch()`**

```typescript
import {setKhanFetchOverride} from "@khan/data-fetch";
import {mockKhanFetch} from "@khan/testing-fetch";
import {RespondWith} from "@khanacademy/wonder-blocks-testing";

describe("API calls", () => {
    it("should fetch user data", async () => {
        // Arrange
        const mockUserData = {id: "123", name: "Test User", email: "test@example.com"};
        setKhanFetchOverride(
            mockKhanFetch().mockRequest(
                "/api/internal/users/123",
                RespondWith.json(mockUserData),
            ),
        );

        // Act
        const result = await fetchUserProfile("123");

        // Assert
        expect(result).toEqual(mockUserData);
    });

    it("should handle API errors", async () => {
        // Arrange
        setKhanFetchOverride(
            mockKhanFetch().mockRequest(
                "/api/internal/users/123",
                RespondWith.errorStatusCode(500),
            ),
        );

        // Act
        const underTest = fetchUserProfile("123");

        // Assert
        await expect(underTest).toReject();
    });
});
```

**‚úÖ Use regex patterns for dynamic URLs:**

```typescript
it("should poll notifications endpoint", async () => {
    // Arrange
    setKhanFetchOverride(
        mockKhanFetch().mockRequest(
            new RegExp(`/api/internal/_notifications/real-time-messaging.+$`),
            RespondWith.json({
                type: "messages",
                messages: [],
                timestamp: "1234",
            }),
        ),
    );

    // Act
    await poller.poll();

    // Assert - verify polling completed successfully
    expect(poller.lastTimestamp).toEqual("1234");
});
```

**‚úÖ Verify fetch was called with correct URL (optional):**

```typescript
import * as KhanFetch from "@khan/data-fetch";

it("should call API with correct parameters", async () => {
    // Arrange
    setKhanFetchOverride(
        mockKhanFetch().mockRequest(
            new RegExp("/api/internal/data.+$"),
            RespondWith.json({success: true}),
        ),
    );
    const fetchSpy = jest.spyOn(KhanFetch, "khanFetch");

    // Act
    await fetchData({channel: "test-channel", since: 0});

    // Assert
    expect(fetchSpy).toHaveBeenCalledWith(
        "/api/internal/data?channel=test-channel&since=0"
    );
});
```

**‚úÖ Mock multiple endpoints:**

```typescript
it("should handle multiple API calls", async () => {
    // Arrange
    setKhanFetchOverride(
        mockKhanFetch()
            .mockRequest("/api/internal/users", RespondWith.json({users: []}))
            .mockRequest("/api/internal/settings", RespondWith.json({theme: "dark"})),
    );

    // Act
    const [users, settings] = await Promise.all([
        fetchUsers(),
        fetchSettings(),
    ]);

    // Assert
    expect(users).toEqual({users: []});
    expect(settings).toEqual({theme: "dark"});
});
```

**‚ùå DON'T: Use `jest.spyOn` to mock khanFetch**

```typescript
// ‚ùå WRONG - This won't work reliably with khanFetch
import * as FetchModule from "@khan/data-fetch";

describe("API calls", () => {
    it("should fetch user data", async () => {
        // ‚ùå This approach doesn't work properly with khanFetch
        jest.spyOn(FetchModule, "khanFetch").mockResolvedValue(mockResponse);
        // ...
    });
});
```

**Why `setKhanFetchOverride`?**
- ‚úÖ Provides stable, type-safe API for mocking HTTP requests
- ‚úÖ Works consistently regardless of how `khanFetch` is imported
- ‚úÖ Supports URL pattern matching with strings or regex
- ‚úÖ Integrates with `RespondWith` helpers from Wonder Blocks testing
- ‚úÖ Can mock multiple endpoints by chaining `.mockRequest()` calls
- ‚úÖ Can still spy on `khanFetch` to verify it was called with correct URLs
- ‚úÖ Clear overrides in `afterEach` if needed, or rely on test isolation

### Mocking InitialRequestUrl

**‚ö†Ô∏è CRITICAL: Use `resetInitialLocation()` instead of module mocking**

When testing code that accesses `InitialRequestUrl` (e.g., `InitialRequestUrl.origin`, `InitialRequestUrl.hostname`, `InitialRequestUrl.configParams`), **ALWAYS use `resetInitialLocation()` from `@khan/shared-core`**.

**‚úÖ DO: Use `resetInitialLocation()` in `beforeEach`**

```typescript
import {resetInitialLocation} from "@khan/shared-core";

describe("MyComponent", () => {
    beforeEach(() => {
        // Set up initial location with a complete URL
        resetInitialLocation("https://www.khanacademy.org/");
        // ... other setup
    });

    it("should use the correct origin", () => {
        // Arrange
        // InitialRequestUrl is now set up properly

        // Act
        const result = myFunction();

        // Assert
        expect(result).toContain("https://www.khanacademy.org");
    });
});
```

**‚úÖ Set URL with query params when needed:**

```typescript
beforeEach(() => {
    // All configParams (lang, country, region, etc.) are automatically parsed
    resetInitialLocation("https://www.khanacademy.org/?lang=es&country=MX");
});
```

**‚úÖ Use `jest.spyOn()` for individual properties when needed:**

```typescript
it("should handle different origins", () => {
    // Arrange
    // Override specific properties for this test only
    jest.spyOn(InitialRequestUrl, "origin", "get").mockReturnValue(
        "https://www.khanacademy.dev",
    );

    // Act
    const result = myFunction();

    // Assert
    expect(result).toContain("khanacademy.dev");
});
```

**‚ùå DON'T: Mock the entire `@khan/shared-core` module**

```typescript
// ‚ùå WRONG - Brittle, hard to maintain, and requires listing all properties
jest.mock("@khan/shared-core", () => ({
    ...jest.requireActual("@khan/shared-core"),
    InitialRequestUrl: {
        href: "https://www.khanacademy.org/",
        pathname: "/",
        origin: "https://www.khanacademy.org",
        // ... many more properties to define manually
        configParams: {
            curriculum: "",
            country: "",
            // ... many more to define
        },
    },
}));
```

**Why `resetInitialLocation`?**
- ‚úÖ Uses the real implementation, not a mock
- ‚úÖ All properties and getters work naturally
- ‚úÖ No need to manually define configParams structure
- ‚úÖ More maintainable - works even if new properties are added
- ‚úÖ Automatically cleaned up by Jest's global `afterEach` hook
- ‚úÖ Works in JSDOM environment (the default)

**Note:** This requires **not** using `@jest-environment node` in your test file. If you need the Node environment for other reasons, use `jest.spyOn()` to mock individual properties instead.

## Component Testing

### Test Harness Setup

**‚úÖ ALWAYS use `withTestHarness` for component tests:**

```typescript
import {withTestHarness} from "~/testing/with-test-harness.ts";

const HarnessedComponent = withTestHarness(MyComponent, {
    gql: (mockGqlFetch) => mockGqlFetch.mockOperationOnce(...),
    router: "/dashboard",
});
```

**Common adapters (configure only what you need):**
- `gql`: GraphQL operations (queries/mutations)
- `router`: URL/routing state and navigation
- `growthbook`: Feature flags
- `lingui`: Internationalization (i18n)

### Hook Testing

**‚úÖ Use `hookTestHarness` or `renderHook`:**

```typescript
import {hookTestHarness} from "~/testing/with-test-harness.ts";
import {renderHook} from "@testing-library/react";

// With test harness for hooks needing context
const {result} = hookTestHarness(useMyHook, {router: "/path"});

// Direct for simple hooks
const {result} = renderHook(() => useMyHook(params));
```

### User Interactions

**‚úÖ ALWAYS use `userEvent` for interactions:**

```typescript
import userEvent from "@testing-library/user-event";

// ‚úÖ DO: Use userEvent (realistic, includes focus/blur/typing)
await userEvent.click(screen.getByRole("button"));
await userEvent.type(screen.getByRole("textbox"), "hello");

// ‚ùå DON'T: Use fireEvent (low-level, less realistic)
fireEvent.click(button);
```

### Element Selection

**Query priority (use in this order):**

1. ‚úÖ **Semantic queries** (best): `getByRole`, `getByLabelText`, `getByText`
2. ‚úÖ **Test IDs** (fallback): `getByTestId` with `data-testid` attribute
3. ‚ùå **NEVER use** CSS classes, IDs, or structural selectors (brittle)

```typescript
// ‚úÖ DO: Semantic queries
screen.getByRole("button", {name: /submit/i});
screen.getByLabelText("Email address");
screen.findByText("Welcome back");

// ‚úÖ DO: Test IDs when semantic queries don't work
screen.getByTestId("custom-widget");

// ‚ùå DON'T: CSS selectors or implementation details
container.querySelector(".my-class");
container.querySelector("#my-id");
```

## Wonder Blocks Component Testing

### Accessibility Testing

**‚úÖ ALWAYS test accessibility features:**

```typescript
// Check disabled state
expect(button).toHaveAttribute("aria-disabled", "true");

// Verify ARIA labels
expect(dialog).toHaveAttribute("aria-labelledby", "dialog-title");

// Test keyboard navigation
await userEvent.tab();
expect(screen.getByRole("button")).toHaveFocus();
```

**Required accessibility tests:**
- ‚úÖ Disabled states with `aria-disabled`
- ‚úÖ Keyboard navigation and focus management
- ‚úÖ ARIA attributes and roles
- ‚úÖ Screen reader labels

### MultiSelect Testing

**‚úÖ Test selection states:**
- ‚úÖ **Multiple selections**: Select at least 2 items when testing multi-select mode
- ‚úÖ **Single selection**: Test single-item selection
- ‚úÖ **Empty state**: Test with no selections
- ‚úÖ **All selected**: Test maximum selection scenarios

## GraphQL Testing

**‚ö†Ô∏è When to use:** Component uses any of these GraphQL symbols:

```typescript
// Hooks
useQuery, useMutation, useGql, useApolloGqlClient

// HOCs (legacy)
withApollo, withApolloQuery, withApolloMutation

// Components (legacy)
ApolloQuery, ApolloMutation
```

### Test Harness Integration

**‚úÖ ALWAYS use the `gql` adapter:**

```typescript
import {matchGql} from "~/testing/gql/match-gql.ts";
import {RespondWith} from "@khanacademy/wonder-blocks-testing";

const HarnessedComponent = withTestHarness(MyComponent, {
    gql: (mockGqlFetch) =>
        mockGqlFetch.mockOperationOnce(
            matchGql(DATA_QUERY),
            RespondWith.graphQLData(mockData),
        ),
});
```

### Mock Data Guidelines

**‚ö†Ô∏è Critical TypeScript Rules:**

```typescript
// ‚úÖ DO: Add "as const" for __typename
const mockUser = {
    __typename: "User" as const,  // Required!
    id: "user-123",
    name: "Test User",
};

// ‚úÖ DO: Add "as const" for enums
const mockStatus = {
    status: "ACTIVE" as const,  // Required for enum values
};

// ‚úÖ DO: Use RespondWith.reject for errors
mockGqlFetch.mockOperationOnce(
    matchGql(QUERY),
    RespondWith.reject(new Error("Network error"))
);
```

**Mock data checklist:**
- ‚úÖ **ALWAYS add** `as const` after `__typename` string literals
- ‚úÖ **ALWAYS add** `as const` after enum values
- ‚úÖ **ALWAYS match** the GraphQL schema structure
- ‚úÖ Use `RespondWith.reject` for network/GraphQL errors
- ‚úÖ Use fragments for reusable mock data across tests

### Example: Using the `gql` Adapter

Here's an example of testing a component that uses GraphQL:

```typescript
import {render, screen} from "@testing-library/react";
import {RespondWith} from "@khanacademy/wonder-blocks-testing";

import {withTestHarness} from "~/testing/with-test-harness.ts";

import UserProfile from "./user-profile.tsx";
import {GET_USER_QUERY} from "./queries.ts";

describe("UserProfile", () => {
    it("should display user information when query succeeds", async () => {
        // Arrange
        const mockUserData = {
            user: {
                __typename: "User" as const,
                id: "user-123",
                name: "John Doe",
                email: "john@example.com",
            },
        };

        const HarnessedComponent = withTestHarness(UserProfile, {
            gql: (mockGqlFetch: GqlFetchMockFn) =>
                mockGqlFetch.mockOperationOnce(
                    matchGql(DATA_QUERY),
                    RespondWith.graphQLData(mockUserData),
                ),
        });

        // Act
        render(<HarnessedComponent userId="user-123" />);

        // Assert
        await screen.findByText("John Doe");
        expect(screen.getByText("john@example.com")).toBeInTheDocument();
    });
});
```

## Error Handling Testing

### Error Scenarios

**‚úÖ ALWAYS test these error conditions:**

```typescript
// ‚úÖ Test error states
it("should display error message when API fails", async () => {
    // Arrange
    jest.spyOn(API, "fetchData").mockRejectedValue(new Error("API Error"));

    // Act
    render(<Component />);

    // Assert
    expect(await screen.findByText(/something went wrong/i)).toBeInTheDocument();
});

// ‚úÖ Test error boundaries
it("should catch render errors in ErrorBoundary", () => {
    // Arrange
    const ThrowError = () => { throw new Error("Test error"); };

    // Act
    render(
        <ErrorBoundary>
            <ThrowError />
        </ErrorBoundary>
    );

    // Assert
    expect(screen.getByText(/error occurred/i)).toBeInTheDocument();
});
```

**Error testing checklist:**
- ‚úÖ Test error states and error boundaries
- ‚úÖ Verify error messages are user-friendly
- ‚úÖ Test recovery from error states (retry, dismiss)
- ‚úÖ Ensure errors are logged properly

### Async Error Testing

**‚úÖ Use `waitFor` for async error states:**

```typescript
it("should handle async errors", async () => {
    // Arrange
    jest.spyOn(API, "fetch").mockRejectedValue(new Error("Failed"));

    // Act
    render(<AsyncComponent />);

    // Assert - Wait for loading ‚Üí error transition
    await waitFor(() => {
        expect(screen.queryByRole("progressbar")).not.toBeInTheDocument();
    });
    expect(screen.getByText(/error/i)).toBeInTheDocument();
});
```

**Async error checklist:**
- ‚úÖ Test rejected promises and async errors
- ‚úÖ Use `waitFor` for asynchronous state changes
- ‚úÖ Verify loading ‚Üí error state transitions
- ‚úÖ Test error recovery mechanisms

## Performance Testing

### Test Performance Best Practices

**‚úÖ Keep tests fast:**

```typescript
// ‚úÖ DO: Mock expensive operations
jest.spyOn(API, "slowOperation").mockResolvedValue(result);

// ‚úÖ DO: Use node environment when possible (faster)
/**
 * @jest-environment node
 */

// ‚ö†Ô∏è ONLY use timeout when absolutely necessary
jest.setTimeout(10000); // With clear justification
```

**Performance checklist:**
- ‚úÖ **Keep tests fast and focused** (< 100ms per test ideal)
- ‚úÖ **Mock expensive operations** (API calls, file I/O, timers)
- ‚úÖ **Use `node` environment** when DOM is not needed
- ‚ö†Ô∏è **Use `jest.setTimeout()` sparingly** and document why
- ‚úÖ **Use `jest.isolateModules()`** for module isolation when needed

**When to increase timeout:**
- Complex integration tests with multiple async operations
- Tests involving animations or transitions (prefer mocking instead)
- Tests with unavoidable network delays (prefer mocking instead)

## Tools and Commands

### ‚ö†Ô∏è PRIMARY TOOL: Wallaby.js

**CRITICAL: ALWAYS attempt to use Wallaby MCP tools first when debugging tests**

Wallaby provides **superior debugging capabilities**:
- ‚úÖ **Real-time test results** without manual execution
- ‚úÖ **Runtime values** at any line during test execution
- ‚úÖ **Code coverage** per test or file
- ‚úÖ **Error diagnostics** with full stack traces and context
- ‚úÖ **Snapshot updates** programmatically

### Using Wallaby MCP Tools

**Step 1: Check if Wallaby is Running**

When working with tests, **ALWAYS try Wallaby tools first**:

```typescript
// Available Wallaby MCP tools:
mcp_wallaby_wallaby_allTests              // All tests in project
mcp_wallaby_wallaby_failingTests          // All failing tests
mcp_wallaby_wallaby_allTestsForFile       // Tests for specific file
mcp_wallaby_wallaby_failingTestsForFile   // Failing tests for specific file
mcp_wallaby_wallaby_runtimeValues         // Runtime values at specific line
mcp_wallaby_wallaby_coveredLinesForFile   // Code coverage for file
mcp_wallaby_wallaby_updateTestSnapshots   // Update failing snapshots
```

**Step 2: If Wallaby Tools Fail**

Ask the user to start Wallaby:

> "Could you start Wallaby for `path/to/test-file.test.ts`? This will give me access to runtime values and test execution details."

**Step 3: Use Wallaby Extensively**

Once running, use Wallaby for:
- ‚úÖ **Debugging failures**: Get actual runtime values at failure points
- ‚úÖ **Understanding coverage**: See which tests cover which code
- ‚úÖ **Viewing results**: Get detailed errors with full context
- ‚úÖ **Fixing snapshots**: Update programmatically without terminal commands

### Wallaby Debugging Workflow

**Example: Debugging a failing test**

```typescript
// 1. Get failing tests for the file you're working on
const failingTests = await mcp_wallaby_wallaby_failingTestsForFile({
    file: "src/component.test.ts"
});

// 2. Get runtime values at the failure point
const runtimeValues = await mcp_wallaby_wallaby_runtimeValues({
    file: "src/component.test.ts",
    line: 45,
    lineContent: "expect(result).toBe(expected);",
    expression: "result"  // See what 'result' actually is
});

// 3. Check what code is covered by this test
const coverage = await mcp_wallaby_wallaby_coveredLinesForFile({
    file: "src/component.ts"
});

// 4. Update snapshots if they need updating
await mcp_wallaby_wallaby_updateTestSnapshots({
    testId: "test-id-from-failing-tests"
});
```

**Why Wallaby is better than terminal commands:**
- ‚úÖ See **actual runtime values** without adding console.logs
- ‚úÖ Get **instant feedback** without re-running tests
- ‚úÖ Understand **exact coverage** per test
- ‚úÖ Update snapshots **programmatically** with context

### Fallback: Terminal Commands

**‚ö†Ô∏è Only use when Wallaby is NOT available**

```bash
# Run all tests
pnpm jest

# Run tests in watch mode
pnpm jest --watch

# Update snapshots
pnpm jest -u

# Run tests with coverage
pnpm jest --coverage

# Run specific test file
pnpm jest path/to/test-file.test.ts

# Debug with verbose output
pnpm jest --verbose --runInBand
```

### Debugging Priority Order

**ü•á FIRST: Try Wallaby MCP Tools**
- ‚úÖ Get runtime values at any line
- ‚úÖ View test execution context in real-time
- ‚úÖ Access detailed error information instantly
- ‚úÖ See code coverage per test
- ‚úÖ No need to modify code or re-run tests

**ü•à SECOND: Terminal Commands** (only if Wallaby unavailable)
- Add `console.log` statements for debugging
- Use `--verbose` flag for detailed output
- Use `--runInBand` for sequential execution (easier to debug)
- Use Node debugger with `debugger` statements

**Why Wallaby First?**
- ‚ùå Terminal: Requires adding console.logs, re-running, cleaning up
- ‚úÖ Wallaby: Instantly see values without code changes
- ‚ùå Terminal: Only see what you explicitly log
- ‚úÖ Wallaby: Inspect any variable at any line
- ‚ùå Terminal: Have to re-run after each change
- ‚úÖ Wallaby: Real-time feedback as you type
