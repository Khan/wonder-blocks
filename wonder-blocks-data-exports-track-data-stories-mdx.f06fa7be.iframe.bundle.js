"use strict";(self.webpackChunkwonder_blocks=self.webpackChunkwonder_blocks||[]).push([[4675],{"./__docs__/wonder-blocks-data/exports.track-data.stories.mdx":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,{__page:()=>__page,default:()=>__WEBPACK_DEFAULT_EXPORT__});__webpack_require__("./node_modules/react/index.js");var _storybook_addon_essentials_docs_mdx_react_shim__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__("./node_modules/@mdx-js/react/lib/index.js"),_storybook_blocks__WEBPACK_IMPORTED_MODULE_4__=__webpack_require__("./node_modules/@storybook/blocks/dist/index.mjs"),_khanacademy_wonder_blocks_data__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./packages/wonder-blocks-data/dist/es/index.js"),react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__("./node_modules/react/jsx-runtime.js");function _createMdxContent(props){const _components=Object.assign({h1:"h1",p:"p",code:"code",h4:"h4",pre:"pre"},(0,_storybook_addon_essentials_docs_mdx_react_shim__WEBPACK_IMPORTED_MODULE_3__.ah)(),props.components);return(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment,{children:[(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_storybook_blocks__WEBPACK_IMPORTED_MODULE_4__.h_,{title:"Data / Exports / TrackData",component:_khanacademy_wonder_blocks_data__WEBPACK_IMPORTED_MODULE_1__.t6,parameters:{chromatic:{disableSnapshot:!0}}}),"\n",(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_components.h1,{id:"trackdata",children:"TrackData"}),"\n",(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(_components.p,{children:["The ",(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_components.code,{children:"TrackData"})," component is a server-side only component. It should be used as\na parent to the components whose data requests you want to fulfill during\nserver-side rendering."]}),"\n",(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_components.h4,{id:"client-side-behavior",children:"Client-side behavior"}),"\n",(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(_components.p,{children:["If used outside of server-side mode (as set using ",(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_components.code,{children:"Server.setServerSide"}),"), this\ncomponent will throw, as demonstrated below."]}),"\n",(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_components.pre,{children:(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_components.code,{className:"language-jsx",children:'import {Body, BodyMonospace} from "@khanacademy/wonder-blocks-typography";\nimport {Server, View} from "@khanacademy/wonder-blocks-core";\nimport {TrackData} from "@khanacademy/wonder-blocks-data";\n\nclass ErrorBoundary extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = {};\n    }\n\n    static getDerivedStateFromError(error) {\n        return {error: error.message};\n    }\n\n    render() {\n        if (typeof jest !== "undefined") {\n            /**\n             * The snapshot test just sees the error getting thrown, not the\n             * awesome error boundary, so we have to hack around it to keep\n             * this live example, but not get test failures.\n             */\n            return "Sorry, no snapshot for you";\n        }\n\n        if (this.state.error) {\n            return <View>{this.state.error}</View>;\n        }\n        return this.props.children;\n    }\n}\n\n<ErrorBoundary>\n    <View>\n        <TrackData>\n            <Body>\n                This only renders if we\'re in server-side mode and the page hot\n                reloaded\n            </Body>\n        </TrackData>\n    </View>\n</ErrorBoundary>;\n'})}),"\n",(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_components.h4,{id:"server-side-behavior",children:"Server-side behavior"}),"\n",(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(_components.p,{children:["When used server-side, this component tracks any data requests made through\nthe ",(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_components.code,{children:"Data"})," component during a render cycle. This data can then be obtained\nusing the ",(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_components.code,{children:"fetchTrackedRequests"})," method. The data can then be used in an\nadditional render cycle to render with that data."]}),"\n",(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_components.pre,{children:(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_components.code,{className:"language-jsx",children:'import {Body, BodyMonospace} from "@khanacademy/wonder-blocks-typography";\nimport {Strut} from "@khanacademy/wonder-blocks-layout";\nimport Spacing from "@khanacademy/wonder-blocks-spacing";\nimport Button from "@khanacademy/wonder-blocks-button";\nimport {Server, View} from "@khanacademy/wonder-blocks-core";\nimport {\n    Data,\n    TrackData,\n    fetchTrackedRequests,\n} from "@khanacademy/wonder-blocks-data";\n\nconst myPretendHandler = () =>\n    new Promise((resolve, reject) => setTimeout(() => resolve("DATA!"), 3000));\n\nclass Example extends React.Component {\n    constructor() {\n        super();\n        /**\n         * For this demonstration, we need to hack the return of isServerSide solely\n         * for the scope of this component.\n         */\n        this.state = {};\n    }\n\n    static getDerivedStateFromError(error) {\n        return {error};\n    }\n\n    componentDidMount() {\n        this._mounted = true;\n    }\n\n    componentWillUnmount() {\n        this._mounted = false;\n    }\n\n    setClientMode() {\n        window.location.reload();\n    }\n\n    setServerMode() {\n        Server.setServerSide();\n        this.setState({refresh: Date.now(), error: null});\n    }\n\n    _renderErrorOrContent() {\n        if (typeof jest !== "undefined") {\n            /**\n             * The snapshot test just sees the error getting thrown, not the\n             * awesome error boundary, so we have to hack around it to keep\n             * this live example, but not get test failures.\n             */\n            return "Sorry, no snapshot for you";\n        }\n\n        if (this.state.error) {\n            return (\n                <React.Fragment>\n                    <Strut size={Spacing.small_12} />\n                    <Body>\n                        We can\'t show you anything useful in client-side mode\n                    </Body>\n                </React.Fragment>\n            );\n        }\n\n        const data = this.state.data\n            ? JSON.stringify(this.state.data, undefined, "  ")\n            : "Data requested...";\n\n        return (\n            <React.Fragment>\n                <Strut size={Spacing.small_12} />\n                <TrackData>\n                    <Data\n                        handler={myPretendHandler}\n                        requestId="TRACK_DATA_EXAMPLE"\n                    >\n                        {(result) => (\n                            <View>\n                                <BodyMonospace>{`Loading: ${\n                                    result.status === "loading"\n                                }`}</BodyMonospace>\n                                <BodyMonospace>{`Data: ${JSON.stringify(\n                                    result.data,\n                                )}`}</BodyMonospace>\n                            </View>\n                        )}\n                    </Data>\n                </TrackData>\n                <Strut size={Spacing.small_12} />\n                <View>\n                    <Body>\n                        The above components requested data, but we\'re\n                        server-side, so all that happened is we tracked the\n                        request. In this example, we\'ve also called\n                        `fetchTrackedRequests` to fetch that tracked data.\n                    </Body>\n                    <Strut size={Spacing.small_12} />\n                    <Body>\n                        In about 3 seconds, it will appear below. Notice that\n                        when it does, the above still doesn\'t update. That\'s\n                        because during SSR, the data is not updated in the\n                        rendered tree.\n                    </Body>\n                    <Strut size={Spacing.small_12} />\n                    <BodyMonospace>{data}</BodyMonospace>\n                </View>\n            </React.Fragment>\n        );\n    }\n\n    render() {\n        try {\n            return (\n                <View key={this.state.refresh}>\n                    {Server.isServerSide() ? (\n                        <React.Fragment>\n                            <Button\n                                kind={"secondary"}\n                                onClick={() => this.setClientMode()}\n                            >\n                                Back to Client-side Mode (reloads page)\n                            </Button>\n                            <Strut size={Spacing.small_12} />\n                            <Button\n                                kind={"secondary"}\n                                onClick={() => this.setServerMode()}\n                            >\n                                Re-mount\n                            </Button>\n                        </React.Fragment>\n                    ) : (\n                        <Button\n                            kind={"primary"}\n                            onClick={() => this.setServerMode()}\n                        >\n                            Enable Server-side Mode\n                        </Button>\n                    )}\n                    {this._renderErrorOrContent()}\n                </View>\n            );\n        } finally {\n            if (!this.state.data && Server.isServerSide()) {\n                setTimeout(\n                    () =>\n                        fetchTrackedRequests().then((data) => {\n                            if (this._mounted) {\n                                this.setState({data});\n                            }\n                        }),\n                    0,\n                );\n            }\n        }\n    }\n}\n\n<Example />;\n'})})]})}const __page=()=>{throw new Error("Docs-only story")};__page.parameters={docsOnly:!0};const componentMeta={title:"Data / Exports / TrackData",parameters:{chromatic:{disableSnapshot:!0}},component:_khanacademy_wonder_blocks_data__WEBPACK_IMPORTED_MODULE_1__.t6,tags:["stories-mdx"],includeStories:["__page"]};componentMeta.parameters=componentMeta.parameters||{},componentMeta.parameters.docs={...componentMeta.parameters.docs||{},page:function MDXContent(props={}){const{wrapper:MDXLayout}=Object.assign({},(0,_storybook_addon_essentials_docs_mdx_react_shim__WEBPACK_IMPORTED_MODULE_3__.ah)(),props.components);return MDXLayout?(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(MDXLayout,{...props,children:(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(_createMdxContent,{...props})}):_createMdxContent(props)}};const __WEBPACK_DEFAULT_EXPORT__=componentMeta}}]);