/*! For license information please see 4218.3daf1756.iframe.bundle.js.LICENSE.txt */
"use strict";(self.webpackChunkwonder_blocks=self.webpackChunkwonder_blocks||[]).push([[4218],{"./node_modules/@mdx-js/react/lib/index.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{NF:()=>withMDXComponents,Zo:()=>MDXProvider,ah:()=>useMDXComponents,pC:()=>MDXContext});var react__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/react/index.js");const MDXContext=react__WEBPACK_IMPORTED_MODULE_0__.createContext({});function withMDXComponents(Component){return function boundMDXComponent(props){const allComponents=useMDXComponents(props.components);return react__WEBPACK_IMPORTED_MODULE_0__.createElement(Component,{...props,allComponents})}}function useMDXComponents(components){const contextComponents=react__WEBPACK_IMPORTED_MODULE_0__.useContext(MDXContext);return react__WEBPACK_IMPORTED_MODULE_0__.useMemo((()=>"function"==typeof components?components(contextComponents):{...contextComponents,...components}),[contextComponents,components])}const emptyObject={};function MDXProvider({components,children,disableParentContext}){let allComponents;return allComponents=disableParentContext?"function"==typeof components?components({}):components||emptyObject:useMDXComponents(components),react__WEBPACK_IMPORTED_MODULE_0__.createElement(MDXContext.Provider,{value:allComponents},children)}},"./packages/wonder-blocks-data/dist/es/index.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{Vw:()=>Data,Q5:()=>GqlRouter,uk:()=>InterceptRequests,t6:()=>TrackData});var es=__webpack_require__("./packages/wonder-blocks-core/dist/es/index.js"),t=e=>null==e||"object"!=typeof e?e:Array.isArray(e)?e.map(t):Object.keys(e).reduce(((n,r)=>(n[r]=t(e[r]),n)),{}),n=Object.freeze({Unknown:"Unknown",Internal:"Internal",InvalidInput:"InvalidInput",InvalidUse:"InvalidUse",NotFound:"NotFound",NotAllowed:"NotAllowed",Unauthorized:"Unauthorized",NotImplemented:"NotImplemented"});function r(t,e,n){return(e=function(t){var e=function(t,e){if("object"!=typeof t||null===t)return t;var n=t[Symbol.toPrimitive];if(void 0!==n){var r=n.call(t,"string");if("object"!=typeof r)return r;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(t)}(t);return"symbol"==typeof e?e:String(e)}(e))in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}class s{constructor(t,e,n){r(this,"_name",void 0),r(this,"_message",void 0),r(this,"_stackFrames",void 0),this._name=t,this._message=e,this._stackFrames=[...n]}get message(){return this._message}get name(){return this._name}get messageWithName(){return"".concat(this.name,": ").concat(this.message)}get stack(){return[...this._stackFrames]}get standardizedStack(){return"".concat(this.messageWithName,"\n").concat(this._stackFrames.join("\n"))}static fromConsequenceAndCause(t,e){var n;for(var r=[],i=e.stack,a=null!==(n=null==t?void 0:t.stack)&&void 0!==n?n:[],o=i.length-1,c=a.length-1;o>=0&&c>=0&&i[o]===a[c];)r.unshift(i[o]),o--,c--;for(;o>=0;o--)r.unshift(i[o]);for(;c>=0;c--)r.unshift(a[c]);return new s(t.name,((t,e)=>{var n=t=>(null==t?void 0:t.trim())||"(empty message)",r=n(t);return null==e?r:"".concat(r,"\n\tcaused by\n\t\t").concat(n(e))})(t.message,e.messageWithName),r)}static normalize(t){var e,n,r,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;var o=null!==(e=t.message.toString().split("\n").find((t=>t.trim().length)))&&void 0!==e?e:"(empty message)",c=t.toString(),u=(null!==(n=t.stack)&&void 0!==n&&n.startsWith(c)&&t.stack!==c?t.stack.substring(c.length):null!==(r=t.stack)&&void 0!==r?r:"").split("\n").filter((t=>t.trim().length)),l=u.length>=i+a?i:0;return new s(t.name,o,u.slice(l))}static from(t){var e,n;var r=t.toString(),i=(null!==(e=t.stack)&&void 0!==e&&e.startsWith(r)&&t.stack!==r?t.stack.substring(r.length):null!==(n=t.stack)&&void 0!==n?n:"").split("\n").filter((t=>t.trim().length));return new s(t.name,t.message,i)}}class i extends Error{constructor(e){var i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:n.Unknown,{cause:a,prefix:o,name:c,metadata:u,stripStackFrames:l,minimumFrameCount:m,compositeStack:f}=arguments.length>2&&void 0!==arguments[2]?arguments[2]:Object.freeze({});super(e),r(this,"kind",void 0),r(this,"originalMessage",void 0),r(this,"originalStack",void 0),r(this,"metadata",void 0),r(this,"cause",void 0),this.originalMessage=e,this.metadata=(e=>{if(null==e)return e;var n=t(e);return Object.freeze(n)})(u),this.name="".concat(null!=o?o:"").concat(i).concat(null!=c?c:"","Error"),this.kind=i,this.originalStack=this.stack,this.cause=a;var d=s.normalize(this,null!=l?l:0,null!=m?m:1);if(delete this.stack,this.stack=d.standardizedStack,null!=a){var h=s.from(a),v=s.fromConsequenceAndCause(d,h);this.message=v.message,!0===f&&(this.stack=v.standardizedStack)}}}Object.freeze({ConsequenceFirst:"consequence-first",CauseFirst:"cause-first"});var react=__webpack_require__("./node_modules/react/index.js");const FetchPolicy={CacheBeforeNetwork:"CacheBeforeNetwork",CacheAndNetwork:"CacheAndNetwork",CacheOnly:"CacheOnly",NetworkOnly:"NetworkOnly"},DataErrors=Object.freeze({Unknown:"Unknown",Internal:"Internal",InvalidInput:"InvalidInput",Network:"Network",NotAllowed:"NotAllowed",Parse:"Parse",Hydrated:"Hydrated"});class DataError extends i{constructor(message,kind,{metadata,cause}={}){super(message,kind,{metadata,cause,name:"Data"})}}class ScopedInMemoryCache{constructor(initialCache={}){this._cache=void 0,this._cache=initialCache}get inUse(){return Object.keys(this._cache).length>0}set(scope,id,value){var _this$_cache$scope;if(!id||"string"!=typeof id)throw new DataError("id must be non-empty string",DataErrors.InvalidInput);if(!scope||"string"!=typeof scope)throw new DataError("scope must be non-empty string",DataErrors.InvalidInput);if("function"==typeof value)throw new DataError("value must be a non-function value",DataErrors.InvalidInput);this._cache[scope]=null!=(_this$_cache$scope=this._cache[scope])?_this$_cache$scope:{},this._cache[scope][id]=value}get(scope,id){var _this$_cache$scope$id,_this$_cache$scope2;return null!=(_this$_cache$scope$id=null==(_this$_cache$scope2=this._cache[scope])?void 0:_this$_cache$scope2[id])?_this$_cache$scope$id:null}purge(scope,id){var _this$_cache$scope3;null!=(_this$_cache$scope3=this._cache[scope])&&_this$_cache$scope3[id]&&(delete this._cache[scope][id],0===Object.keys(this._cache[scope]).length&&delete this._cache[scope])}purgeScope(scope,predicate){if(this._cache[scope])if(null!=predicate){for(const key of Object.keys(this._cache[scope]))predicate(key,this._cache[scope][key])&&delete this._cache[scope][key];0===Object.keys(this._cache[scope]).length&&delete this._cache[scope]}else delete this._cache[scope]}purgeAll(predicate){if(null!=predicate)for(const scope of Object.keys(this._cache))this.purgeScope(scope,((id,value)=>predicate(scope,id,value)));else this._cache={}}}class SerializableInMemoryCache extends ScopedInMemoryCache{constructor(initialCache={}){try{super(t(initialCache))}catch(e){throw new DataError(`An error occurred trying to initialize from a response cache snapshot: ${e}`,DataErrors.InvalidInput)}}set(scope,id,value){super.set(scope,id,Object.freeze(t(value)))}clone(){try{return t(this._cache)}catch(e){throw new DataError("An error occurred while trying to clone the cache",DataErrors.Internal,{cause:e})}}}let _default$2;class SsrCache{static get Default(){return _default$2||(_default$2=new SsrCache),_default$2}constructor(hydrationCache=null,ssrOnlyCache=null){this._hydrationCache=void 0,this._ssrOnlyCache=void 0,this.initialize=source=>{if(this._hydrationCache.inUse)throw new Error("Cannot initialize data response cache more than once");this._hydrationCache=new SerializableInMemoryCache({default:source})},this.cacheData=(id,data,hydrate)=>this._setCachedResponse(id,{data},hydrate),this.cacheError=(id,error,hydrate)=>{const errorMessage="string"==typeof error?error:error.message;return this._setCachedResponse(id,{error:errorMessage},hydrate)},this.getEntry=id=>{const ssrEntry=es.xF.isServerSide()?this._ssrOnlyCache.get("default",id):null,internalEntry=null!=ssrEntry?ssrEntry:this._hydrationCache.get("default",id);return es.xF.isServerSide()||null==internalEntry||this._hydrationCache.purge("default",id),internalEntry},this.purgeData=predicate=>{const realPredicate=predicate?(_,key,cachedEntry)=>predicate(key,cachedEntry):void 0;this._hydrationCache.purgeAll(realPredicate),this._ssrOnlyCache.purgeAll(realPredicate)},this.cloneHydratableData=()=>{var _cache$DefaultScope;return null!=(_cache$DefaultScope=this._hydrationCache.clone().default)?_cache$DefaultScope:{}},this._ssrOnlyCache=ssrOnlyCache||new SerializableInMemoryCache,this._hydrationCache=hydrationCache||new SerializableInMemoryCache}_setCachedResponse(id,entry,hydrate){const frozenEntry=Object.freeze(entry);return es.xF.isServerSide()&&(hydrate?this._hydrationCache.set("default",id,frozenEntry):this._ssrOnlyCache.set("default",id,frozenEntry)),frozenEntry}}function _extends(){return _extends=Object.assign?Object.assign.bind():function(target){for(var i=1;i<arguments.length;i++){var source=arguments[i];for(var key in source)Object.prototype.hasOwnProperty.call(source,key)&&(target[key]=source[key])}return target},_extends.apply(this,arguments)}let _default$1;class RequestFulfillment{constructor(){this._requests={},this.fulfill=(id,{handler,hydrate:_hydrate=!0})=>{const inflight=this._requests[id];if(inflight)return inflight;const request=handler().then((data=>({status:"success",data}))).catch((error=>{const actualError="string"==typeof error?new DataError("Request failed",DataErrors.Unknown,{metadata:{unexpectedError:error}}):error;return"AbortError"===actualError.name?{status:"aborted"}:{status:"error",error:actualError}})).finally((()=>{delete this._requests[id]}));return this._requests[id]=request,request},this.abort=id=>{delete this._requests[id]},this.abortAll=()=>{Object.keys(this._requests).forEach((id=>this.abort(id)))}}static get Default(){return _default$1||(_default$1=new RequestFulfillment),_default$1}}const TrackerContext=react.createContext(null);let _default;TrackerContext.displayName="TrackerContext";class RequestTracker{static get Default(){return _default||(_default=new RequestTracker),_default}constructor(responseCache=void 0){this._trackedRequests={},this._responseCache=void 0,this._requestFulfillment=void 0,this.trackDataRequest=(id,handler,hydrate)=>{null==this._trackedRequests[id]&&(this._trackedRequests[id]={handler,hydrate})},this.reset=()=>{this._trackedRequests={}},this.fulfillTrackedRequests=()=>{const promises=[],{cacheData,cacheError}=this._responseCache;for(const requestKey of Object.keys(this._trackedRequests)){const options=this._trackedRequests[requestKey];try{promises.push(this._requestFulfillment.fulfill(requestKey,_extends({},options)).then((result=>{switch(result.status){case"success":cacheData(requestKey,result.data,options.hydrate);break;case"error":cacheError(requestKey,result.error,options.hydrate)}})))}catch(e){promises.push(Promise.resolve(cacheError(requestKey,e,options.hydrate)))}}return this.reset(),Promise.all(promises).then((()=>this._responseCache.cloneHydratableData()))},this._responseCache=responseCache||SsrCache.Default,this._requestFulfillment=new RequestFulfillment}get hasUnfulfilledRequests(){return Object.keys(this._trackedRequests).length>0}}const cache$1=new ScopedInMemoryCache,useSharedCache=(id,scope,initialValue)=>{if(!id||"string"!=typeof id)throw new DataError("id must be a non-empty string",DataErrors.InvalidInput);if(!scope||"string"!=typeof scope)throw new DataError("scope must be a non-empty string",DataErrors.InvalidInput);const cacheValue=react.useCallback((value=>null==value?cache$1.purge(scope,id):cache$1.set(scope,id,value)),[id,scope]);let currentValue=cache$1.get(scope,id);if(null==currentValue&&void 0!==initialValue){const value="function"==typeof initialValue?initialValue():initialValue;null!=value&&(cacheValue(value),currentValue=value)}return[currentValue,cacheValue]};class TrackData extends react.Component{render(){if(!es.xF.isServerSide())throw new Error("This component is not for use during client-side rendering");return react.createElement(TrackerContext.Provider,{value:RequestTracker.Default.trackDataRequest},this.props.children)}}TrackData.displayName="TrackData";const loadingStatus=Object.freeze({status:"loading"}),abortedStatus=Object.freeze({status:"aborted"}),Status=Object.freeze({loading:()=>loadingStatus,aborted:()=>abortedStatus,success:data=>({status:"success",data}),error:error=>({status:"error",error})}),InterceptContext=react.createContext([]);InterceptContext.displayName="InterceptContext";const useRequestInterception=(requestId,handler)=>{const interceptors=react.useContext(InterceptContext);return react.useCallback((()=>{const interceptResponse=interceptors.reduceRight(((prev,interceptor)=>null!=prev?prev:interceptor(requestId)),null);return null!=interceptResponse?interceptResponse:handler()}),[handler,interceptors,requestId])},useServerEffect=(requestId,handler,options={})=>{const{hydrate=!0,skip=!1}=options,interceptedHandler=useRequestInterception(requestId,handler),cachedResult=SsrCache.Default.getEntry(requestId),maybeTrack=(0,react.useContext)(TrackerContext);return!skip&&null==cachedResult&&es.xF.isServerSide()&&(null==maybeTrack||maybeTrack(requestId,interceptedHandler,hydrate)),null==cachedResult?null:(cacheEntry=>{if(null==cacheEntry)return null;const{data,error}=cacheEntry;return null!=error?Status.error(new DataError(error,DataErrors.Hydrated)):null!=data?Status.success(data):Status.aborted()})(cachedResult)},DefaultScope$1="useCachedEffect",WhenClientSide={DoNotHydrate:"DoNotHydrate",ExecuteWhenNoResult:"ExecuteWhenNoResult",ExecuteWhenNoSuccessResult:"ExecuteWhenNoSuccessResult",AlwaysExecute:"AlwaysExecute"},DefaultScope="useHydratableEffect",useHydratableEffect=(requestId,handler,options={})=>{const{clientBehavior=WhenClientSide.ExecuteWhenNoSuccessResult,skip=!1,retainResultOnChange=!1,onResultChanged,scope=DefaultScope}=options,serverResult=useServerEffect(requestId,handler,{hydrate:clientBehavior!==WhenClientSide.DoNotHydrate,skip}),getDefaultCacheValue=react.useCallback((()=>{switch(clientBehavior){case WhenClientSide.DoNotHydrate:case WhenClientSide.AlwaysExecute:return null;case WhenClientSide.ExecuteWhenNoResult:return serverResult;case WhenClientSide.ExecuteWhenNoSuccessResult:return"success"===(null==serverResult?void 0:serverResult.status)?serverResult:null}}),[serverResult]);useSharedCache(requestId,scope,getDefaultCacheValue);const[clientResult]=((requestId,handler,options={})=>{var _ref;const{fetchPolicy=FetchPolicy.CacheBeforeNetwork,skip:hardSkip=!1,retainResultOnChange=!1,onResultChanged,scope=DefaultScope$1}=options,interceptedHandler=useRequestInterception(requestId,handler),[mostRecentResult,setMostRecentResult]=useSharedCache(requestId,scope),forceUpdate=(0,es.NW)(),networkResultRef=react.useRef(),currentRequestRef=react.useRef(),fetchRequest=react.useMemo((()=>{var _currentRequestRef$cu;return null==(_currentRequestRef$cu=currentRequestRef.current)||_currentRequestRef$cu.cancel(),currentRequestRef.current=null,networkResultRef.current=null,()=>{var _currentRequestRef$cu2,_currentRequestRef$cu3;if(fetchPolicy===FetchPolicy.CacheOnly)throw new DataError("Cannot fetch with CacheOnly policy",DataErrors.NotAllowed);const request=RequestFulfillment.Default.fulfill(`${requestId}|${scope}`,{handler:interceptedHandler});if(request===(null==(_currentRequestRef$cu2=currentRequestRef.current)?void 0:_currentRequestRef$cu2.request))return;networkResultRef.current=null,null==(_currentRequestRef$cu3=currentRequestRef.current)||_currentRequestRef$cu3.cancel();let cancel=!1;request.then((result=>{currentRequestRef.current=null,cancel||(setMostRecentResult(result),networkResultRef.current=result,null!=onResultChanged?onResultChanged(result):forceUpdate())})),currentRequestRef.current={requestId,request,cancel(){cancel=!0,RequestFulfillment.Default.abort(requestId)}}}}),[requestId,onResultChanged,forceUpdate,setMostRecentResult,fetchPolicy]),shouldFetch=react.useMemo((()=>{if(hardSkip)return!1;switch(fetchPolicy){case FetchPolicy.CacheOnly:return!1;case FetchPolicy.CacheBeforeNetwork:return null==mostRecentResult;case FetchPolicy.CacheAndNetwork:case FetchPolicy.NetworkOnly:return null==networkResultRef.current}}),[mostRecentResult,fetchPolicy,hardSkip]);react.useEffect((()=>{if(shouldFetch)return fetchRequest(),()=>{var _currentRequestRef$cu4;null==(_currentRequestRef$cu4=currentRequestRef.current)||_currentRequestRef$cu4.cancel(),currentRequestRef.current=null}}),[shouldFetch,fetchRequest]);const lastResultAgnosticOfIdRef=react.useRef(Status.loading()),loadingResult=retainResultOnChange?lastResultAgnosticOfIdRef.current:Status.loading(),result=null!=(_ref=fetchPolicy===FetchPolicy.NetworkOnly?networkResultRef.current:mostRecentResult)?_ref:loadingResult;return lastResultAgnosticOfIdRef.current=result,[result,fetchRequest]})(requestId,handler,{skip,onResultChanged,retainResultOnChange,scope,fetchPolicy:FetchPolicy.CacheBeforeNetwork});return null!=serverResult?serverResult:clientResult},Data=({requestId,handler,children,retainResultOnChange:_retainResultOnChange=!1,clientBehavior:_clientBehavior=WhenClientSide.ExecuteWhenNoSuccessResult})=>children(useHydratableEffect(requestId,handler,{retainResultOnChange:_retainResultOnChange,clientBehavior:_clientBehavior})),InterceptRequests=({interceptor,children})=>{const interceptors=react.useContext(InterceptContext),updatedInterceptors=react.useMemo((()=>[...interceptors,interceptor]),[interceptors,interceptor]);return react.createElement(InterceptContext.Provider,{value:updatedInterceptors},children)};Object.freeze({Internal:"Internal",BadResponse:"BadResponse",ErrorResult:"ErrorResult"});Object.freeze({query:"query",mutation:"mutation"}),new Map;const GqlRouterContext=react.createContext(null);GqlRouterContext.displayName="GqlRouterContext";const GqlRouter=({defaultContext:thisDefaultContext,fetch:thisFetch,children})=>{const configuration=react.useMemo((()=>({fetch:thisFetch,defaultContext:thisDefaultContext})),[thisDefaultContext,thisFetch]);return react.createElement(GqlRouterContext.Provider,{value:configuration},children)};GqlRouter.__docgenInfo={description:"",methods:[],displayName:"GqlRouter"},InterceptRequests.__docgenInfo={description:"",methods:[],displayName:"InterceptRequests"},TrackData.__docgenInfo={description:"",methods:[],displayName:"TrackData"}},"./node_modules/react/cjs/react-jsx-runtime.production.min.js":(__unused_webpack_module,exports,__webpack_require__)=>{var f=__webpack_require__("./node_modules/react/index.js"),g=60103;if(exports.Fragment=60107,"function"==typeof Symbol&&Symbol.for){var h=Symbol.for;g=h("react.element"),exports.Fragment=h("react.fragment")}var m=f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,n=Object.prototype.hasOwnProperty,p={key:!0,ref:!0,__self:!0,__source:!0};function q(c,a,k){var b,d={},e=null,l=null;for(b in void 0!==k&&(e=""+k),void 0!==a.key&&(e=""+a.key),void 0!==a.ref&&(l=a.ref),a)n.call(a,b)&&!p.hasOwnProperty(b)&&(d[b]=a[b]);if(c&&c.defaultProps)for(b in a=c.defaultProps)void 0===d[b]&&(d[b]=a[b]);return{$$typeof:g,type:c,key:e,ref:l,props:d,_owner:m.current}}exports.jsx=q,exports.jsxs=q},"./node_modules/react/jsx-runtime.js":(module,__unused_webpack_exports,__webpack_require__)=>{module.exports=__webpack_require__("./node_modules/react/cjs/react-jsx-runtime.production.min.js")}}]);